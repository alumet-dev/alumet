//! Measure cgroup v2 things.

use std::u8;

/// CPU statistics for cgroup v2.
pub mod cpu {
    use std::{fs::File, io, path::Path};

    use super::LineIndex;
    use crate::measure::parse::{SelectiveStatFile, StatFileBuilder};

    /// Collects measurements from `cpu.stat`.
    pub struct CpuStatCollector {
        stat_file: SelectiveStatFile,
        mapping: CpuStatMapping,
    }

    #[derive(Default)]
    struct CpuStatMapping {
        usage: LineIndex,
        user: LineIndex,
        system: LineIndex,
    }

    pub struct CpuStatCollectorSettings {
        pub keys: Vec<String>,
    }

    /// Represents the measurements extracted from the `cpu.stat` file.
    #[derive(Debug, Default)]
    pub struct CpuStats {
        pub usage: Option<u64>,
        pub user: Option<u64>,
        pub system: Option<u64>,
        // could be extended to manage other measurements
    }

    impl CpuStatCollector {
        pub fn new<P: AsRef<Path>>(
            path: P,
            settings: CpuStatCollectorSettings,
            io_buf: &mut Vec<u8>,
        ) -> io::Result<Self> {
            let file = File::open(path)?;

            let (stat_file, stat_mapping) = StatFileBuilder::new(file, &settings.keys).build(io_buf.as_mut())?;

            let mut mapping = CpuStatMapping::default();
            if let Some(i) = stat_mapping.line_index("usage_usec") {
                mapping.usage = i.into();
            }
            if let Some(i) = stat_mapping.line_index("user_usec") {
                mapping.user = i.into();
            }
            if let Some(i) = stat_mapping.line_index("system_usec") {
                mapping.system = i.into();
            }

            Ok(Self { stat_file, mapping })
        }

        /// Collects measurements from the underlying "file", using `io_buf` as an intermediary I/O buffer.
        pub fn measure(&mut self, io_buf: &mut Vec<u8>) -> io::Result<CpuStats> {
            let mut res = CpuStats::default();
            unsafe {
                self.stat_file.read(io_buf, |i, _k, v| match i {
                    i if i == self.mapping.usage.0 => {
                        res.usage = Some(v);
                    }
                    i if i == self.mapping.user.0 => {
                        res.user = Some(v);
                    }
                    i if i == self.mapping.system.0 => {
                        res.system = Some(v);
                    }
                    _ => (),
                })
            }?;
            Ok(res)
        }
    }
}

/// Memory statistics for cgroup v2.
pub mod memory {
    use std::{fs::File, io, path::Path};

    use crate::measure::{
        parse::{SelectiveStatFile, StatFileBuilder, U64File},
        v2::LineIndex,
    };

    /// Collects measurements from `memory.current`.
    pub struct MemoryCurrentCollector {
        file: U64File,
    }

    /// Collects measurements from `memory.stat`.
    pub struct MemoryStatCollector {
        stat_file: SelectiveStatFile,
        mapping: MemoryStatMapping,
    }

    /// Represents the measurements extracted from the `memory.stat` file.
    #[derive(Default)]
    pub struct MemoryStats {
        anon: Option<u64>,
        file: Option<u64>,
        kernel_stack: Option<u64>,
        page_tables: Option<u64>,
        // could be extended to manage other memory.stat measurements
    }

    #[derive(Default)]
    struct MemoryStatMapping {
        anon: LineIndex,
        file: LineIndex,
        kernel_stack: LineIndex,
        page_tables: LineIndex,
    }

    pub struct MemoryStatCollectorSettings {
        pub keys: Vec<String>,
    }

    impl MemoryCurrentCollector {
        pub fn new<P: AsRef<Path>>(path: P) -> io::Result<Self> {
            let file = U64File::open(path)?;
            Ok(Self { file })
        }

        /// Collects measurements from the underlying "file", using `io_buf` as an intermediary I/O buffer.
        pub fn measure(&mut self, io_buf: &mut Vec<u8>) -> io::Result<u64> {
            // SAFETY: the content is generated by the kernel and is always valid ASCII (hence valid UTF-8)
            unsafe { self.file.read(io_buf) }
        }
    }

    impl MemoryStatCollector {
        pub fn new<P: AsRef<Path>>(
            path: P,
            settings: MemoryStatCollectorSettings,
            io_buf: &mut Vec<u8>,
        ) -> io::Result<Self> {
            let file = File::open(path)?;

            let (stat_file, stat_mapping) = StatFileBuilder::new(file, &settings.keys).build(io_buf.as_mut())?;

            let mut mapping = MemoryStatMapping::default();
            if let Some(i) = stat_mapping.line_index("anon") {
                mapping.anon = i.into();
            }
            if let Some(i) = stat_mapping.line_index("file") {
                mapping.file = i.into();
            }
            if let Some(i) = stat_mapping.line_index("kernel_stack") {
                mapping.kernel_stack = i.into();
            }
            if let Some(i) = stat_mapping.line_index("pagetables") {
                mapping.page_tables = i.into();
            }
            Ok(Self { stat_file, mapping })
        }

        /// Collects measurements from the underlying "file", using `io_buf` as an intermediary I/O buffer.
        pub fn measure(&mut self, io_buf: &mut Vec<u8>) -> io::Result<MemoryStats> {
            let mut res = MemoryStats::default();
            unsafe {
                self.stat_file.read(io_buf, |i, _k, v| match i {
                    i if i == self.mapping.anon.0 => {
                        res.anon = Some(v);
                    }
                    i if i == self.mapping.file.0 => {
                        res.file = Some(v);
                    }
                    i if i == self.mapping.kernel_stack.0 => {
                        res.kernel_stack = Some(v);
                    }
                    i if i == self.mapping.page_tables.0 => {
                        res.page_tables = Some(v);
                    }
                    _ => (),
                })
            }?;
            Ok(res)
        }
    }
}

/// An `u8` with a default value of `u8::MAX`.
///
/// # Why?
/// This type allows to `derive(Default)` for the mapping structs.
///
/// The stat file contains less than 64 lines, and SelectiveStatFile only supports up to 64 lines.
/// Use a value above 63 as the default value, so that it is never equal to a line index.
/// This is more efficient than using an Option: 1 byte instead of 2, and no additional branch when comparing to the line index.
struct LineIndex(pub u8);

impl Default for LineIndex {
    fn default() -> Self {
        Self(u8::MAX)
    }
}

impl From<u8> for LineIndex {
    fn from(value: u8) -> Self {
        Self(value)
    }
}

impl From<LineIndex> for u8 {
    fn from(value: LineIndex) -> Self {
        value.0
    }
}

/// Mocks for testing.
#[cfg(feature = "manually")]
pub mod mock {
    use std::{fmt::Display, fs::File};

    use serde::{Serialize, ser::Serializer};
    use thiserror::Error;

    #[derive(Serialize, Debug, Default)]
    pub struct CpuStatMock {
        pub usage_usec: u64,
        pub user_usec: u64,
        pub system_usec: u64,
        pub nr_periods: u64,
        pub nr_throttled: u64,
        pub throttled_usec: u64,
        pub nr_bursts: u64,
        pub burst_usec: u64,
    }

    #[derive(Serialize, Debug, Default)]
    pub struct MemoryStatMock {
        pub anon: u64,
        pub file: u64,
        pub kernel: u64,
        pub kernel_stack: u64,
        pub pagetables: u64,
        pub sec_pagetables: u64,
        pub percpu: u64,
        pub sock: u64,
        pub vmalloc: u64,
        pub shmem: u64,
        pub zswap: u64,
        pub zswapped: u64,
        pub file_mapped: u64,
        pub file_dirty: u64,
        pub file_writeback: u64,
        pub swapcached: u64,
        pub anon_thp: u64,
        pub file_thp: u64,
        pub shmem_thp: u64,
        pub inactive_anon: u64,
        pub active_anon: u64,
        pub inactive_file: u64,
        pub active_file: u64,
        pub unevictable: u64,
        pub slab_reclaimable: u64,
        pub slab_unreclaimable: u64,
        pub slab: u64,
        pub workingset_refault_anon: u64,
        pub workingset_refault_file: u64,
        pub workingset_activate_anon: u64,
        pub workingset_activate_file: u64,
        pub workingset_restore_anon: u64,
        pub workingset_restore_file: u64,
        pub workingset_nodereclaim: u64,
        pub pswpin: u64,
        pub pswpout: u64,
        pub pgscan: u64,
        pub pgsteal: u64,
        pub pgscan_kswapd: u64,
        pub pgscan_direct: u64,
        pub pgscan_khugepaged: u64,
        pub pgscan_proactive: u64,
        pub pgsteal_kswapd: u64,
        pub pgsteal_direct: u64,
        pub pgsteal_khugepaged: u64,
        pub pgsteal_proactive: u64,
        pub pgfault: u64,
        pub pgmajfault: u64,
        pub pgrefill: u64,
        pub pgactivate: u64,
        pub pgdeactivate: u64,
        pub pglazyfree: u64,
        pub pglazyfreed: u64,
        pub swpin_zero: u64,
        pub swpout_zero: u64,
        pub zswpin: u64,
        pub zswpout: u64,
        pub zswpwb: u64,
        pub thp_fault_alloc: u64,
        pub thp_collapse_alloc: u64,
        pub thp_swpout: u64,
        pub thp_swpout_fallback: u64,
        pub numa_pages_migrated: u64,
        pub numa_pte_updates: u64,
        pub numa_hint_faults: u64,
        pub pgdemote_kswapd: u64,
        pub pgdemote_direct: u64,
        pub pgdemote_khugepaged: u64,
        pub pgdemote_proactive: u64,
        pub hugetlb: u64,
    }

    pub trait MockFileCgroupKV {
        fn serialize_to_string(&self) -> anyhow::Result<String>;

        fn write_to_file(&self, file: &mut File) -> anyhow::Result<()> {
            use std::io::Write;
            writeln!(file, "{}", self.serialize_to_string()?)?;
            file.flush()?;
            Ok(())
        }
    }

    impl<S: Serialize> MockFileCgroupKV for S {
        fn serialize_to_string(&self) -> anyhow::Result<String> {
            let res = self.serialize(StatSerializer)?;
            Ok(res)
        }
    }

    #[derive(Debug, Error)]
    pub enum SerializationError {
        #[error("unsupported type")]
        UnsupportedType,
        #[error("{0}")]
        Message(String),
    }

    impl serde::ser::Error for SerializationError {
        fn custom<T: Display>(msg: T) -> Self {
            Self::Message(msg.to_string())
        }
    }

    pub struct StatSerializer;

    impl Serializer for StatSerializer {
        type Ok = String;
        type Error = SerializationError;

        type SerializeSeq = Impossible<String, Self::Error>;
        type SerializeTuple = Impossible<String, Self::Error>;
        type SerializeTupleStruct = Impossible<String, Self::Error>;
        type SerializeTupleVariant = Impossible<String, Self::Error>;
        type SerializeMap = Impossible<String, Self::Error>;
        type SerializeStruct = SerializeStructWrapper;
        type SerializeStructVariant = Impossible<String, Self::Error>;

        fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_str(self, v: &str) -> Result<Self::Ok, Self::Error> {
            Ok(v.to_string())
        }

        fn serialize_bytes(self, _v: &[u8]) -> Result<Self::Ok, Self::Error> {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_none(self) -> Result<Self::Ok, Self::Error> {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_some<T: ?Sized>(self, _value: &T) -> Result<Self::Ok, Self::Error>
        where
            T: serde::Serialize,
        {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_unit_struct(self, _name: &'static str) -> Result<Self::Ok, Self::Error> {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_unit_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            _variant: &'static str,
        ) -> Result<Self::Ok, Self::Error> {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_newtype_struct<T: ?Sized>(self, _name: &'static str, _value: &T) -> Result<Self::Ok, Self::Error>
        where
            T: serde::Serialize,
        {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_newtype_variant<T: ?Sized>(
            self,
            _name: &'static str,
            _variant_index: u32,
            _variant: &'static str,
            _value: &T,
        ) -> Result<Self::Ok, Self::Error>
        where
            T: serde::Serialize,
        {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple, Self::Error> {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_tuple_struct(
            self,
            _name: &'static str,
            _len: usize,
        ) -> Result<Self::SerializeTupleStruct, Self::Error> {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_tuple_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            _variant: &'static str,
            _len: usize,
        ) -> Result<Self::SerializeTupleVariant, Self::Error> {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {
            Err(SerializationError::UnsupportedType)
        }

        fn serialize_struct(self, _name: &'static str, len: usize) -> Result<Self::SerializeStruct, Self::Error> {
            Ok(SerializeStructWrapper {
                fields: Vec::with_capacity(len),
            })
        }

        fn serialize_struct_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            _variant: &'static str,
            _len: usize,
        ) -> Result<Self::SerializeStructVariant, Self::Error> {
            Err(SerializationError::UnsupportedType)
        }
    }

    pub struct SerializeStructWrapper {
        fields: Vec<String>,
    }

    impl serde::ser::SerializeStruct for SerializeStructWrapper {
        type Ok = String;
        type Error = SerializationError;

        fn serialize_field<T: ?Sized>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>
        where
            T: serde::Serialize,
        {
            let value_str = value.serialize(StatSerializer)?;
            self.fields.push(format!("{key} {value_str}"));
            Ok(())
        }

        fn end(self) -> Result<String, Self::Error> {
            Ok(self.fields.join("\n"))
        }
    }

    pub struct Impossible<T, E> {
        _marker: std::marker::PhantomData<(T, E)>,
    }

    impl<T, E: serde::ser::Error> serde::ser::SerializeSeq for Impossible<T, E> {
        type Ok = T;
        type Error = E;

        fn serialize_element<U: ?Sized>(&mut self, _value: &U) -> Result<(), Self::Error>
        where
            U: serde::Serialize,
        {
            unreachable!()
        }

        fn end(self) -> Result<T, E> {
            unreachable!()
        }
    }

    impl<T, E: serde::ser::Error> serde::ser::SerializeTuple for Impossible<T, E> {
        type Ok = T;
        type Error = E;

        fn serialize_element<U: ?Sized>(&mut self, _value: &U) -> Result<(), Self::Error>
        where
            U: serde::Serialize,
        {
            unreachable!()
        }

        fn end(self) -> Result<T, E> {
            unreachable!()
        }
    }

    impl<T, E: serde::ser::Error> serde::ser::SerializeTupleStruct for Impossible<T, E> {
        type Ok = T;
        type Error = E;

        fn serialize_field<U: ?Sized>(&mut self, _value: &U) -> Result<(), Self::Error>
        where
            U: serde::Serialize,
        {
            unreachable!()
        }

        fn end(self) -> Result<T, E> {
            unreachable!()
        }
    }

    impl<T, E: serde::ser::Error> serde::ser::SerializeTupleVariant for Impossible<T, E> {
        type Ok = T;
        type Error = E;

        fn serialize_field<U: ?Sized>(&mut self, _value: &U) -> Result<(), Self::Error>
        where
            U: serde::Serialize,
        {
            unreachable!()
        }

        fn end(self) -> Result<T, E> {
            unreachable!()
        }
    }

    impl<T, E: serde::ser::Error> serde::ser::SerializeMap for Impossible<T, E> {
        type Ok = T;
        type Error = E;

        fn serialize_key<U: ?Sized>(&mut self, _key: &U) -> Result<(), Self::Error>
        where
            U: serde::Serialize,
        {
            unreachable!()
        }

        fn serialize_value<U: ?Sized>(&mut self, _value: &U) -> Result<(), Self::Error>
        where
            U: serde::Serialize,
        {
            unreachable!()
        }

        fn end(self) -> Result<T, E> {
            unreachable!()
        }
    }

    impl<T, E: serde::ser::Error> serde::ser::SerializeStructVariant for Impossible<T, E> {
        type Ok = T;
        type Error = E;

        fn serialize_field<U: ?Sized>(&mut self, _key: &'static str, _value: &U) -> Result<(), Self::Error>
        where
            U: serde::Serialize,
        {
            unreachable!()
        }

        fn end(self) -> Result<T, E> {
            unreachable!()
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use pretty_assertions::assert_eq;

        #[test]
        fn serialize_mock() {
            let mock = CpuStatMock {
                usage_usec: 0,
                user_usec: 1,
                system_usec: 123,
                nr_periods: 123,
                nr_throttled: 123,
                throttled_usec: 123,
                nr_bursts: 123,
                burst_usec: 123456789,
            };
            let s = mock.serialize_to_string().unwrap();
            const EXPECTED: &str = "usage_usec 0
user_usec 1
system_usec 123
nr_periods 123
nr_throttled 123
throttled_usec 123
nr_bursts 123
burst_usec 123456789";
            assert_eq!(s, EXPECTED);
        }
    }
}
