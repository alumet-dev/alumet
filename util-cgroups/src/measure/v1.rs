//! Measure cgroup v1 things.

use anyhow::Context;
use std::io::{self};

use crate::{measure::parse::U64File, Cgroup, CgroupHierarchy};

/// Collects cgroup v1 measurements.
pub struct V1Collector {
    cpuacct_usage: Option<U64File>,
    memory_stat: Option<U64File>,
}

/// The result of a cgroupv1 measurement operation.
pub struct V1Stats {
    pub cpuacct_usage: Option<u64>,
    pub memory_stat: Option<u64>,
}

impl V1Collector {
    /// Creates a new collector that gathers data from multiple cgroup hierarchies.
    ///
    /// # Available metrics
    /// The probe can only measure what is provided by the cgroup controllers attached to the given hierarchies.
    /// For instance, if one hierarchy has the `cpuacct` controller, and another one has the `memory` controller,
    /// the probe reads both `cpuacct.usage` and `memory.stat` (in their respective hierarchies).
    pub fn across_hierarchies(cgroup_path: &str, hierarchies: &[&CgroupHierarchy]) -> anyhow::Result<Self> {
        let mut cpuacct_usage = None;
        let mut memory_stat = None;
        for h in hierarchies {
            let cgroup_in_sysfs = h.cgroup_fs_path(cgroup_path);
            if h.available_controllers().iter().any(|c| c == "cpuacct") {
                let data_path = cgroup_in_sysfs.join("cpuacct.usage");
                let file = U64File::open(&data_path).with_context(|| format!("failed to open {data_path:?}"))?;
                cpuacct_usage = Some(file)
            }
            if h.available_controllers().iter().any(|c| c == "memory") {
                let data_path = cgroup_in_sysfs.join("memory.stat");
                let file = U64File::open(&data_path).with_context(|| format!("failed to open {data_path:?}"))?;
                memory_stat = Some(file)
            }
        }
        Ok(Self {
            cpuacct_usage,
            memory_stat,
        })
    }

    /// Creates a new `V1Collector` in a single cgroup v1 hierarchy.
    ///
    /// # Available metrics
    /// The collector can only measure what is provided by the cgroup controllers attached to the given hierarchy.
    pub fn in_single_hierarchy<'h>(cgroup: Cgroup<'h>) -> anyhow::Result<Self> {
        Self::across_hierarchies(cgroup.canonical_path(), &[cgroup.hierarchy()])
            .with_context(|| format!("collector creation failed for cgroup {}", cgroup.unique_name()))
    }

    /// Collects measurements from the underlying "file", using `io_buf` as an intermediary I/O buffer.
    pub fn measure(&mut self, io_buf: &mut Vec<u8>) -> io::Result<V1Stats> {
        // SAFETY: the content is generated by the kernel and is always valid ASCII (hence valid UTF-8)
        let cpuacct_usage = self
            .cpuacct_usage
            .as_mut()
            .map(|f| unsafe { f.read(io_buf) })
            .transpose()?;

        let memory_stat = self
            .memory_stat
            .as_mut()
            .map(|f| unsafe { f.read(io_buf) })
            .transpose()?;

        Ok(V1Stats {
            cpuacct_usage,
            memory_stat,
        })
    }
}
