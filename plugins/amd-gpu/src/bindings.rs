/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe { *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize) };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe { (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize) };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const AMDSMI_MAX_MM_IP_COUNT: u32 = 8;
pub const AMDSMI_MAX_STRING_LENGTH: u32 = 256;
pub const AMDSMI_MAX_DEVICES: u32 = 32;
pub const AMDSMI_MAX_CACHE_TYPES: u32 = 10;
pub const AMDSMI_MAX_ACCELERATOR_PROFILE: u32 = 32;
pub const AMDSMI_MAX_CP_PROFILE_RESOURCES: u32 = 32;
pub const AMDSMI_MAX_ACCELERATOR_PARTITIONS: u32 = 8;
pub const AMDSMI_MAX_NUM_NUMA_NODES: u32 = 32;
pub const AMDSMI_GPU_UUID_SIZE: u32 = 38;
pub const AMDSMI_MAX_NUM_XGMI_PHYSICAL_LINK: u32 = 64;
pub const AMDSMI_MAX_CONTAINER_TYPE: u32 = 2;
pub const CENTRIGRADE_TO_MILLI_CENTIGRADE: u32 = 1000;
pub const AMDSMI_NUM_HBM_INSTANCES: u32 = 4;
pub const AMDSMI_MAX_NUM_VCN: u32 = 4;
pub const AMDSMI_MAX_NUM_CLKS: u32 = 4;
pub const AMDSMI_MAX_NUM_XGMI_LINKS: u32 = 8;
pub const AMDSMI_MAX_NUM_GFX_CLKS: u32 = 8;
pub const AMDSMI_MAX_AID: u32 = 4;
pub const AMDSMI_MAX_ENGINES: u32 = 8;
pub const AMDSMI_MAX_NUM_JPEG: u32 = 32;
pub const AMDSMI_MAX_NUM_JPEG_ENG_V1: u32 = 40;
pub const AMDSMI_MAX_NUM_XCC: u32 = 8;
pub const AMDSMI_MAX_NUM_XCP: u32 = 8;
pub const MAX_NUMBER_OF_AFIDS_PER_RECORD: u32 = 12;
pub const AMDSMI_TIME_FORMAT: &[u8; 20] = b"%02d:%02d:%02d.%03d\0";
pub const AMDSMI_DATE_FORMAT: &[u8; 35] = b"%04d-%02d-%02d:%02d:%02d:%02d.%03d\0";
pub const AMDSMI_LIB_VERSION_MAJOR: u32 = 26;
pub const AMDSMI_LIB_VERSION_MINOR: u32 = 1;
pub const AMDSMI_LIB_VERSION_RELEASE: u32 = 0;
pub const AMDSMI_MAX_NUM_FREQUENCIES: u32 = 33;
pub const AMDSMI_MAX_FAN_SPEED: u32 = 255;
pub const AMDSMI_NUM_VOLTAGE_CURVE_POINTS: u32 = 3;
pub const AMDSMI_MAX_UTILIZATION_VALUES: u32 = 4;
pub const AMDSMI_MAX_NUM_PM_POLICIES: u32 = 32;
pub const amd_smi_VERSION_MAJOR: u32 = 0;
pub const amd_smi_VERSION_MINOR: u32 = 0;
pub const amd_smi_VERSION_PATCH: u32 = 0;
pub const amd_smi_VERSION_BUILD: &[u8; 2] = b"0\0";
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"][::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"][::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"][::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"][::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"][::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"][::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"][::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"][::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"][::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"][::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"][::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"][::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"][::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"][::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"][::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"][::std::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"][::std::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"][::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"][::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"][::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"][::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"][::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"][::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"][::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"][::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"][::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"][::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"][::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"][::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"][::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"][::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"][::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"][::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"][::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"][::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"][::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"][::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"][::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"][::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"][::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"][::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"][::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"][::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"][::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"][::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"][::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = "!< Initialize all processors"]
pub const amdsmi_init_flags_t_AMDSMI_INIT_ALL_PROCESSORS: amdsmi_init_flags_t = 4294967295;
#[doc = "!< Initialize AMD CPUS"]
pub const amdsmi_init_flags_t_AMDSMI_INIT_AMD_CPUS: amdsmi_init_flags_t = 1;
#[doc = "!< Initialize AMD GPUS"]
pub const amdsmi_init_flags_t_AMDSMI_INIT_AMD_GPUS: amdsmi_init_flags_t = 2;
#[doc = "!< Initialize Non-AMD CPUS"]
pub const amdsmi_init_flags_t_AMDSMI_INIT_NON_AMD_CPUS: amdsmi_init_flags_t = 4;
#[doc = "!< Initialize Non-AMD GPUS"]
pub const amdsmi_init_flags_t_AMDSMI_INIT_NON_AMD_GPUS: amdsmi_init_flags_t = 8;
#[doc = "< Initialize AMD CPUS and GPUS\n(Default option)"]
pub const amdsmi_init_flags_t_AMDSMI_INIT_AMD_APUS: amdsmi_init_flags_t = 3;
#[doc = " @brief Initialization flags\n\n Initialization flags may be OR'd together and passed to ::amdsmi_init().\n\n @cond @tag{gpu_bm_linux} @tag{host} @tag{cpu_bm} @tag{guest_windows} @endcond"]
pub type amdsmi_init_flags_t = ::std::os::raw::c_uint;
#[doc = "!< Multi-Media Unified Video Decoder"]
pub const amdsmi_mm_ip_t_AMDSMI_MM_UVD: amdsmi_mm_ip_t = 0;
#[doc = "!< Multi-Media Video Coding Engine"]
pub const amdsmi_mm_ip_t_AMDSMI_MM_VCE: amdsmi_mm_ip_t = 1;
#[doc = "!< Multi-Media Video Core Next"]
pub const amdsmi_mm_ip_t_AMDSMI_MM_VCN: amdsmi_mm_ip_t = 2;
pub const amdsmi_mm_ip_t_AMDSMI_MM__MAX: amdsmi_mm_ip_t = 3;
#[doc = " @brief GPU Capability info\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_mm_ip_t = ::std::os::raw::c_uint;
#[doc = "!< Linux containers"]
pub const amdsmi_container_types_t_AMDSMI_CONTAINER_LXC: amdsmi_container_types_t = 0;
#[doc = "!< Docker containers"]
pub const amdsmi_container_types_t_AMDSMI_CONTAINER_DOCKER: amdsmi_container_types_t = 1;
#[doc = " @brief Container\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_container_types_t = ::std::os::raw::c_uint;
#[doc = " @brief opaque handler point to underlying implementation\n\n @cond @tag{gpu_bm_linux} @tag{host} @tag{cpu_bm} @tag{guest_windows} @endcond"]
pub type amdsmi_processor_handle = *mut ::std::os::raw::c_void;
pub type amdsmi_socket_handle = *mut ::std::os::raw::c_void;
#[doc = " @brief opaque handler point to underlying implementation\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_node_handle = *mut ::std::os::raw::c_void;
#[doc = "!< Unknown processor type"]
pub const processor_type_t_AMDSMI_PROCESSOR_TYPE_UNKNOWN: processor_type_t = 0;
#[doc = "!< AMD Graphics processor type"]
pub const processor_type_t_AMDSMI_PROCESSOR_TYPE_AMD_GPU: processor_type_t = 1;
#[doc = "!< AMD CPU processor type"]
pub const processor_type_t_AMDSMI_PROCESSOR_TYPE_AMD_CPU: processor_type_t = 2;
#[doc = "!< Non-AMD Graphics processor type"]
pub const processor_type_t_AMDSMI_PROCESSOR_TYPE_NON_AMD_GPU: processor_type_t = 3;
#[doc = "!< Non-AMD CPU processor type"]
pub const processor_type_t_AMDSMI_PROCESSOR_TYPE_NON_AMD_CPU: processor_type_t = 4;
#[doc = "!< AMD CPU-Core processor type"]
pub const processor_type_t_AMDSMI_PROCESSOR_TYPE_AMD_CPU_CORE: processor_type_t = 5;
#[doc = "!< AMD Accelerated processor type (GPU and CPU)"]
pub const processor_type_t_AMDSMI_PROCESSOR_TYPE_AMD_APU: processor_type_t = 6;
#[doc = " @brief Processor types detectable by AMD SMI\n\n AMDSMI_PROCESSOR_TYPE_AMD_CPU      - CPU Socket is a physical component that holds the CPU.\n AMDSMI_PROCESSOR_TYPE_AMD_CPU_CORE - CPU Cores are number of individual processing units within the CPU.\n AMDSMI_PROCESSOR_TYPE_AMD_APU      - Combination of AMDSMI_PROCESSOR_TYPE_AMD_CPU and integrated GPU on single die\n\n @cond @tag{gpu_bm_linux} @tag{host} @tag{cpu_bm} @tag{guest_windows} @endcond"]
pub type processor_type_t = ::std::os::raw::c_uint;
#[doc = "!< Call succeeded"]
pub const amdsmi_status_t_AMDSMI_STATUS_SUCCESS: amdsmi_status_t = 0;
#[doc = "!< Invalid parameters"]
pub const amdsmi_status_t_AMDSMI_STATUS_INVAL: amdsmi_status_t = 1;
#[doc = "!< Command not supported"]
pub const amdsmi_status_t_AMDSMI_STATUS_NOT_SUPPORTED: amdsmi_status_t = 2;
#[doc = "!< Not implemented yet"]
pub const amdsmi_status_t_AMDSMI_STATUS_NOT_YET_IMPLEMENTED: amdsmi_status_t = 3;
#[doc = "!< Fail to load lib"]
pub const amdsmi_status_t_AMDSMI_STATUS_FAIL_LOAD_MODULE: amdsmi_status_t = 4;
#[doc = "!< Fail to load symbol"]
pub const amdsmi_status_t_AMDSMI_STATUS_FAIL_LOAD_SYMBOL: amdsmi_status_t = 5;
#[doc = "!< Error when call libdrm"]
pub const amdsmi_status_t_AMDSMI_STATUS_DRM_ERROR: amdsmi_status_t = 6;
#[doc = "!< API call failed"]
pub const amdsmi_status_t_AMDSMI_STATUS_API_FAILED: amdsmi_status_t = 7;
#[doc = "!< Timeout in API call"]
pub const amdsmi_status_t_AMDSMI_STATUS_TIMEOUT: amdsmi_status_t = 8;
#[doc = "!< Retry operation"]
pub const amdsmi_status_t_AMDSMI_STATUS_RETRY: amdsmi_status_t = 9;
#[doc = "!< Permission Denied"]
pub const amdsmi_status_t_AMDSMI_STATUS_NO_PERM: amdsmi_status_t = 10;
#[doc = "!< An interrupt occurred during execution of function"]
pub const amdsmi_status_t_AMDSMI_STATUS_INTERRUPT: amdsmi_status_t = 11;
#[doc = "!< I/O Error"]
pub const amdsmi_status_t_AMDSMI_STATUS_IO: amdsmi_status_t = 12;
#[doc = "!< Bad address"]
pub const amdsmi_status_t_AMDSMI_STATUS_ADDRESS_FAULT: amdsmi_status_t = 13;
#[doc = "!< Problem accessing a file"]
pub const amdsmi_status_t_AMDSMI_STATUS_FILE_ERROR: amdsmi_status_t = 14;
#[doc = "!< Not enough memory"]
pub const amdsmi_status_t_AMDSMI_STATUS_OUT_OF_RESOURCES: amdsmi_status_t = 15;
#[doc = "!< An internal exception was caught"]
pub const amdsmi_status_t_AMDSMI_STATUS_INTERNAL_EXCEPTION: amdsmi_status_t = 16;
#[doc = "!< The provided input is out of allowable or safe range"]
pub const amdsmi_status_t_AMDSMI_STATUS_INPUT_OUT_OF_BOUNDS: amdsmi_status_t = 17;
#[doc = "!< An error occurred when initializing internal data structures"]
pub const amdsmi_status_t_AMDSMI_STATUS_INIT_ERROR: amdsmi_status_t = 18;
#[doc = "!< An internal reference counter exceeded INT32_MAX"]
pub const amdsmi_status_t_AMDSMI_STATUS_REFCOUNT_OVERFLOW: amdsmi_status_t = 19;
#[doc = "!< Error when a directory is not found, maps to ENOTDIR"]
pub const amdsmi_status_t_AMDSMI_STATUS_DIRECTORY_NOT_FOUND: amdsmi_status_t = 20;
#[doc = "!< Processor busy"]
pub const amdsmi_status_t_AMDSMI_STATUS_BUSY: amdsmi_status_t = 30;
#[doc = "!< Processor Not found"]
pub const amdsmi_status_t_AMDSMI_STATUS_NOT_FOUND: amdsmi_status_t = 31;
#[doc = "!< Processor not initialized"]
pub const amdsmi_status_t_AMDSMI_STATUS_NOT_INIT: amdsmi_status_t = 32;
#[doc = "!< No more free slot"]
pub const amdsmi_status_t_AMDSMI_STATUS_NO_SLOT: amdsmi_status_t = 33;
#[doc = "!< Processor driver not loaded"]
pub const amdsmi_status_t_AMDSMI_STATUS_DRIVER_NOT_LOADED: amdsmi_status_t = 34;
#[doc = "!< There is more data than the buffer size the user passed"]
pub const amdsmi_status_t_AMDSMI_STATUS_MORE_DATA: amdsmi_status_t = 39;
#[doc = "!< No data was found for a given input"]
pub const amdsmi_status_t_AMDSMI_STATUS_NO_DATA: amdsmi_status_t = 40;
#[doc = "!< Not enough resources were available for the operation"]
pub const amdsmi_status_t_AMDSMI_STATUS_INSUFFICIENT_SIZE: amdsmi_status_t = 41;
#[doc = "!< An unexpected amount of data was read"]
pub const amdsmi_status_t_AMDSMI_STATUS_UNEXPECTED_SIZE: amdsmi_status_t = 42;
#[doc = "!< The data read or provided to function is not what was expected"]
pub const amdsmi_status_t_AMDSMI_STATUS_UNEXPECTED_DATA: amdsmi_status_t = 43;
#[doc = "!< System has different cpu than AMD"]
pub const amdsmi_status_t_AMDSMI_STATUS_NON_AMD_CPU: amdsmi_status_t = 44;
#[doc = "!< Energy driver not found"]
pub const amdsmi_status_t_AMDSMI_STATUS_NO_ENERGY_DRV: amdsmi_status_t = 45;
#[doc = "!< MSR driver not found"]
pub const amdsmi_status_t_AMDSMI_STATUS_NO_MSR_DRV: amdsmi_status_t = 46;
#[doc = "!< HSMP driver not found"]
pub const amdsmi_status_t_AMDSMI_STATUS_NO_HSMP_DRV: amdsmi_status_t = 47;
#[doc = "!< HSMP not supported"]
pub const amdsmi_status_t_AMDSMI_STATUS_NO_HSMP_SUP: amdsmi_status_t = 48;
#[doc = "!< HSMP message/feature not supported"]
pub const amdsmi_status_t_AMDSMI_STATUS_NO_HSMP_MSG_SUP: amdsmi_status_t = 49;
#[doc = "!< HSMP message timed out"]
pub const amdsmi_status_t_AMDSMI_STATUS_HSMP_TIMEOUT: amdsmi_status_t = 50;
#[doc = "!< No Energy and HSMP driver present"]
pub const amdsmi_status_t_AMDSMI_STATUS_NO_DRV: amdsmi_status_t = 51;
#[doc = "!< file or directory not found"]
pub const amdsmi_status_t_AMDSMI_STATUS_FILE_NOT_FOUND: amdsmi_status_t = 52;
#[doc = "!< Parsed argument is invalid"]
pub const amdsmi_status_t_AMDSMI_STATUS_ARG_PTR_NULL: amdsmi_status_t = 53;
#[doc = "!< AMDGPU restart failed"]
pub const amdsmi_status_t_AMDSMI_STATUS_AMDGPU_RESTART_ERR: amdsmi_status_t = 54;
#[doc = "!< Setting is not available"]
pub const amdsmi_status_t_AMDSMI_STATUS_SETTING_UNAVAILABLE: amdsmi_status_t = 55;
#[doc = "!< EEPROM is corrupted"]
pub const amdsmi_status_t_AMDSMI_STATUS_CORRUPTED_EEPROM: amdsmi_status_t = 56;
#[doc = "!< The internal library error did not map to a status code"]
pub const amdsmi_status_t_AMDSMI_STATUS_MAP_ERROR: amdsmi_status_t = 4294967294;
#[doc = "!< An unknown error occurred"]
pub const amdsmi_status_t_AMDSMI_STATUS_UNKNOWN_ERROR: amdsmi_status_t = 4294967295;
#[doc = " @brief Error codes returned by amdsmi functions\n\n Please avoid status codes that are multiples of 256 (256, 512, etc..)\n Return values in the shell get modulo 256 applied, meaning any multiple of 256 ends up as 0\n\n @cond @tag{gpu_bm_linux} @tag{host} @tag{cpu_bm} @tag{guest_windows} @endcond"]
pub type amdsmi_status_t = ::std::os::raw::c_uint;
#[doc = "!< System clock"]
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE_SYS: amdsmi_clk_type_t = 0;
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE_FIRST: amdsmi_clk_type_t = 0;
#[doc = "!< Graphics clock"]
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE_GFX: amdsmi_clk_type_t = 0;
#[doc = "< Data Fabric clock (for ASICs\nrunning on a separate clock)"]
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE_DF: amdsmi_clk_type_t = 1;
#[doc = "< Display Controller Engine Front clock,\ntiming/bandwidth signals to display"]
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE_DCEF: amdsmi_clk_type_t = 2;
#[doc = "!< System On Chip clock, integrated circuit frequency"]
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE_SOC: amdsmi_clk_type_t = 3;
#[doc = "!< Memory clock speed, system operating frequency"]
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE_MEM: amdsmi_clk_type_t = 4;
#[doc = "!< PCI Express clock, high bandwidth peripherals"]
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE_PCIE: amdsmi_clk_type_t = 5;
#[doc = "!< Video 0 clock, video processing units"]
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE_VCLK0: amdsmi_clk_type_t = 6;
#[doc = "!< Video 1 clock, video processing units"]
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE_VCLK1: amdsmi_clk_type_t = 7;
#[doc = "!< Display 1 clock, timing signals for display output"]
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE_DCLK0: amdsmi_clk_type_t = 8;
#[doc = "!< Display 2 clock, timing signals for display output"]
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE_DCLK1: amdsmi_clk_type_t = 9;
pub const amdsmi_clk_type_t_AMDSMI_CLK_TYPE__MAX: amdsmi_clk_type_t = 9;
#[doc = " @brief Clock types\n\n @cond @tag{gpu_bm_linux} @tag{host} @tag{guest_windows} @endcond"]
pub type amdsmi_clk_type_t = ::std::os::raw::c_uint;
#[doc = "!< Invalid accelerator partition type"]
pub const amdsmi_accelerator_partition_type_t_AMDSMI_ACCELERATOR_PARTITION_INVALID:
    amdsmi_accelerator_partition_type_t = 0;
#[doc = "< Single GPU mode (SPX)- All XCCs work\ntogether with shared memory"]
pub const amdsmi_accelerator_partition_type_t_AMDSMI_ACCELERATOR_PARTITION_SPX: amdsmi_accelerator_partition_type_t = 1;
#[doc = "< Dual GPU mode (DPX)- Half XCCs work\ntogether with shared memory"]
pub const amdsmi_accelerator_partition_type_t_AMDSMI_ACCELERATOR_PARTITION_DPX: amdsmi_accelerator_partition_type_t = 2;
#[doc = "< Triple GPU mode (TPX)- One-third XCCs\nwork together with shared memory"]
pub const amdsmi_accelerator_partition_type_t_AMDSMI_ACCELERATOR_PARTITION_TPX: amdsmi_accelerator_partition_type_t = 3;
#[doc = "< Quad GPU mode (QPX)- Quarter XCCs\nwork together with shared memory"]
pub const amdsmi_accelerator_partition_type_t_AMDSMI_ACCELERATOR_PARTITION_QPX: amdsmi_accelerator_partition_type_t = 4;
#[doc = "< Core mode (CPX)- Per-chip XCC with\nshared memory"]
pub const amdsmi_accelerator_partition_type_t_AMDSMI_ACCELERATOR_PARTITION_CPX: amdsmi_accelerator_partition_type_t = 5;
pub const amdsmi_accelerator_partition_type_t_AMDSMI_ACCELERATOR_PARTITION_MAX: amdsmi_accelerator_partition_type_t = 6;
#[doc = " @brief Accelerator Partition\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_accelerator_partition_type_t = ::std::os::raw::c_uint;
#[doc = "!< Compute complex or stream processors"]
pub const amdsmi_accelerator_partition_resource_type_t_AMDSMI_ACCELERATOR_XCC:
    amdsmi_accelerator_partition_resource_type_t = 0;
#[doc = "!< Video encoding"]
pub const amdsmi_accelerator_partition_resource_type_t_AMDSMI_ACCELERATOR_ENCODER:
    amdsmi_accelerator_partition_resource_type_t = 1;
#[doc = "!< Video decoding"]
pub const amdsmi_accelerator_partition_resource_type_t_AMDSMI_ACCELERATOR_DECODER:
    amdsmi_accelerator_partition_resource_type_t = 2;
#[doc = "!< Direct Memory Access, high speed data transfers"]
pub const amdsmi_accelerator_partition_resource_type_t_AMDSMI_ACCELERATOR_DMA:
    amdsmi_accelerator_partition_resource_type_t = 3;
#[doc = "!< Encoding and Decoding jpeg engines"]
pub const amdsmi_accelerator_partition_resource_type_t_AMDSMI_ACCELERATOR_JPEG:
    amdsmi_accelerator_partition_resource_type_t = 4;
pub const amdsmi_accelerator_partition_resource_type_t_AMDSMI_ACCELERATOR_MAX:
    amdsmi_accelerator_partition_resource_type_t = 5;
#[doc = " @brief Accelerator Partition Resource Types\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_accelerator_partition_resource_type_t = ::std::os::raw::c_uint;
#[doc = "!< Invalid compute partition type"]
pub const amdsmi_compute_partition_type_t_AMDSMI_COMPUTE_PARTITION_INVALID: amdsmi_compute_partition_type_t = 0;
#[doc = "< Single GPU mode (SPX)- All XCCs work\ntogether with shared memory"]
pub const amdsmi_compute_partition_type_t_AMDSMI_COMPUTE_PARTITION_SPX: amdsmi_compute_partition_type_t = 1;
#[doc = "< Dual GPU mode (DPX)- Half XCCs work\ntogether with shared memory"]
pub const amdsmi_compute_partition_type_t_AMDSMI_COMPUTE_PARTITION_DPX: amdsmi_compute_partition_type_t = 2;
#[doc = "< Triple GPU mode (TPX)- One-third XCCs\nwork together with shared memory"]
pub const amdsmi_compute_partition_type_t_AMDSMI_COMPUTE_PARTITION_TPX: amdsmi_compute_partition_type_t = 3;
#[doc = "< Quad GPU mode (QPX)- Quarter XCCs\nwork together with shared memory"]
pub const amdsmi_compute_partition_type_t_AMDSMI_COMPUTE_PARTITION_QPX: amdsmi_compute_partition_type_t = 4;
#[doc = "< Core mode (CPX)- Per-chip XCC with\nshared memory"]
pub const amdsmi_compute_partition_type_t_AMDSMI_COMPUTE_PARTITION_CPX: amdsmi_compute_partition_type_t = 5;
#[doc = " @brief Compute Partition. This enum is used to identify\n various compute partitioning settings.\n\n @cond @tag{gpu_bm_linux} @tag{guest_windows} @endcond"]
pub type amdsmi_compute_partition_type_t = ::std::os::raw::c_uint;
pub const amdsmi_memory_partition_type_t_AMDSMI_MEMORY_PARTITION_UNKNOWN: amdsmi_memory_partition_type_t = 0;
#[doc = "< NPS1 - All CCD & XCD data is interleaved\nacross all 8 HBM stacks (all stacks/1)"]
pub const amdsmi_memory_partition_type_t_AMDSMI_MEMORY_PARTITION_NPS1: amdsmi_memory_partition_type_t = 1;
#[doc = "< NPS2 - 2 sets of CCDs or 4 XCD interleaved\nacross the 4 HBM stacks per AID pair\n(8 stacks/2)"]
pub const amdsmi_memory_partition_type_t_AMDSMI_MEMORY_PARTITION_NPS2: amdsmi_memory_partition_type_t = 2;
#[doc = "< NPS4 - Each XCD data is interleaved\nacross 2 (or single) HBM stacks\n(8 stacks/8 or 8 stacks/4)"]
pub const amdsmi_memory_partition_type_t_AMDSMI_MEMORY_PARTITION_NPS4: amdsmi_memory_partition_type_t = 4;
#[doc = "< NPS8 - Each XCD uses a single HBM stack\n(8 stacks/8). Or each XCD uses a single\nHBM stack & CCDs share 2 non-interleaved\nHBM stacks on its AID\n(AID[1,2,3] = 6 stacks/6)"]
pub const amdsmi_memory_partition_type_t_AMDSMI_MEMORY_PARTITION_NPS8: amdsmi_memory_partition_type_t = 8;
#[doc = " @brief Memory Partitions\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_memory_partition_type_t = ::std::os::raw::c_uint;
#[doc = "!< Edge temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_EDGE: amdsmi_temperature_type_t = 0;
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_FIRST: amdsmi_temperature_type_t = 0;
#[doc = "!< Hottest temperature reported for entire die"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_HOTSPOT: amdsmi_temperature_type_t = 1;
#[doc = "!< Synonymous with HOTSPOT"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_JUNCTION: amdsmi_temperature_type_t = 1;
#[doc = "!< VRAM temperature on graphics card"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_VRAM: amdsmi_temperature_type_t = 2;
#[doc = "!< High Bandwidth 0 temperature per stack"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_HBM_0: amdsmi_temperature_type_t = 3;
#[doc = "!< High Bandwidth 1 temperature per stack"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_HBM_1: amdsmi_temperature_type_t = 4;
#[doc = "!< High Bandwidth 2 temperature per stack"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_HBM_2: amdsmi_temperature_type_t = 5;
#[doc = "!< High Bandwidth 3 temperature per stack"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_HBM_3: amdsmi_temperature_type_t = 6;
#[doc = "!< PCIe switch temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_PLX: amdsmi_temperature_type_t = 7;
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_NODE_FIRST: amdsmi_temperature_type_t = 100;
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_NODE_RETIMER_X: amdsmi_temperature_type_t = 100;
#[doc = "!< OAM X IBC temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_NODE_OAM_X_IBC: amdsmi_temperature_type_t = 101;
#[doc = "!< OAM X IBC 2 temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_NODE_OAM_X_IBC_2: amdsmi_temperature_type_t = 102;
#[doc = "!< OAM X VDD 1.8V voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_NODE_OAM_X_VDD18_VR: amdsmi_temperature_type_t =
    103;
#[doc = "!< OAM X 0.4V HBM B voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_NODE_OAM_X_04_HBM_B_VR: amdsmi_temperature_type_t =
    104;
#[doc = "!< OAM X 0.4V HBM D voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_NODE_OAM_X_04_HBM_D_VR: amdsmi_temperature_type_t =
    105;
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_NODE_LAST: amdsmi_temperature_type_t = 149;
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VR_FIRST: amdsmi_temperature_type_t = 150;
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDDCR_VDD0: amdsmi_temperature_type_t = 150;
#[doc = "!< VDDCR VDD1 voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDDCR_VDD1: amdsmi_temperature_type_t = 151;
#[doc = "!< VDDCR VDD2 voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDDCR_VDD2: amdsmi_temperature_type_t = 152;
#[doc = "!< VDDCR VDD3 voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDDCR_VDD3: amdsmi_temperature_type_t = 153;
#[doc = "!< VDDCR SOC A voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDDCR_SOC_A: amdsmi_temperature_type_t = 154;
#[doc = "!< VDDCR SOC C voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDDCR_SOC_C: amdsmi_temperature_type_t = 155;
#[doc = "!< VDDCR SOCIO A voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDDCR_SOCIO_A: amdsmi_temperature_type_t = 156;
#[doc = "!< VDDCR SOCIO C voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDDCR_SOCIO_C: amdsmi_temperature_type_t = 157;
#[doc = "!< VDD 0.85V HBM voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDD_085_HBM: amdsmi_temperature_type_t = 158;
#[doc = "!< VDDCR 1.1V HBM B voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDDCR_11_HBM_B: amdsmi_temperature_type_t = 159;
#[doc = "!< VDDCR 1.1V HBM D voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDDCR_11_HBM_D: amdsmi_temperature_type_t = 160;
#[doc = "!< VDD USR voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDD_USR: amdsmi_temperature_type_t = 161;
#[doc = "!< VDDIO 1.1V E32 voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VDDIO_11_E32: amdsmi_temperature_type_t = 162;
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_GPUBOARD_VR_LAST: amdsmi_temperature_type_t = 199;
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_FIRST: amdsmi_temperature_type_t = 200;
#[doc = "!< UBB FPGA temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_UBB_FPGA: amdsmi_temperature_type_t = 200;
#[doc = "!< UBB front temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_UBB_FRONT: amdsmi_temperature_type_t = 201;
#[doc = "!< UBB back temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_UBB_BACK: amdsmi_temperature_type_t = 202;
#[doc = "!< UBB OAM7 temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_UBB_OAM7: amdsmi_temperature_type_t = 203;
#[doc = "!< UBB IBC temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_UBB_IBC: amdsmi_temperature_type_t = 204;
#[doc = "!< UBB UFPGA temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_UBB_UFPGA: amdsmi_temperature_type_t = 205;
#[doc = "!< UBB OAM1 temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_UBB_OAM1: amdsmi_temperature_type_t = 206;
#[doc = "!< OAM 0-1 HSC temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_OAM_0_1_HSC: amdsmi_temperature_type_t = 207;
#[doc = "!< OAM 2-3 HSC temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_OAM_2_3_HSC: amdsmi_temperature_type_t = 208;
#[doc = "!< OAM 4-5 HSC temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_OAM_4_5_HSC: amdsmi_temperature_type_t = 209;
#[doc = "!< OAM 6-7 HSC temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_OAM_6_7_HSC: amdsmi_temperature_type_t = 210;
#[doc = "!< UBB FPGA 0.72V voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_UBB_FPGA_0V72_VR: amdsmi_temperature_type_t = 211;
#[doc = "!< UBB FPGA 3.3V voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_UBB_FPGA_3V3_VR: amdsmi_temperature_type_t = 212;
#[doc = "!< Retimer 0-1-2-3 1.2V voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_RETIMER_0_1_2_3_1V2_VR:
    amdsmi_temperature_type_t = 213;
#[doc = "!< Retimer 4-5-6-7 1.2V voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_RETIMER_4_5_6_7_1V2_VR:
    amdsmi_temperature_type_t = 214;
#[doc = "!< Retimer 0-1 0.9V voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_RETIMER_0_1_0V9_VR: amdsmi_temperature_type_t =
    215;
#[doc = "!< Retimer 4-5 0.9V voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_RETIMER_4_5_0V9_VR: amdsmi_temperature_type_t =
    216;
#[doc = "!< Retimer 2-3 0.9V voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_RETIMER_2_3_0V9_VR: amdsmi_temperature_type_t =
    217;
#[doc = "!< Retimer 6-7 0.9V voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_RETIMER_6_7_0V9_VR: amdsmi_temperature_type_t =
    218;
#[doc = "!< OAM 0-1-2-3 3.3V voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_OAM_0_1_2_3_3V3_VR: amdsmi_temperature_type_t =
    219;
#[doc = "!< OAM 4-5-6-7 3.3V voltage regulator temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_OAM_4_5_6_7_3V3_VR: amdsmi_temperature_type_t =
    220;
#[doc = "!< IBC HSC temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_IBC_HSC: amdsmi_temperature_type_t = 221;
#[doc = "!< IBC temperature"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_IBC: amdsmi_temperature_type_t = 222;
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE_BASEBOARD_LAST: amdsmi_temperature_type_t = 249;
#[doc = "!< Maximum per GPU temperature type"]
pub const amdsmi_temperature_type_t_AMDSMI_TEMPERATURE_TYPE__MAX: amdsmi_temperature_type_t = 249;
#[doc = " @brief This enumeration is used to indicate from which part of the processor a\n temperature reading should be obtained.\n\n @cond @tag{gpu_bm_linux} @tag{host} @tag{guest_windows} @endcond"]
pub type amdsmi_temperature_type_t = ::std::os::raw::c_uint;
#[doc = "< System Management Unit (power management,\nclock control, thermal monitoring, etc...)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_SMU: amdsmi_fw_block_t = 1;
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_FIRST: amdsmi_fw_block_t = 1;
#[doc = "!< Compute Processor - Command_Engine (fetch, decode, dispatch)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_CP_CE: amdsmi_fw_block_t = 2;
#[doc = "!< Compute Processor - Pixel Front End Processor (pixelating process)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_CP_PFP: amdsmi_fw_block_t = 3;
#[doc = "!< Compute Processor - Micro Engine (specialize processing)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_CP_ME: amdsmi_fw_block_t = 4;
#[doc = "!< Compute Processor - Micro Engine Controler Job Table 1 (queues, scheduling)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_CP_MEC_JT1: amdsmi_fw_block_t = 5;
#[doc = "!< Compute Processor - Micro Engine Controler Job Table 2 (queues, scheduling)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_CP_MEC_JT2: amdsmi_fw_block_t = 6;
#[doc = "!< Compute Processor - Micro Engine Controler 1 (scheduling, managing resources)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_CP_MEC1: amdsmi_fw_block_t = 7;
#[doc = "!< Compute Processor - Micro Engine Controler 2 (scheduling, managing resources)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_CP_MEC2: amdsmi_fw_block_t = 8;
#[doc = "!< Rasterizer and L2 Cache (rasterization processs)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLC: amdsmi_fw_block_t = 9;
#[doc = "!< System Direct Memory Access 0 (high speed data transfers)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_SDMA0: amdsmi_fw_block_t = 10;
#[doc = "!< System Direct Memory Access 1 (high speed data transfers)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_SDMA1: amdsmi_fw_block_t = 11;
#[doc = "!< System Direct Memory Access 2 (high speed data transfers)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_SDMA2: amdsmi_fw_block_t = 12;
#[doc = "!< System Direct Memory Access 3 (high speed data transfers)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_SDMA3: amdsmi_fw_block_t = 13;
#[doc = "!< System Direct Memory Access 4 (high speed data transfers)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_SDMA4: amdsmi_fw_block_t = 14;
#[doc = "!< System Direct Memory Access 5 (high speed data transfers)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_SDMA5: amdsmi_fw_block_t = 15;
#[doc = "!< System Direct Memory Access 6 (high speed data transfers)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_SDMA6: amdsmi_fw_block_t = 16;
#[doc = "!< System Direct Memory Access 7 (high speed data transfers)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_SDMA7: amdsmi_fw_block_t = 17;
#[doc = "!< Video Core Next (encoding and decoding)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_VCN: amdsmi_fw_block_t = 18;
#[doc = "!< Unified Video Decoder (decode specific video formats)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_UVD: amdsmi_fw_block_t = 19;
#[doc = "!< Video Coding Engine (Encoding video)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_VCE: amdsmi_fw_block_t = 20;
#[doc = "!< Image Signal Processor (processing raw image data from sensors)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_ISP: amdsmi_fw_block_t = 21;
#[doc = "!< Digital Micro Controller Unit - Embedded RAM (memory used by DMU)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_DMCU_ERAM: amdsmi_fw_block_t = 22;
#[doc = "!< Digital Micro Controller Unit - Interrupt Service Routine (interrupt handlers)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_DMCU_ISR: amdsmi_fw_block_t = 23;
#[doc = "!< Rasterizier and L2 Cache Restore List Graphics Processor Memory"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLC_RESTORE_LIST_GPM_MEM: amdsmi_fw_block_t = 24;
#[doc = "!< Rasterizier and L2 Cache Restore List System RAM Memory"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLC_RESTORE_LIST_SRM_MEM: amdsmi_fw_block_t = 25;
#[doc = "!< Rasterizier and L2 Cache Restore List Control"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLC_RESTORE_LIST_CNTL: amdsmi_fw_block_t = 26;
#[doc = "!< Rasterizier and L2 Cache Virtual memory"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLC_V: amdsmi_fw_block_t = 27;
#[doc = "!< Multi-Media Shader Hardware Scheduler"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_MMSCH: amdsmi_fw_block_t = 28;
#[doc = "!< Platform Security Processor System Driver"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_PSP_SYSDRV: amdsmi_fw_block_t = 29;
#[doc = "!< Platform Security Processor Secure Operating System Driver"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_PSP_SOSDRV: amdsmi_fw_block_t = 30;
#[doc = "!< Platform Security Processor Table of Contents"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_PSP_TOC: amdsmi_fw_block_t = 31;
#[doc = "!< Platform Security Processor Table of Contents"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_PSP_KEYDB: amdsmi_fw_block_t = 32;
#[doc = "!< Data Fabric Controler (bandwidth and coherency)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_DFC: amdsmi_fw_block_t = 33;
#[doc = "!< Platform Security Processor Secure Program Loader"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_PSP_SPL: amdsmi_fw_block_t = 34;
#[doc = "!< Driver Capabilities (capabilities, features)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_DRV_CAP: amdsmi_fw_block_t = 35;
#[doc = "!< Memory Contoller (RAM and VRAM)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_MC: amdsmi_fw_block_t = 36;
#[doc = "!< Platform Security Processor Bootloader (initial firmware)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_PSP_BL: amdsmi_fw_block_t = 37;
#[doc = "!< Compute Processor Packet Processor 4 (processing command packets)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_CP_PM4: amdsmi_fw_block_t = 38;
#[doc = "!< Rasterizier and L2 Cache Partition"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLC_P: amdsmi_fw_block_t = 39;
#[doc = "!< Security Policy Stage 2 (security features)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_SEC_POLICY_STAGE2: amdsmi_fw_block_t = 40;
#[doc = "!< Register Access Whitelist (Prevent unathorizied access)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_REG_ACCESS_WHITELIST: amdsmi_fw_block_t = 41;
#[doc = "!< Input/Output Memory Management Unit - Dynamic RAM"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_IMU_DRAM: amdsmi_fw_block_t = 42;
#[doc = "!< Input/Output Memory Management Unit - Instruction RAM"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_IMU_IRAM: amdsmi_fw_block_t = 43;
#[doc = "!< System Direct Memory Access - Thread Handler 0"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_SDMA_TH0: amdsmi_fw_block_t = 44;
#[doc = "!< System Direct Memory Access - Thread Handler 1"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_SDMA_TH1: amdsmi_fw_block_t = 45;
#[doc = "!< Compute Processor - Micro Engine Scheduler"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_CP_MES: amdsmi_fw_block_t = 46;
#[doc = "!< Micro Engine Scheduler - Kernel Indirect Queue"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_MES_KIQ: amdsmi_fw_block_t = 47;
#[doc = "!< Micro Engine Scheduler - Stack"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_MES_STACK: amdsmi_fw_block_t = 48;
#[doc = "!< Micro Engine Scheduler - Thread 1"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_MES_THREAD1: amdsmi_fw_block_t = 49;
#[doc = "!< Micro Engine Scheduler - Thread 1 Stack"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_MES_THREAD1_STACK: amdsmi_fw_block_t = 50;
#[doc = "!< Hardware Block RLX6"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLX6: amdsmi_fw_block_t = 51;
#[doc = "!< Hardware Block RLX6 - Dynamic Ram Boot"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLX6_DRAM_BOOT: amdsmi_fw_block_t = 52;
#[doc = "!< Hardware Block RS64 - Micro Engine"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RS64_ME: amdsmi_fw_block_t = 53;
#[doc = "!< Hardware Block RS64 - Micro Engine Partition 0 Data"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RS64_ME_P0_DATA: amdsmi_fw_block_t = 54;
#[doc = "!< Hardware Block RS64 - Micro Engine Partition 1 Data"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RS64_ME_P1_DATA: amdsmi_fw_block_t = 55;
#[doc = "!< Hardware Block RS64 - Pixel Front End Processor"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RS64_PFP: amdsmi_fw_block_t = 56;
#[doc = "!< Hardware Block RS64 - Pixel Front End Processor Partition 0 Data"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RS64_PFP_P0_DATA: amdsmi_fw_block_t = 57;
#[doc = "!< Hardware Block RS64 - Pixel Front End Processor Partition 1 Data"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RS64_PFP_P1_DATA: amdsmi_fw_block_t = 58;
#[doc = "!< Hardware Block RS64 - Micro Engine Controller"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RS64_MEC: amdsmi_fw_block_t = 59;
#[doc = "!< Hardware Block RS64 - Micro Engine Controller Partition 0 Data"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RS64_MEC_P0_DATA: amdsmi_fw_block_t = 60;
#[doc = "!< Hardware Block RS64 - Micro Engine Controller Partition 1 Data"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RS64_MEC_P1_DATA: amdsmi_fw_block_t = 61;
#[doc = "!< Hardware Block RS64 - Micro Engine Controller Partition 2 Data"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RS64_MEC_P2_DATA: amdsmi_fw_block_t = 62;
#[doc = "!< Hardware Block RS64 - Micro Engine Controller Partition 3 Data"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RS64_MEC_P3_DATA: amdsmi_fw_block_t = 63;
#[doc = "!< Power Policy Table (power management policies)"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_PPTABLE: amdsmi_fw_block_t = 64;
#[doc = "!< Platform Security Processor - System On a Chip"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_PSP_SOC: amdsmi_fw_block_t = 65;
#[doc = "!< Platform Security Processor - Debug"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_PSP_DBG: amdsmi_fw_block_t = 66;
#[doc = "!< Platform Security Processor - Interface"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_PSP_INTF: amdsmi_fw_block_t = 67;
#[doc = "!< Hardware Block RLX6 - Core 1"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLX6_CORE1: amdsmi_fw_block_t = 68;
#[doc = "!< Hardware Block RLX6 Core 1 - Dynamic RAM Boot"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLX6_DRAM_BOOT_CORE1: amdsmi_fw_block_t = 69;
#[doc = "!< Hardware Block RLCV - Subsystem LX7"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLCV_LX7: amdsmi_fw_block_t = 70;
#[doc = "!< Rasterizier and L2 Cache - Save Restore List"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLC_SAVE_RESTORE_LIST: amdsmi_fw_block_t = 71;
#[doc = "!< Asynchronous Shader Dispatcher"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_ASD: amdsmi_fw_block_t = 72;
#[doc = "!< Trusted Applications - Reliablity Availability and Serviceability"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_TA_RAS: amdsmi_fw_block_t = 73;
#[doc = "!< Trusted Applications - Reliablity XGMI"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_TA_XGMI: amdsmi_fw_block_t = 74;
#[doc = "!< Rasterizier and L2 Cache - Shared Resource Local Group"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLC_SRLG: amdsmi_fw_block_t = 75;
#[doc = "!< Rasterizier and L2 Cache - Shared Resource Local Segment"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_RLC_SRLS: amdsmi_fw_block_t = 76;
#[doc = "!< Power Management Firmware"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_PM: amdsmi_fw_block_t = 77;
#[doc = "!< Display Micro-Controller Unit"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_DMCU: amdsmi_fw_block_t = 78;
#[doc = "!< Platform Level Data Model Firmware Bundle"]
pub const amdsmi_fw_block_t_AMDSMI_FW_ID_PLDM_BUNDLE: amdsmi_fw_block_t = 79;
pub const amdsmi_fw_block_t_AMDSMI_FW_ID__MAX: amdsmi_fw_block_t = 80;
#[doc = " @brief The values of this enum are used to identify the various firmware\n blocks.\n\n @cond @tag{gpu_bm_linux} @tag{guest_windows} @tag{host} @endcond"]
pub type amdsmi_fw_block_t = ::std::os::raw::c_uint;
#[doc = "!< Unknown memory type"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_UNKNOWN: amdsmi_vram_type_t = 0;
#[doc = "!< High Bandwidth Memory"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_HBM: amdsmi_vram_type_t = 1;
#[doc = "!< High Bandwidth Memory, Generation 2"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_HBM2: amdsmi_vram_type_t = 2;
#[doc = "!< High Bandwidth Memory, Generation 2 Enhanced"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_HBM2E: amdsmi_vram_type_t = 3;
#[doc = "!< High Bandwidth Memory, Generation 3"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_HBM3: amdsmi_vram_type_t = 4;
#[doc = "!< High Bandwidth Memory, Generation 3 Enhanced"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_HBM3E: amdsmi_vram_type_t = 5;
#[doc = "!< Double Data Rate, Generation 2"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_DDR2: amdsmi_vram_type_t = 10;
#[doc = "!< Double Data Rate, Generation 3"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_DDR3: amdsmi_vram_type_t = 11;
#[doc = "!< Double Data Rate, Generation 4"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_DDR4: amdsmi_vram_type_t = 12;
#[doc = "!< Double Data Rate, Generation 5"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_DDR5: amdsmi_vram_type_t = 13;
#[doc = "!< Graphics Double Data Rate, Generation 1"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_GDDR1: amdsmi_vram_type_t = 17;
#[doc = "!< Graphics Double Data Rate, Generation 2"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_GDDR2: amdsmi_vram_type_t = 18;
#[doc = "!< Graphics Double Data Rate, Generation 3"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_GDDR3: amdsmi_vram_type_t = 19;
#[doc = "!< Graphics Double Data Rate, Generation 4"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_GDDR4: amdsmi_vram_type_t = 20;
#[doc = "!< Graphics Double Data Rate, Generation 5"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_GDDR5: amdsmi_vram_type_t = 21;
#[doc = "!< Graphics Double Data Rate, Generation 6"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_GDDR6: amdsmi_vram_type_t = 22;
#[doc = "!< Graphics Double Data Rate, Generation 7"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_GDDR7: amdsmi_vram_type_t = 23;
#[doc = "!< Low Power Double Data Rate, Generation 4"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_LPDDR4: amdsmi_vram_type_t = 30;
#[doc = "!< Low Power Double Data Rate, Generation 5"]
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE_LPDDR5: amdsmi_vram_type_t = 31;
pub const amdsmi_vram_type_t_AMDSMI_VRAM_TYPE__MAX: amdsmi_vram_type_t = 31;
#[doc = " @brief vRam Types. This enum is used to identify various VRam types.\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_vram_type_t = ::std::os::raw::c_uint;
#[doc = " @brief This structure represents a range (e.g., frequencies or voltages).\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_range_t {
    #[doc = "!< Lower bound of range"]
    pub lower_bound: u64,
    #[doc = "!< Upper bound of range"]
    pub upper_bound: u64,
    pub reserved: [u64; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_range_t"][::std::mem::size_of::<amdsmi_range_t>() - 32usize];
    ["Alignment of amdsmi_range_t"][::std::mem::align_of::<amdsmi_range_t>() - 8usize];
    ["Offset of field: amdsmi_range_t::lower_bound"][::std::mem::offset_of!(amdsmi_range_t, lower_bound) - 0usize];
    ["Offset of field: amdsmi_range_t::upper_bound"][::std::mem::offset_of!(amdsmi_range_t, upper_bound) - 8usize];
    ["Offset of field: amdsmi_range_t::reserved"][::std::mem::offset_of!(amdsmi_range_t, reserved) - 16usize];
};
#[doc = " @brief XGMI Information\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_xgmi_info_t {
    pub xgmi_lanes: u8,
    pub xgmi_hive_id: u64,
    pub xgmi_node_id: u64,
    pub index: u32,
    pub reserved: [u32; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_xgmi_info_t"][::std::mem::size_of::<amdsmi_xgmi_info_t>() - 64usize];
    ["Alignment of amdsmi_xgmi_info_t"][::std::mem::align_of::<amdsmi_xgmi_info_t>() - 8usize];
    ["Offset of field: amdsmi_xgmi_info_t::xgmi_lanes"]
        [::std::mem::offset_of!(amdsmi_xgmi_info_t, xgmi_lanes) - 0usize];
    ["Offset of field: amdsmi_xgmi_info_t::xgmi_hive_id"]
        [::std::mem::offset_of!(amdsmi_xgmi_info_t, xgmi_hive_id) - 8usize];
    ["Offset of field: amdsmi_xgmi_info_t::xgmi_node_id"]
        [::std::mem::offset_of!(amdsmi_xgmi_info_t, xgmi_node_id) - 16usize];
    ["Offset of field: amdsmi_xgmi_info_t::index"][::std::mem::offset_of!(amdsmi_xgmi_info_t, index) - 24usize];
    ["Offset of field: amdsmi_xgmi_info_t::reserved"][::std::mem::offset_of!(amdsmi_xgmi_info_t, reserved) - 28usize];
};
#[doc = " @brief VRam Usage\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_vram_usage_t {
    #[doc = "!< In MB"]
    pub vram_total: u32,
    #[doc = "!< In MB"]
    pub vram_used: u32,
    pub reserved: [u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_vram_usage_t"][::std::mem::size_of::<amdsmi_vram_usage_t>() - 16usize];
    ["Alignment of amdsmi_vram_usage_t"][::std::mem::align_of::<amdsmi_vram_usage_t>() - 4usize];
    ["Offset of field: amdsmi_vram_usage_t::vram_total"]
        [::std::mem::offset_of!(amdsmi_vram_usage_t, vram_total) - 0usize];
    ["Offset of field: amdsmi_vram_usage_t::vram_used"]
        [::std::mem::offset_of!(amdsmi_vram_usage_t, vram_used) - 4usize];
    ["Offset of field: amdsmi_vram_usage_t::reserved"][::std::mem::offset_of!(amdsmi_vram_usage_t, reserved) - 8usize];
};
#[doc = " @brief This structure hold violation status information.\n        Note: for MI3x asics and higher, older ASICs will show unsupported.\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_violation_status_t {
    #[doc = "!< Represents CPU timestamp in microseconds (uS)"]
    pub reference_timestamp: u64,
    #[doc = "!< Violation time.  Units in nanoseconds (ns) {@linux_bm}, in milliseconds (ms) {@host}"]
    pub violation_timestamp: u64,
    #[doc = "!< Current accumulated counter; Max uint64 means unsupported"]
    pub acc_counter: u64,
    #[doc = "!< Current accumulated processor hot violation count; Max uint64 means unsupported"]
    pub acc_prochot_thrm: u64,
    #[doc = "!< PVIOL; Current accumulated Package Power Tracking (PPT) count; Max uint64 means unsupported"]
    pub acc_ppt_pwr: u64,
    #[doc = "!< TVIOL; Current accumulated Socket thermal count; Max uint64 means unsupported"]
    pub acc_socket_thrm: u64,
    #[doc = "!< Current accumulated voltage regulator count; Max uint64 means unsupported"]
    pub acc_vr_thrm: u64,
    #[doc = "!< Current accumulated High Bandwidth Memory (HBM) thermal count; Max uint64 means unsupported"]
    pub acc_hbm_thrm: u64,
    #[doc = "< UPDATED in new driver 1.8: use new *_gfx_clk_below_host_limit_pwr, *_gfx_clk_below_host_limit_thm, *_gfx_clk_below_host_limit_total values!\nCurrent gfx clock below host limit count; Max uint64 means unsupported."]
    pub acc_gfx_clk_below_host_limit: u64,
    #[doc = "!< Processor hot violation % (greater than 0% is a violation); Max uint64 means unsupported"]
    pub per_prochot_thrm: u64,
    #[doc = "!< PVIOL; Package Power Tracking (PPT) violation % (greater than 0% is a violation); Max uint64 means unsupported"]
    pub per_ppt_pwr: u64,
    #[doc = "!< TVIOL; Socket thermal violation % (greater than 0% is a violation); Max uint64 means unsupported"]
    pub per_socket_thrm: u64,
    #[doc = "!< Voltage regulator violation % (greater than 0% is a violation); Max uint64 means unsupported"]
    pub per_vr_thrm: u64,
    #[doc = "!< High Bandwidth Memory (HBM) thermal violation % (greater than 0% is a violation); Max uint64 means unsupported"]
    pub per_hbm_thrm: u64,
    #[doc = "< UPDATED in new driver 1.8: use new *_gfx_clk_below_host_limit_pwr, *_gfx_clk_below_host_limit_thm, *_gfx_clk_below_host_limit_total values!\nGfx clock below host limit violation % (greater than 0% is a violation); Max uint64 means unsupported."]
    pub per_gfx_clk_below_host_limit: u64,
    #[doc = "!< Processor hot violation; 1 = active 0 = not active; Max uint8 means unsupported"]
    pub active_prochot_thrm: u8,
    #[doc = "!< Package Power Tracking (PPT) violation; 1 = active 0 = not active; Max uint8 means unsupported"]
    pub active_ppt_pwr: u8,
    #[doc = "!< Socket thermal violation; 1 = active 0 = not active; Max uint8 means unsupported"]
    pub active_socket_thrm: u8,
    #[doc = "!< Voltage regulator violation; 1 = active 0 = not active; Max uint8 means unsupported"]
    pub active_vr_thrm: u8,
    #[doc = "!< High Bandwidth Memory (HBM) thermal violation; 1 = active 0 = not active; Max uint8 means unsupported"]
    pub active_hbm_thrm: u8,
    #[doc = "< UPDATED in new driver 1.8: use new *_gfx_clk_below_host_limit_total values!\nGfx clock below host limit violation; 1 = active 0 = not active; Max uint8 means unsupported."]
    pub active_gfx_clk_below_host_limit: u8,
    #[doc = "!< New Driver 1.8 fields: Current gfx clock below host limit power count; Max uint64 means unsupported"]
    pub acc_gfx_clk_below_host_limit_pwr: [[u64; 8usize]; 8usize],
    #[doc = "!< New Driver 1.8 fields: Current gfx clock below host limit thermal count; Max uint64 means unsupported"]
    pub acc_gfx_clk_below_host_limit_thm: [[u64; 8usize]; 8usize],
    #[doc = "!< New Driver 1.8 fields: Current low utilization count; Max uint64 means unsupported"]
    pub acc_low_utilization: [[u64; 8usize]; 8usize],
    #[doc = "!< New Driver 1.8 fields: Current gfx clock below host limit total count; Max uint64 means unsupported"]
    pub acc_gfx_clk_below_host_limit_total: [[u64; 8usize]; 8usize],
    #[doc = "!< New Driver 1.8 fields: Gfx clock below host limit power violation % (greater than 0% is a violation); Max uint64 means unsupported"]
    pub per_gfx_clk_below_host_limit_pwr: [[u64; 8usize]; 8usize],
    #[doc = "!< New Driver 1.8 fields: Gfx clock below host limit violation % (greater than 0% is a violation); Max uint64 means unsupported"]
    pub per_gfx_clk_below_host_limit_thm: [[u64; 8usize]; 8usize],
    #[doc = "!< New Driver 1.8 fields: Low utilization violation % (greater than 0% is a violation); Max uint64 means unsupported"]
    pub per_low_utilization: [[u64; 8usize]; 8usize],
    #[doc = "!< New Driver 1.8 fields: Any Gfx clock below host limit violation % (greater than 0% is a violation); Max uint64 means unsupported"]
    pub per_gfx_clk_below_host_limit_total: [[u64; 8usize]; 8usize],
    #[doc = "!< New Driver 1.8 fields: Gfx clock below host limit power violation; 1 = active 0 = not active; Max uint8 means unsupported"]
    pub active_gfx_clk_below_host_limit_pwr: [[u8; 8usize]; 8usize],
    #[doc = "!< New Driver 1.8 fields: Gfx clock below host limit thermal violation; 1 = active 0 = not active; Max uint8 means unsupported"]
    pub active_gfx_clk_below_host_limit_thm: [[u8; 8usize]; 8usize],
    #[doc = "!< New Driver 1.8 fields: Low utilization violation; 1 = active 0 = not active; Max uint8 means unsupported"]
    pub active_low_utilization: [[u8; 8usize]; 8usize],
    #[doc = "!< New Driver 1.8 fields: Any Gfx clock host limit violation; 1 = active 0 = not active; Max uint8 means unsupported"]
    pub active_gfx_clk_below_host_limit_total: [[u8; 8usize]; 8usize],
    pub reserved: [[u64; 8usize]; 8usize],
    pub reserved2: [[u64; 8usize]; 8usize],
    pub reserved3: [[u64; 8usize]; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_violation_status_t"][::std::mem::size_of::<amdsmi_violation_status_t>() - 6016usize];
    ["Alignment of amdsmi_violation_status_t"][::std::mem::align_of::<amdsmi_violation_status_t>() - 8usize];
    ["Offset of field: amdsmi_violation_status_t::reference_timestamp"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, reference_timestamp) - 0usize];
    ["Offset of field: amdsmi_violation_status_t::violation_timestamp"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, violation_timestamp) - 8usize];
    ["Offset of field: amdsmi_violation_status_t::acc_counter"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, acc_counter) - 16usize];
    ["Offset of field: amdsmi_violation_status_t::acc_prochot_thrm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, acc_prochot_thrm) - 24usize];
    ["Offset of field: amdsmi_violation_status_t::acc_ppt_pwr"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, acc_ppt_pwr) - 32usize];
    ["Offset of field: amdsmi_violation_status_t::acc_socket_thrm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, acc_socket_thrm) - 40usize];
    ["Offset of field: amdsmi_violation_status_t::acc_vr_thrm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, acc_vr_thrm) - 48usize];
    ["Offset of field: amdsmi_violation_status_t::acc_hbm_thrm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, acc_hbm_thrm) - 56usize];
    ["Offset of field: amdsmi_violation_status_t::acc_gfx_clk_below_host_limit"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, acc_gfx_clk_below_host_limit) - 64usize];
    ["Offset of field: amdsmi_violation_status_t::per_prochot_thrm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, per_prochot_thrm) - 72usize];
    ["Offset of field: amdsmi_violation_status_t::per_ppt_pwr"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, per_ppt_pwr) - 80usize];
    ["Offset of field: amdsmi_violation_status_t::per_socket_thrm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, per_socket_thrm) - 88usize];
    ["Offset of field: amdsmi_violation_status_t::per_vr_thrm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, per_vr_thrm) - 96usize];
    ["Offset of field: amdsmi_violation_status_t::per_hbm_thrm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, per_hbm_thrm) - 104usize];
    ["Offset of field: amdsmi_violation_status_t::per_gfx_clk_below_host_limit"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, per_gfx_clk_below_host_limit) - 112usize];
    ["Offset of field: amdsmi_violation_status_t::active_prochot_thrm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, active_prochot_thrm) - 120usize];
    ["Offset of field: amdsmi_violation_status_t::active_ppt_pwr"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, active_ppt_pwr) - 121usize];
    ["Offset of field: amdsmi_violation_status_t::active_socket_thrm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, active_socket_thrm) - 122usize];
    ["Offset of field: amdsmi_violation_status_t::active_vr_thrm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, active_vr_thrm) - 123usize];
    ["Offset of field: amdsmi_violation_status_t::active_hbm_thrm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, active_hbm_thrm) - 124usize];
    ["Offset of field: amdsmi_violation_status_t::active_gfx_clk_below_host_limit"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, active_gfx_clk_below_host_limit) - 125usize];
    ["Offset of field: amdsmi_violation_status_t::acc_gfx_clk_below_host_limit_pwr"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, acc_gfx_clk_below_host_limit_pwr) - 128usize];
    ["Offset of field: amdsmi_violation_status_t::acc_gfx_clk_below_host_limit_thm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, acc_gfx_clk_below_host_limit_thm) - 640usize];
    ["Offset of field: amdsmi_violation_status_t::acc_low_utilization"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, acc_low_utilization) - 1152usize];
    ["Offset of field: amdsmi_violation_status_t::acc_gfx_clk_below_host_limit_total"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, acc_gfx_clk_below_host_limit_total) - 1664usize];
    ["Offset of field: amdsmi_violation_status_t::per_gfx_clk_below_host_limit_pwr"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, per_gfx_clk_below_host_limit_pwr) - 2176usize];
    ["Offset of field: amdsmi_violation_status_t::per_gfx_clk_below_host_limit_thm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, per_gfx_clk_below_host_limit_thm) - 2688usize];
    ["Offset of field: amdsmi_violation_status_t::per_low_utilization"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, per_low_utilization) - 3200usize];
    ["Offset of field: amdsmi_violation_status_t::per_gfx_clk_below_host_limit_total"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, per_gfx_clk_below_host_limit_total) - 3712usize];
    ["Offset of field: amdsmi_violation_status_t::active_gfx_clk_below_host_limit_pwr"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, active_gfx_clk_below_host_limit_pwr) - 4224usize];
    ["Offset of field: amdsmi_violation_status_t::active_gfx_clk_below_host_limit_thm"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, active_gfx_clk_below_host_limit_thm) - 4288usize];
    ["Offset of field: amdsmi_violation_status_t::active_low_utilization"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, active_low_utilization) - 4352usize];
    ["Offset of field: amdsmi_violation_status_t::active_gfx_clk_below_host_limit_total"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, active_gfx_clk_below_host_limit_total) - 4416usize];
    ["Offset of field: amdsmi_violation_status_t::reserved"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, reserved) - 4480usize];
    ["Offset of field: amdsmi_violation_status_t::reserved2"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, reserved2) - 4992usize];
    ["Offset of field: amdsmi_violation_status_t::reserved3"]
        [::std::mem::offset_of!(amdsmi_violation_status_t, reserved3) - 5504usize];
};
#[doc = " @brief Frequency Range\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_frequency_range_t {
    #[doc = "!< In MHz"]
    pub supported_freq_range: amdsmi_range_t,
    #[doc = "!< In MHz"]
    pub current_freq_range: amdsmi_range_t,
    pub reserved: [u32; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_frequency_range_t"][::std::mem::size_of::<amdsmi_frequency_range_t>() - 96usize];
    ["Alignment of amdsmi_frequency_range_t"][::std::mem::align_of::<amdsmi_frequency_range_t>() - 8usize];
    ["Offset of field: amdsmi_frequency_range_t::supported_freq_range"]
        [::std::mem::offset_of!(amdsmi_frequency_range_t, supported_freq_range) - 0usize];
    ["Offset of field: amdsmi_frequency_range_t::current_freq_range"]
        [::std::mem::offset_of!(amdsmi_frequency_range_t, current_freq_range) - 32usize];
    ["Offset of field: amdsmi_frequency_range_t::reserved"]
        [::std::mem::offset_of!(amdsmi_frequency_range_t, reserved) - 64usize];
};
#[doc = " @brief bdf types\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union amdsmi_bdf_t {
    pub bdf: amdsmi_bdf_t_bdf_,
    pub __bindgen_anon_1: amdsmi_bdf_t__bindgen_ty_1,
    pub as_uint: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_bdf_t_bdf_ {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_bdf_t_bdf_"][::std::mem::size_of::<amdsmi_bdf_t_bdf_>() - 8usize];
    ["Alignment of amdsmi_bdf_t_bdf_"][::std::mem::align_of::<amdsmi_bdf_t_bdf_>() - 8usize];
};
impl amdsmi_bdf_t_bdf_ {
    #[inline]
    pub fn function_number(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_function_number(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn function_number_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_function_number_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn device_number(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_device_number(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn device_number_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_device_number_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bus_number(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_bus_number(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bus_number_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_bus_number_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn domain_number(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_domain_number(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn domain_number_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                48u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_domain_number_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                48u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        function_number: u64,
        device_number: u64,
        bus_number: u64,
        domain_number: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let function_number: u64 = unsafe { ::std::mem::transmute(function_number) };
            function_number as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let device_number: u64 = unsafe { ::std::mem::transmute(device_number) };
            device_number as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let bus_number: u64 = unsafe { ::std::mem::transmute(bus_number) };
            bus_number as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let domain_number: u64 = unsafe { ::std::mem::transmute(domain_number) };
            domain_number as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_bdf_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_bdf_t__bindgen_ty_1"][::std::mem::size_of::<amdsmi_bdf_t__bindgen_ty_1>() - 8usize];
    ["Alignment of amdsmi_bdf_t__bindgen_ty_1"][::std::mem::align_of::<amdsmi_bdf_t__bindgen_ty_1>() - 8usize];
};
impl amdsmi_bdf_t__bindgen_ty_1 {
    #[inline]
    pub fn function_number(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_function_number(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn function_number_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_function_number_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn device_number(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_device_number(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn device_number_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_device_number_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bus_number(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_bus_number(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bus_number_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_bus_number_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn domain_number(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_domain_number(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn domain_number_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                48u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_domain_number_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                48u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        function_number: u64,
        device_number: u64,
        bus_number: u64,
        domain_number: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let function_number: u64 = unsafe { ::std::mem::transmute(function_number) };
            function_number as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let device_number: u64 = unsafe { ::std::mem::transmute(device_number) };
            device_number as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let bus_number: u64 = unsafe { ::std::mem::transmute(bus_number) };
            bus_number as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let domain_number: u64 = unsafe { ::std::mem::transmute(domain_number) };
            domain_number as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_bdf_t"][::std::mem::size_of::<amdsmi_bdf_t>() - 8usize];
    ["Alignment of amdsmi_bdf_t"][::std::mem::align_of::<amdsmi_bdf_t>() - 8usize];
    ["Offset of field: amdsmi_bdf_t::bdf"][::std::mem::offset_of!(amdsmi_bdf_t, bdf) - 0usize];
    ["Offset of field: amdsmi_bdf_t::as_uint"][::std::mem::offset_of!(amdsmi_bdf_t, as_uint) - 0usize];
};
#[doc = " @brief Structure holds enumeration information\n\n @cond @tag{gpu_bm_linux} @tag{guest_1vf} @tag{guest_mvf} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_enumeration_info_t {
    #[doc = "!< the render node under /sys/class/drm/renderD*"]
    pub drm_render: u32,
    #[doc = "!< the graphic card device under /sys/class/drm/card*"]
    pub drm_card: u32,
    #[doc = "!< the HSA enumeration ID"]
    pub hsa_id: u32,
    #[doc = "!< the HIP enumeration ID"]
    pub hip_id: u32,
    #[doc = "!< the HIP unique identifer"]
    pub hip_uuid: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_enumeration_info_t"][::std::mem::size_of::<amdsmi_enumeration_info_t>() - 272usize];
    ["Alignment of amdsmi_enumeration_info_t"][::std::mem::align_of::<amdsmi_enumeration_info_t>() - 4usize];
    ["Offset of field: amdsmi_enumeration_info_t::drm_render"]
        [::std::mem::offset_of!(amdsmi_enumeration_info_t, drm_render) - 0usize];
    ["Offset of field: amdsmi_enumeration_info_t::drm_card"]
        [::std::mem::offset_of!(amdsmi_enumeration_info_t, drm_card) - 4usize];
    ["Offset of field: amdsmi_enumeration_info_t::hsa_id"]
        [::std::mem::offset_of!(amdsmi_enumeration_info_t, hsa_id) - 8usize];
    ["Offset of field: amdsmi_enumeration_info_t::hip_id"]
        [::std::mem::offset_of!(amdsmi_enumeration_info_t, hip_id) - 12usize];
    ["Offset of field: amdsmi_enumeration_info_t::hip_uuid"]
        [::std::mem::offset_of!(amdsmi_enumeration_info_t, hip_uuid) - 16usize];
};
#[doc = "!< PCIE card form factor"]
pub const amdsmi_card_form_factor_t_AMDSMI_CARD_FORM_FACTOR_PCIE: amdsmi_card_form_factor_t = 0;
#[doc = "!< OAM form factor"]
pub const amdsmi_card_form_factor_t_AMDSMI_CARD_FORM_FACTOR_OAM: amdsmi_card_form_factor_t = 1;
#[doc = "!< CEM form factor"]
pub const amdsmi_card_form_factor_t_AMDSMI_CARD_FORM_FACTOR_CEM: amdsmi_card_form_factor_t = 2;
#[doc = "!< Unknown Form factor"]
pub const amdsmi_card_form_factor_t_AMDSMI_CARD_FORM_FACTOR_UNKNOWN: amdsmi_card_form_factor_t = 3;
#[doc = " @brief Card Form Factor\n\n @cond @tag{gpu_bm_linux} @tag{host} @tag{guest_windows} @endcond"]
pub type amdsmi_card_form_factor_t = ::std::os::raw::c_uint;
#[doc = " @brief pcie information\n\n @cond @tag{gpu_bm_linux} @tag{host} @tag{guest_windows} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_pcie_info_t {
    pub pcie_static: amdsmi_pcie_info_t_pcie_static_,
    pub pcie_metric: amdsmi_pcie_info_t_pcie_metric_,
    pub reserved: [u64; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_pcie_info_t_pcie_static_ {
    #[doc = "!< maximum number of PCIe lanes"]
    pub max_pcie_width: u16,
    #[doc = "!< maximum PCIe speed in GT/s"]
    pub max_pcie_speed: u32,
    #[doc = "!< PCIe interface version"]
    pub pcie_interface_version: u32,
    #[doc = "!< card form factor"]
    pub slot_type: amdsmi_card_form_factor_t,
    #[doc = "!< maximum PCIe link generation"]
    pub max_pcie_interface_version: u32,
    pub reserved: [u64; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_pcie_info_t_pcie_static_"][::std::mem::size_of::<amdsmi_pcie_info_t_pcie_static_>() - 96usize];
    ["Alignment of amdsmi_pcie_info_t_pcie_static_"]
        [::std::mem::align_of::<amdsmi_pcie_info_t_pcie_static_>() - 8usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_static_::max_pcie_width"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_static_, max_pcie_width) - 0usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_static_::max_pcie_speed"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_static_, max_pcie_speed) - 4usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_static_::pcie_interface_version"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_static_, pcie_interface_version) - 8usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_static_::slot_type"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_static_, slot_type) - 12usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_static_::max_pcie_interface_version"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_static_, max_pcie_interface_version) - 16usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_static_::reserved"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_static_, reserved) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_pcie_info_t_pcie_metric_ {
    #[doc = "!< current PCIe width"]
    pub pcie_width: u16,
    #[doc = "!< current PCIe speed in MT/s"]
    pub pcie_speed: u32,
    #[doc = "!< current instantaneous PCIe bandwidth in Mb/s"]
    pub pcie_bandwidth: u32,
    #[doc = "!< total number of the replays issued on the PCIe link"]
    pub pcie_replay_count: u64,
    #[doc = "!< total number of times the PCIe link transitioned from L0 to the recovery state"]
    pub pcie_l0_to_recovery_count: u64,
    #[doc = "!< total number of replay rollovers issued on the PCIe link"]
    pub pcie_replay_roll_over_count: u64,
    #[doc = "!< total number of NAKs issued on the PCIe link by the device"]
    pub pcie_nak_sent_count: u64,
    #[doc = "!< total number of NAKs issued on the PCIe link by the receiver"]
    pub pcie_nak_received_count: u64,
    #[doc = "!< PCIe other end recovery counter"]
    pub pcie_lc_perf_other_end_recovery_count: u32,
    pub reserved: [u64; 12usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_pcie_info_t_pcie_metric_"][::std::mem::size_of::<amdsmi_pcie_info_t_pcie_metric_>() - 160usize];
    ["Alignment of amdsmi_pcie_info_t_pcie_metric_"]
        [::std::mem::align_of::<amdsmi_pcie_info_t_pcie_metric_>() - 8usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_metric_::pcie_width"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_metric_, pcie_width) - 0usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_metric_::pcie_speed"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_metric_, pcie_speed) - 4usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_metric_::pcie_bandwidth"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_metric_, pcie_bandwidth) - 8usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_metric_::pcie_replay_count"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_metric_, pcie_replay_count) - 16usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_metric_::pcie_l0_to_recovery_count"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_metric_, pcie_l0_to_recovery_count) - 24usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_metric_::pcie_replay_roll_over_count"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_metric_, pcie_replay_roll_over_count) - 32usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_metric_::pcie_nak_sent_count"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_metric_, pcie_nak_sent_count) - 40usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_metric_::pcie_nak_received_count"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_metric_, pcie_nak_received_count) - 48usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_metric_::pcie_lc_perf_other_end_recovery_count"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_metric_, pcie_lc_perf_other_end_recovery_count) - 56usize];
    ["Offset of field: amdsmi_pcie_info_t_pcie_metric_::reserved"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t_pcie_metric_, reserved) - 64usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_pcie_info_t"][::std::mem::size_of::<amdsmi_pcie_info_t>() - 512usize];
    ["Alignment of amdsmi_pcie_info_t"][::std::mem::align_of::<amdsmi_pcie_info_t>() - 8usize];
    ["Offset of field: amdsmi_pcie_info_t::pcie_static"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t, pcie_static) - 0usize];
    ["Offset of field: amdsmi_pcie_info_t::pcie_metric"]
        [::std::mem::offset_of!(amdsmi_pcie_info_t, pcie_metric) - 96usize];
    ["Offset of field: amdsmi_pcie_info_t::reserved"][::std::mem::offset_of!(amdsmi_pcie_info_t, reserved) - 256usize];
};
#[doc = " @brief Power Cap Information\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_power_cap_info_t {
    #[doc = "!< current power cap Units uW {@linux_bm} or W {@host}"]
    pub power_cap: u64,
    #[doc = "!< default power cap Units uW {@linux_bm} or W {@host}"]
    pub default_power_cap: u64,
    #[doc = "!< dpm power cap Units MHz {@linux_bm} or Hz {@host}"]
    pub dpm_cap: u64,
    #[doc = "!< minimum power cap Units uW {@linux_bm} or W {@host}"]
    pub min_power_cap: u64,
    #[doc = "!< maximum power cap Units uW {@linux_bm} or W {@host}"]
    pub max_power_cap: u64,
    pub reserved: [u64; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_power_cap_info_t"][::std::mem::size_of::<amdsmi_power_cap_info_t>() - 64usize];
    ["Alignment of amdsmi_power_cap_info_t"][::std::mem::align_of::<amdsmi_power_cap_info_t>() - 8usize];
    ["Offset of field: amdsmi_power_cap_info_t::power_cap"]
        [::std::mem::offset_of!(amdsmi_power_cap_info_t, power_cap) - 0usize];
    ["Offset of field: amdsmi_power_cap_info_t::default_power_cap"]
        [::std::mem::offset_of!(amdsmi_power_cap_info_t, default_power_cap) - 8usize];
    ["Offset of field: amdsmi_power_cap_info_t::dpm_cap"]
        [::std::mem::offset_of!(amdsmi_power_cap_info_t, dpm_cap) - 16usize];
    ["Offset of field: amdsmi_power_cap_info_t::min_power_cap"]
        [::std::mem::offset_of!(amdsmi_power_cap_info_t, min_power_cap) - 24usize];
    ["Offset of field: amdsmi_power_cap_info_t::max_power_cap"]
        [::std::mem::offset_of!(amdsmi_power_cap_info_t, max_power_cap) - 32usize];
    ["Offset of field: amdsmi_power_cap_info_t::reserved"]
        [::std::mem::offset_of!(amdsmi_power_cap_info_t, reserved) - 40usize];
};
#[doc = "!< PPT0 power cap; lower limit, filtered input"]
pub const amdsmi_power_cap_type_t_AMDSMI_POWER_CAP_TYPE_PPT0: amdsmi_power_cap_type_t = 0;
#[doc = "!< PPT1 power cap; higher limit, raw input"]
pub const amdsmi_power_cap_type_t_AMDSMI_POWER_CAP_TYPE_PPT1: amdsmi_power_cap_type_t = 1;
#[doc = " @brief Power Cap Package Power Tracking (PPT) type\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_power_cap_type_t = ::std::os::raw::c_uint;
#[doc = " @brief VBios Information\n\n @cond @tag{gpu_bm_linux} @tag{guest_windows} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_vbios_info_t {
    pub name: [::std::os::raw::c_char; 256usize],
    pub build_date: [::std::os::raw::c_char; 256usize],
    pub part_number: [::std::os::raw::c_char; 256usize],
    pub version: [::std::os::raw::c_char; 256usize],
    pub boot_firmware: [::std::os::raw::c_char; 256usize],
    pub reserved: [u64; 36usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_vbios_info_t"][::std::mem::size_of::<amdsmi_vbios_info_t>() - 1568usize];
    ["Alignment of amdsmi_vbios_info_t"][::std::mem::align_of::<amdsmi_vbios_info_t>() - 8usize];
    ["Offset of field: amdsmi_vbios_info_t::name"][::std::mem::offset_of!(amdsmi_vbios_info_t, name) - 0usize];
    ["Offset of field: amdsmi_vbios_info_t::build_date"]
        [::std::mem::offset_of!(amdsmi_vbios_info_t, build_date) - 256usize];
    ["Offset of field: amdsmi_vbios_info_t::part_number"]
        [::std::mem::offset_of!(amdsmi_vbios_info_t, part_number) - 512usize];
    ["Offset of field: amdsmi_vbios_info_t::version"][::std::mem::offset_of!(amdsmi_vbios_info_t, version) - 768usize];
    ["Offset of field: amdsmi_vbios_info_t::boot_firmware"]
        [::std::mem::offset_of!(amdsmi_vbios_info_t, boot_firmware) - 1024usize];
    ["Offset of field: amdsmi_vbios_info_t::reserved"]
        [::std::mem::offset_of!(amdsmi_vbios_info_t, reserved) - 1280usize];
};
#[doc = "!< Cache enabled"]
pub const amdsmi_cache_property_type_t_AMDSMI_CACHE_PROPERTY_ENABLED: amdsmi_cache_property_type_t = 1;
#[doc = "!< Data cache"]
pub const amdsmi_cache_property_type_t_AMDSMI_CACHE_PROPERTY_DATA_CACHE: amdsmi_cache_property_type_t = 2;
#[doc = "!< Instruction cache"]
pub const amdsmi_cache_property_type_t_AMDSMI_CACHE_PROPERTY_INST_CACHE: amdsmi_cache_property_type_t = 4;
#[doc = "!< CPU cache"]
pub const amdsmi_cache_property_type_t_AMDSMI_CACHE_PROPERTY_CPU_CACHE: amdsmi_cache_property_type_t = 8;
#[doc = "!< Single Instruction, Multiple Data Cache"]
pub const amdsmi_cache_property_type_t_AMDSMI_CACHE_PROPERTY_SIMD_CACHE: amdsmi_cache_property_type_t = 16;
#[doc = " @brief cache properties\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_cache_property_type_t = ::std::os::raw::c_uint;
#[doc = " @brief GPU Cache Information\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_gpu_cache_info_t {
    pub num_cache_types: u32,
    pub cache: [amdsmi_gpu_cache_info_t_cache_; 10usize],
    pub reserved: [u32; 15usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_gpu_cache_info_t_cache_ {
    #[doc = "!< amdsmi_cache_property_type_t which is a bitmask"]
    pub cache_properties: u32,
    #[doc = "!< In KB"]
    pub cache_size: u32,
    pub cache_level: u32,
    #[doc = "!< Indicates how many Compute Units share this cache instance"]
    pub max_num_cu_shared: u32,
    #[doc = "!< total number of instance of this cache type"]
    pub num_cache_instance: u32,
    pub reserved: [u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_gpu_cache_info_t_cache_"][::std::mem::size_of::<amdsmi_gpu_cache_info_t_cache_>() - 32usize];
    ["Alignment of amdsmi_gpu_cache_info_t_cache_"][::std::mem::align_of::<amdsmi_gpu_cache_info_t_cache_>() - 4usize];
    ["Offset of field: amdsmi_gpu_cache_info_t_cache_::cache_properties"]
        [::std::mem::offset_of!(amdsmi_gpu_cache_info_t_cache_, cache_properties) - 0usize];
    ["Offset of field: amdsmi_gpu_cache_info_t_cache_::cache_size"]
        [::std::mem::offset_of!(amdsmi_gpu_cache_info_t_cache_, cache_size) - 4usize];
    ["Offset of field: amdsmi_gpu_cache_info_t_cache_::cache_level"]
        [::std::mem::offset_of!(amdsmi_gpu_cache_info_t_cache_, cache_level) - 8usize];
    ["Offset of field: amdsmi_gpu_cache_info_t_cache_::max_num_cu_shared"]
        [::std::mem::offset_of!(amdsmi_gpu_cache_info_t_cache_, max_num_cu_shared) - 12usize];
    ["Offset of field: amdsmi_gpu_cache_info_t_cache_::num_cache_instance"]
        [::std::mem::offset_of!(amdsmi_gpu_cache_info_t_cache_, num_cache_instance) - 16usize];
    ["Offset of field: amdsmi_gpu_cache_info_t_cache_::reserved"]
        [::std::mem::offset_of!(amdsmi_gpu_cache_info_t_cache_, reserved) - 20usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_gpu_cache_info_t"][::std::mem::size_of::<amdsmi_gpu_cache_info_t>() - 384usize];
    ["Alignment of amdsmi_gpu_cache_info_t"][::std::mem::align_of::<amdsmi_gpu_cache_info_t>() - 4usize];
    ["Offset of field: amdsmi_gpu_cache_info_t::num_cache_types"]
        [::std::mem::offset_of!(amdsmi_gpu_cache_info_t, num_cache_types) - 0usize];
    ["Offset of field: amdsmi_gpu_cache_info_t::cache"]
        [::std::mem::offset_of!(amdsmi_gpu_cache_info_t, cache) - 4usize];
    ["Offset of field: amdsmi_gpu_cache_info_t::reserved"]
        [::std::mem::offset_of!(amdsmi_gpu_cache_info_t, reserved) - 324usize];
};
#[doc = " @brief Firmware Information\n\n @cond @tag{gpu_bm_linux} @tag{host} @tag{guest_windows} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_fw_info_t {
    pub num_fw_info: u8,
    pub fw_info_list: [amdsmi_fw_info_t_fw_info_list_; 80usize],
    pub reserved: [u32; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_fw_info_t_fw_info_list_ {
    pub fw_id: amdsmi_fw_block_t,
    pub fw_version: u64,
    pub reserved: [u64; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_fw_info_t_fw_info_list_"][::std::mem::size_of::<amdsmi_fw_info_t_fw_info_list_>() - 32usize];
    ["Alignment of amdsmi_fw_info_t_fw_info_list_"][::std::mem::align_of::<amdsmi_fw_info_t_fw_info_list_>() - 8usize];
    ["Offset of field: amdsmi_fw_info_t_fw_info_list_::fw_id"]
        [::std::mem::offset_of!(amdsmi_fw_info_t_fw_info_list_, fw_id) - 0usize];
    ["Offset of field: amdsmi_fw_info_t_fw_info_list_::fw_version"]
        [::std::mem::offset_of!(amdsmi_fw_info_t_fw_info_list_, fw_version) - 8usize];
    ["Offset of field: amdsmi_fw_info_t_fw_info_list_::reserved"]
        [::std::mem::offset_of!(amdsmi_fw_info_t_fw_info_list_, reserved) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_fw_info_t"][::std::mem::size_of::<amdsmi_fw_info_t>() - 2600usize];
    ["Alignment of amdsmi_fw_info_t"][::std::mem::align_of::<amdsmi_fw_info_t>() - 8usize];
    ["Offset of field: amdsmi_fw_info_t::num_fw_info"][::std::mem::offset_of!(amdsmi_fw_info_t, num_fw_info) - 0usize];
    ["Offset of field: amdsmi_fw_info_t::fw_info_list"]
        [::std::mem::offset_of!(amdsmi_fw_info_t, fw_info_list) - 8usize];
    ["Offset of field: amdsmi_fw_info_t::reserved"][::std::mem::offset_of!(amdsmi_fw_info_t, reserved) - 2568usize];
};
#[doc = " @brief ASIC Information\n\n @cond @tag{gpu_bm_linux} @tag{guest_windows} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_asic_info_t {
    pub market_name: [::std::os::raw::c_char; 256usize],
    #[doc = "!< Use 32 bit to be compatible with other platform."]
    pub vendor_id: u32,
    pub vendor_name: [::std::os::raw::c_char; 256usize],
    #[doc = "!< The subsystem vendor ID"]
    pub subvendor_id: u32,
    #[doc = "!< The device ID of a GPU"]
    pub device_id: u64,
    #[doc = "!< The revision ID of a GPU"]
    pub rev_id: u32,
    pub asic_serial: [::std::os::raw::c_char; 256usize],
    #[doc = "!< 0xFFFFFFFF if not supported"]
    pub oam_id: u32,
    #[doc = "!< 0xFFFFFFFF if not supported"]
    pub num_of_compute_units: u32,
    #[doc = "!< 0xFFFFFFFFFFFFFFFF if not supported"]
    pub target_graphics_version: u64,
    pub subsystem_id: u32,
    #[doc = "!> The subsystem ID"]
    pub reserved: [u32; 21usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_asic_info_t"][::std::mem::size_of::<amdsmi_asic_info_t>() - 896usize];
    ["Alignment of amdsmi_asic_info_t"][::std::mem::align_of::<amdsmi_asic_info_t>() - 8usize];
    ["Offset of field: amdsmi_asic_info_t::market_name"]
        [::std::mem::offset_of!(amdsmi_asic_info_t, market_name) - 0usize];
    ["Offset of field: amdsmi_asic_info_t::vendor_id"]
        [::std::mem::offset_of!(amdsmi_asic_info_t, vendor_id) - 256usize];
    ["Offset of field: amdsmi_asic_info_t::vendor_name"]
        [::std::mem::offset_of!(amdsmi_asic_info_t, vendor_name) - 260usize];
    ["Offset of field: amdsmi_asic_info_t::subvendor_id"]
        [::std::mem::offset_of!(amdsmi_asic_info_t, subvendor_id) - 516usize];
    ["Offset of field: amdsmi_asic_info_t::device_id"]
        [::std::mem::offset_of!(amdsmi_asic_info_t, device_id) - 520usize];
    ["Offset of field: amdsmi_asic_info_t::rev_id"][::std::mem::offset_of!(amdsmi_asic_info_t, rev_id) - 528usize];
    ["Offset of field: amdsmi_asic_info_t::asic_serial"]
        [::std::mem::offset_of!(amdsmi_asic_info_t, asic_serial) - 532usize];
    ["Offset of field: amdsmi_asic_info_t::oam_id"][::std::mem::offset_of!(amdsmi_asic_info_t, oam_id) - 788usize];
    ["Offset of field: amdsmi_asic_info_t::num_of_compute_units"]
        [::std::mem::offset_of!(amdsmi_asic_info_t, num_of_compute_units) - 792usize];
    ["Offset of field: amdsmi_asic_info_t::target_graphics_version"]
        [::std::mem::offset_of!(amdsmi_asic_info_t, target_graphics_version) - 800usize];
    ["Offset of field: amdsmi_asic_info_t::subsystem_id"]
        [::std::mem::offset_of!(amdsmi_asic_info_t, subsystem_id) - 808usize];
    ["Offset of field: amdsmi_asic_info_t::reserved"][::std::mem::offset_of!(amdsmi_asic_info_t, reserved) - 812usize];
};
#[doc = " @brief Structure holds kfd information\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_kfd_info_t {
    #[doc = "!< 0xFFFFFFFFFFFFFFFF if not supported"]
    pub kfd_id: u64,
    #[doc = "!< 0xFFFFFFFF if not supported"]
    pub node_id: u32,
    #[doc = "!< 0xFFFFFFFF if not supported"]
    pub current_partition_id: u32,
    pub reserved: [u32; 12usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_kfd_info_t"][::std::mem::size_of::<amdsmi_kfd_info_t>() - 64usize];
    ["Alignment of amdsmi_kfd_info_t"][::std::mem::align_of::<amdsmi_kfd_info_t>() - 8usize];
    ["Offset of field: amdsmi_kfd_info_t::kfd_id"][::std::mem::offset_of!(amdsmi_kfd_info_t, kfd_id) - 0usize];
    ["Offset of field: amdsmi_kfd_info_t::node_id"][::std::mem::offset_of!(amdsmi_kfd_info_t, node_id) - 8usize];
    ["Offset of field: amdsmi_kfd_info_t::current_partition_id"]
        [::std::mem::offset_of!(amdsmi_kfd_info_t, current_partition_id) - 12usize];
    ["Offset of field: amdsmi_kfd_info_t::reserved"][::std::mem::offset_of!(amdsmi_kfd_info_t, reserved) - 16usize];
};
#[doc = " @brief This union holds memory partition bitmask.\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union amdsmi_nps_caps_t {
    pub nps_flags: amdsmi_nps_caps_t_nps_flags_,
    pub nps_cap_mask: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_nps_caps_t_nps_flags_ {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_nps_caps_t_nps_flags_"][::std::mem::size_of::<amdsmi_nps_caps_t_nps_flags_>() - 4usize];
    ["Alignment of amdsmi_nps_caps_t_nps_flags_"][::std::mem::align_of::<amdsmi_nps_caps_t_nps_flags_>() - 4usize];
};
impl amdsmi_nps_caps_t_nps_flags_ {
    #[inline]
    pub fn nps1_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nps1_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nps1_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nps1_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nps2_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nps2_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nps2_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nps2_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nps4_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nps4_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nps4_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nps4_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nps8_cap(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nps8_cap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nps8_cap_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nps8_cap_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nps1_cap: u32,
        nps2_cap: u32,
        nps4_cap: u32,
        nps8_cap: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nps1_cap: u32 = unsafe { ::std::mem::transmute(nps1_cap) };
            nps1_cap as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nps2_cap: u32 = unsafe { ::std::mem::transmute(nps2_cap) };
            nps2_cap as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let nps4_cap: u32 = unsafe { ::std::mem::transmute(nps4_cap) };
            nps4_cap as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let nps8_cap: u32 = unsafe { ::std::mem::transmute(nps8_cap) };
            nps8_cap as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_nps_caps_t"][::std::mem::size_of::<amdsmi_nps_caps_t>() - 4usize];
    ["Alignment of amdsmi_nps_caps_t"][::std::mem::align_of::<amdsmi_nps_caps_t>() - 4usize];
    ["Offset of field: amdsmi_nps_caps_t::nps_flags"][::std::mem::offset_of!(amdsmi_nps_caps_t, nps_flags) - 0usize];
    ["Offset of field: amdsmi_nps_caps_t::nps_cap_mask"]
        [::std::mem::offset_of!(amdsmi_nps_caps_t, nps_cap_mask) - 0usize];
};
#[doc = " @brief Memory Partition Configuration.\n This structure is used to identify various memory partition configurations.\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amdsmi_memory_partition_config_t {
    pub partition_caps: amdsmi_nps_caps_t,
    pub mp_mode: amdsmi_memory_partition_type_t,
    pub num_numa_ranges: u32,
    pub numa_range: [amdsmi_memory_partition_config_t_numa_range_; 32usize],
    pub reserved: [u64; 11usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_memory_partition_config_t_numa_range_ {
    pub memory_type: amdsmi_vram_type_t,
    pub start: u64,
    pub end: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_memory_partition_config_t_numa_range_"]
        [::std::mem::size_of::<amdsmi_memory_partition_config_t_numa_range_>() - 24usize];
    ["Alignment of amdsmi_memory_partition_config_t_numa_range_"]
        [::std::mem::align_of::<amdsmi_memory_partition_config_t_numa_range_>() - 8usize];
    ["Offset of field: amdsmi_memory_partition_config_t_numa_range_::memory_type"]
        [::std::mem::offset_of!(amdsmi_memory_partition_config_t_numa_range_, memory_type) - 0usize];
    ["Offset of field: amdsmi_memory_partition_config_t_numa_range_::start"]
        [::std::mem::offset_of!(amdsmi_memory_partition_config_t_numa_range_, start) - 8usize];
    ["Offset of field: amdsmi_memory_partition_config_t_numa_range_::end"]
        [::std::mem::offset_of!(amdsmi_memory_partition_config_t_numa_range_, end) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_memory_partition_config_t"][::std::mem::size_of::<amdsmi_memory_partition_config_t>() - 872usize];
    ["Alignment of amdsmi_memory_partition_config_t"]
        [::std::mem::align_of::<amdsmi_memory_partition_config_t>() - 8usize];
    ["Offset of field: amdsmi_memory_partition_config_t::partition_caps"]
        [::std::mem::offset_of!(amdsmi_memory_partition_config_t, partition_caps) - 0usize];
    ["Offset of field: amdsmi_memory_partition_config_t::mp_mode"]
        [::std::mem::offset_of!(amdsmi_memory_partition_config_t, mp_mode) - 4usize];
    ["Offset of field: amdsmi_memory_partition_config_t::num_numa_ranges"]
        [::std::mem::offset_of!(amdsmi_memory_partition_config_t, num_numa_ranges) - 8usize];
    ["Offset of field: amdsmi_memory_partition_config_t::numa_range"]
        [::std::mem::offset_of!(amdsmi_memory_partition_config_t, numa_range) - 16usize];
    ["Offset of field: amdsmi_memory_partition_config_t::reserved"]
        [::std::mem::offset_of!(amdsmi_memory_partition_config_t, reserved) - 784usize];
};
#[doc = " @brief Accelerator Partition Resource Profile\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amdsmi_accelerator_partition_profile_t {
    #[doc = "!< SPX, DPX, QPX, CPX and so on"]
    pub profile_type: amdsmi_accelerator_partition_type_t,
    #[doc = "!< On MI300X: SPX=>1, DPX=>2, QPX=>4, CPX=>8; length of resources"]
    pub num_partitions: u32,
    #[doc = "!< Possible memory partition capabilities"]
    pub memory_caps: amdsmi_nps_caps_t,
    #[doc = "!< Index in the profiles array in amdsmi_accelerator_partition_profile_t"]
    pub profile_index: u32,
    #[doc = "!< length of index_of_resources_profile"]
    pub num_resources: u32,
    pub resources: [[u32; 32usize]; 8usize],
    pub reserved: [u64; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_accelerator_partition_profile_t"]
        [::std::mem::size_of::<amdsmi_accelerator_partition_profile_t>() - 1152usize];
    ["Alignment of amdsmi_accelerator_partition_profile_t"]
        [::std::mem::align_of::<amdsmi_accelerator_partition_profile_t>() - 8usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_t::profile_type"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_t, profile_type) - 0usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_t::num_partitions"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_t, num_partitions) - 4usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_t::memory_caps"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_t, memory_caps) - 8usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_t::profile_index"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_t, profile_index) - 12usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_t::num_resources"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_t, num_resources) - 16usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_t::resources"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_t, resources) - 20usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_t::reserved"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_t, reserved) - 1048usize];
};
#[doc = " @brief  Accelerator Partition Resources.\n This struct is used to identify various partition resource profiles.\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_accelerator_partition_resource_profile_t {
    pub profile_index: u32,
    pub resource_type: amdsmi_accelerator_partition_resource_type_t,
    #[doc = "!< Resources a partition can use, which may be shared"]
    pub partition_resource: u32,
    #[doc = "!< If it is greater than 1, then resource is shared."]
    pub num_partitions_share_resource: u32,
    pub reserved: [u64; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_accelerator_partition_resource_profile_t"]
        [::std::mem::size_of::<amdsmi_accelerator_partition_resource_profile_t>() - 64usize];
    ["Alignment of amdsmi_accelerator_partition_resource_profile_t"]
        [::std::mem::align_of::<amdsmi_accelerator_partition_resource_profile_t>() - 8usize];
    ["Offset of field: amdsmi_accelerator_partition_resource_profile_t::profile_index"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_resource_profile_t, profile_index) - 0usize];
    ["Offset of field: amdsmi_accelerator_partition_resource_profile_t::resource_type"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_resource_profile_t, resource_type) - 4usize];
    ["Offset of field: amdsmi_accelerator_partition_resource_profile_t::partition_resource"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_resource_profile_t, partition_resource) - 8usize];
    ["Offset of field: amdsmi_accelerator_partition_resource_profile_t::num_partitions_share_resource"][::std::mem::offset_of!(
        amdsmi_accelerator_partition_resource_profile_t,
        num_partitions_share_resource
    ) - 12usize];
    ["Offset of field: amdsmi_accelerator_partition_resource_profile_t::reserved"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_resource_profile_t, reserved) - 16usize];
};
#[doc = " @brief Accelerator Partition Profile Configurations\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amdsmi_accelerator_partition_profile_config_t {
    #[doc = "!< The length of profiles array"]
    pub num_profiles: u32,
    pub num_resource_profiles: u32,
    pub resource_profiles: [amdsmi_accelerator_partition_resource_profile_t; 32usize],
    #[doc = "!< The index of the default profile in the profiles array"]
    pub default_profile_index: u32,
    pub profiles: [amdsmi_accelerator_partition_profile_t; 32usize],
    pub reserved: [u64; 30usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_accelerator_partition_profile_config_t"]
        [::std::mem::size_of::<amdsmi_accelerator_partition_profile_config_t>() - 39168usize];
    ["Alignment of amdsmi_accelerator_partition_profile_config_t"]
        [::std::mem::align_of::<amdsmi_accelerator_partition_profile_config_t>() - 8usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_config_t::num_profiles"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_config_t, num_profiles) - 0usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_config_t::num_resource_profiles"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_config_t, num_resource_profiles) - 4usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_config_t::resource_profiles"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_config_t, resource_profiles) - 8usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_config_t::default_profile_index"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_config_t, default_profile_index) - 2056usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_config_t::profiles"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_config_t, profiles) - 2064usize];
    ["Offset of field: amdsmi_accelerator_partition_profile_config_t::reserved"]
        [::std::mem::offset_of!(amdsmi_accelerator_partition_profile_config_t, reserved) - 38928usize];
};
#[doc = "!< Internal Link Type, within chip"]
pub const amdsmi_link_type_t_AMDSMI_LINK_TYPE_INTERNAL: amdsmi_link_type_t = 0;
#[doc = "!< Peripheral Component Interconnect Express Link Type"]
pub const amdsmi_link_type_t_AMDSMI_LINK_TYPE_PCIE: amdsmi_link_type_t = 1;
#[doc = "!< GPU Memory Interconnect (multi GPU communication)"]
pub const amdsmi_link_type_t_AMDSMI_LINK_TYPE_XGMI: amdsmi_link_type_t = 2;
#[doc = "!< Not Applicable Link Type"]
pub const amdsmi_link_type_t_AMDSMI_LINK_TYPE_NOT_APPLICABLE: amdsmi_link_type_t = 3;
#[doc = "!< Unknown Link Type"]
pub const amdsmi_link_type_t_AMDSMI_LINK_TYPE_UNKNOWN: amdsmi_link_type_t = 4;
#[doc = " @brief Link type\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_link_type_t = ::std::os::raw::c_uint;
#[doc = " @brief This structure holds CPU utilization information.\n\n @cond @tag{cpu_bm} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_cpu_util_t {
    pub cpu_util_total: u32,
    pub cpu_util_user: u32,
    pub cpu_util_nice: u32,
    pub cpu_util_sys: u32,
    pub cpu_util_irq: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_cpu_util_t"][::std::mem::size_of::<amdsmi_cpu_util_t>() - 20usize];
    ["Alignment of amdsmi_cpu_util_t"][::std::mem::align_of::<amdsmi_cpu_util_t>() - 4usize];
    ["Offset of field: amdsmi_cpu_util_t::cpu_util_total"]
        [::std::mem::offset_of!(amdsmi_cpu_util_t, cpu_util_total) - 0usize];
    ["Offset of field: amdsmi_cpu_util_t::cpu_util_user"]
        [::std::mem::offset_of!(amdsmi_cpu_util_t, cpu_util_user) - 4usize];
    ["Offset of field: amdsmi_cpu_util_t::cpu_util_nice"]
        [::std::mem::offset_of!(amdsmi_cpu_util_t, cpu_util_nice) - 8usize];
    ["Offset of field: amdsmi_cpu_util_t::cpu_util_sys"]
        [::std::mem::offset_of!(amdsmi_cpu_util_t, cpu_util_sys) - 12usize];
    ["Offset of field: amdsmi_cpu_util_t::cpu_util_irq"]
        [::std::mem::offset_of!(amdsmi_cpu_util_t, cpu_util_irq) - 16usize];
};
#[doc = " @brief Link Metrics\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amdsmi_link_metrics_t {
    #[doc = "!< number of links"]
    pub num_links: u32,
    pub links: [amdsmi_link_metrics_t__links; 64usize],
    pub reserved: [u64; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amdsmi_link_metrics_t__links {
    #[doc = "!< bdf of the destination gpu"]
    pub bdf: amdsmi_bdf_t,
    #[doc = "!< current link speed in Gb/s"]
    pub bit_rate: u32,
    #[doc = "!< max bandwidth of the link in Gb/s"]
    pub max_bandwidth: u32,
    #[doc = "!< type of the link"]
    pub link_type: amdsmi_link_type_t,
    #[doc = "!< total data received for each link in KB"]
    pub read: u64,
    #[doc = "!< total data transfered for each link in KB"]
    pub write: u64,
    pub reserved: [u64; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_link_metrics_t__links"][::std::mem::size_of::<amdsmi_link_metrics_t__links>() - 48usize];
    ["Alignment of amdsmi_link_metrics_t__links"][::std::mem::align_of::<amdsmi_link_metrics_t__links>() - 8usize];
    ["Offset of field: amdsmi_link_metrics_t__links::bdf"]
        [::std::mem::offset_of!(amdsmi_link_metrics_t__links, bdf) - 0usize];
    ["Offset of field: amdsmi_link_metrics_t__links::bit_rate"]
        [::std::mem::offset_of!(amdsmi_link_metrics_t__links, bit_rate) - 8usize];
    ["Offset of field: amdsmi_link_metrics_t__links::max_bandwidth"]
        [::std::mem::offset_of!(amdsmi_link_metrics_t__links, max_bandwidth) - 12usize];
    ["Offset of field: amdsmi_link_metrics_t__links::link_type"]
        [::std::mem::offset_of!(amdsmi_link_metrics_t__links, link_type) - 16usize];
    ["Offset of field: amdsmi_link_metrics_t__links::read"]
        [::std::mem::offset_of!(amdsmi_link_metrics_t__links, read) - 24usize];
    ["Offset of field: amdsmi_link_metrics_t__links::write"]
        [::std::mem::offset_of!(amdsmi_link_metrics_t__links, write) - 32usize];
    ["Offset of field: amdsmi_link_metrics_t__links::reserved"]
        [::std::mem::offset_of!(amdsmi_link_metrics_t__links, reserved) - 40usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_link_metrics_t"][::std::mem::size_of::<amdsmi_link_metrics_t>() - 3136usize];
    ["Alignment of amdsmi_link_metrics_t"][::std::mem::align_of::<amdsmi_link_metrics_t>() - 8usize];
    ["Offset of field: amdsmi_link_metrics_t::num_links"]
        [::std::mem::offset_of!(amdsmi_link_metrics_t, num_links) - 0usize];
    ["Offset of field: amdsmi_link_metrics_t::links"][::std::mem::offset_of!(amdsmi_link_metrics_t, links) - 8usize];
    ["Offset of field: amdsmi_link_metrics_t::reserved"]
        [::std::mem::offset_of!(amdsmi_link_metrics_t, reserved) - 3080usize];
};
#[doc = " @brief VRam Information\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_vram_info_t {
    pub vram_type: amdsmi_vram_type_t,
    pub vram_vendor: [::std::os::raw::c_char; 256usize],
    #[doc = "!< vram size in MB"]
    pub vram_size: u64,
    #[doc = "!< In bits"]
    pub vram_bit_width: u32,
    #[doc = "!< The VRAM max bandwidth at current memory clock (GB/s)"]
    pub vram_max_bandwidth: u64,
    pub reserved: [u64; 37usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_vram_info_t"][::std::mem::size_of::<amdsmi_vram_info_t>() - 584usize];
    ["Alignment of amdsmi_vram_info_t"][::std::mem::align_of::<amdsmi_vram_info_t>() - 8usize];
    ["Offset of field: amdsmi_vram_info_t::vram_type"][::std::mem::offset_of!(amdsmi_vram_info_t, vram_type) - 0usize];
    ["Offset of field: amdsmi_vram_info_t::vram_vendor"]
        [::std::mem::offset_of!(amdsmi_vram_info_t, vram_vendor) - 4usize];
    ["Offset of field: amdsmi_vram_info_t::vram_size"]
        [::std::mem::offset_of!(amdsmi_vram_info_t, vram_size) - 264usize];
    ["Offset of field: amdsmi_vram_info_t::vram_bit_width"]
        [::std::mem::offset_of!(amdsmi_vram_info_t, vram_bit_width) - 272usize];
    ["Offset of field: amdsmi_vram_info_t::vram_max_bandwidth"]
        [::std::mem::offset_of!(amdsmi_vram_info_t, vram_max_bandwidth) - 280usize];
    ["Offset of field: amdsmi_vram_info_t::reserved"][::std::mem::offset_of!(amdsmi_vram_info_t, reserved) - 288usize];
};
#[doc = " @brief Driver Information\n\n @cond @tag{gpu_bm_linux} @tag{guest_windows} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_driver_info_t {
    pub driver_version: [::std::os::raw::c_char; 256usize],
    pub driver_date: [::std::os::raw::c_char; 256usize],
    pub driver_name: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_driver_info_t"][::std::mem::size_of::<amdsmi_driver_info_t>() - 768usize];
    ["Alignment of amdsmi_driver_info_t"][::std::mem::align_of::<amdsmi_driver_info_t>() - 1usize];
    ["Offset of field: amdsmi_driver_info_t::driver_version"]
        [::std::mem::offset_of!(amdsmi_driver_info_t, driver_version) - 0usize];
    ["Offset of field: amdsmi_driver_info_t::driver_date"]
        [::std::mem::offset_of!(amdsmi_driver_info_t, driver_date) - 256usize];
    ["Offset of field: amdsmi_driver_info_t::driver_name"]
        [::std::mem::offset_of!(amdsmi_driver_info_t, driver_name) - 512usize];
};
#[doc = " @brief Board Information\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_board_info_t {
    pub model_number: [::std::os::raw::c_char; 256usize],
    pub product_serial: [::std::os::raw::c_char; 256usize],
    pub fru_id: [::std::os::raw::c_char; 256usize],
    pub product_name: [::std::os::raw::c_char; 256usize],
    pub manufacturer_name: [::std::os::raw::c_char; 256usize],
    pub reserved: [u64; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_board_info_t"][::std::mem::size_of::<amdsmi_board_info_t>() - 1792usize];
    ["Alignment of amdsmi_board_info_t"][::std::mem::align_of::<amdsmi_board_info_t>() - 8usize];
    ["Offset of field: amdsmi_board_info_t::model_number"]
        [::std::mem::offset_of!(amdsmi_board_info_t, model_number) - 0usize];
    ["Offset of field: amdsmi_board_info_t::product_serial"]
        [::std::mem::offset_of!(amdsmi_board_info_t, product_serial) - 256usize];
    ["Offset of field: amdsmi_board_info_t::fru_id"][::std::mem::offset_of!(amdsmi_board_info_t, fru_id) - 512usize];
    ["Offset of field: amdsmi_board_info_t::product_name"]
        [::std::mem::offset_of!(amdsmi_board_info_t, product_name) - 768usize];
    ["Offset of field: amdsmi_board_info_t::manufacturer_name"]
        [::std::mem::offset_of!(amdsmi_board_info_t, manufacturer_name) - 1024usize];
    ["Offset of field: amdsmi_board_info_t::reserved"]
        [::std::mem::offset_of!(amdsmi_board_info_t, reserved) - 1280usize];
};
#[doc = " @brief Power Information\n\n Unsupported struct members are set to UINT32_MAX\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_power_info_t {
    #[doc = "!< Socket power in W"]
    pub socket_power: u64,
    #[doc = "!< Current socket power in W, Mi 300+ Series cards"]
    pub current_socket_power: u32,
    #[doc = "!< Average socket power in W, Navi + Mi 200 and earlier Series cards"]
    pub average_socket_power: u32,
    #[doc = "!< GFX voltage measurement in mV"]
    pub gfx_voltage: u64,
    #[doc = "!< SOC voltage measurement in mV"]
    pub soc_voltage: u64,
    #[doc = "!< MEM voltage measurement in mV"]
    pub mem_voltage: u64,
    #[doc = "!< The power limit in W"]
    pub power_limit: u32,
    pub reserved: [u64; 18usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_power_info_t"][::std::mem::size_of::<amdsmi_power_info_t>() - 192usize];
    ["Alignment of amdsmi_power_info_t"][::std::mem::align_of::<amdsmi_power_info_t>() - 8usize];
    ["Offset of field: amdsmi_power_info_t::socket_power"]
        [::std::mem::offset_of!(amdsmi_power_info_t, socket_power) - 0usize];
    ["Offset of field: amdsmi_power_info_t::current_socket_power"]
        [::std::mem::offset_of!(amdsmi_power_info_t, current_socket_power) - 8usize];
    ["Offset of field: amdsmi_power_info_t::average_socket_power"]
        [::std::mem::offset_of!(amdsmi_power_info_t, average_socket_power) - 12usize];
    ["Offset of field: amdsmi_power_info_t::gfx_voltage"]
        [::std::mem::offset_of!(amdsmi_power_info_t, gfx_voltage) - 16usize];
    ["Offset of field: amdsmi_power_info_t::soc_voltage"]
        [::std::mem::offset_of!(amdsmi_power_info_t, soc_voltage) - 24usize];
    ["Offset of field: amdsmi_power_info_t::mem_voltage"]
        [::std::mem::offset_of!(amdsmi_power_info_t, mem_voltage) - 32usize];
    ["Offset of field: amdsmi_power_info_t::power_limit"]
        [::std::mem::offset_of!(amdsmi_power_info_t, power_limit) - 40usize];
    ["Offset of field: amdsmi_power_info_t::reserved"][::std::mem::offset_of!(amdsmi_power_info_t, reserved) - 48usize];
};
#[doc = " @brief Clock Information\n\n @cond @tag{gpu_bm_linux} @tag{guest_windows} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_clk_info_t {
    #[doc = "!< In MHz"]
    pub clk: u32,
    #[doc = "!< In MHz"]
    pub min_clk: u32,
    #[doc = "!< In MHz"]
    pub max_clk: u32,
    #[doc = "!< True/False"]
    pub clk_locked: u8,
    #[doc = "!< True/False"]
    pub clk_deep_sleep: u8,
    pub reserved: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_clk_info_t"][::std::mem::size_of::<amdsmi_clk_info_t>() - 32usize];
    ["Alignment of amdsmi_clk_info_t"][::std::mem::align_of::<amdsmi_clk_info_t>() - 4usize];
    ["Offset of field: amdsmi_clk_info_t::clk"][::std::mem::offset_of!(amdsmi_clk_info_t, clk) - 0usize];
    ["Offset of field: amdsmi_clk_info_t::min_clk"][::std::mem::offset_of!(amdsmi_clk_info_t, min_clk) - 4usize];
    ["Offset of field: amdsmi_clk_info_t::max_clk"][::std::mem::offset_of!(amdsmi_clk_info_t, max_clk) - 8usize];
    ["Offset of field: amdsmi_clk_info_t::clk_locked"][::std::mem::offset_of!(amdsmi_clk_info_t, clk_locked) - 12usize];
    ["Offset of field: amdsmi_clk_info_t::clk_deep_sleep"]
        [::std::mem::offset_of!(amdsmi_clk_info_t, clk_deep_sleep) - 13usize];
    ["Offset of field: amdsmi_clk_info_t::reserved"][::std::mem::offset_of!(amdsmi_clk_info_t, reserved) - 16usize];
};
#[doc = " @brief Engine Usage\n amdsmi_engine_usage_t:\n This structure holds common\n GPU activity values seen in both BM or\n SRIOV\n\n @cond @tag{gpu_bm_linux} @tag{guest_windows} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_engine_usage_t {
    #[doc = "!< In %"]
    pub gfx_activity: u32,
    #[doc = "!< In %"]
    pub umc_activity: u32,
    #[doc = "!< In %"]
    pub mm_activity: u32,
    pub reserved: [u32; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_engine_usage_t"][::std::mem::size_of::<amdsmi_engine_usage_t>() - 64usize];
    ["Alignment of amdsmi_engine_usage_t"][::std::mem::align_of::<amdsmi_engine_usage_t>() - 4usize];
    ["Offset of field: amdsmi_engine_usage_t::gfx_activity"]
        [::std::mem::offset_of!(amdsmi_engine_usage_t, gfx_activity) - 0usize];
    ["Offset of field: amdsmi_engine_usage_t::umc_activity"]
        [::std::mem::offset_of!(amdsmi_engine_usage_t, umc_activity) - 4usize];
    ["Offset of field: amdsmi_engine_usage_t::mm_activity"]
        [::std::mem::offset_of!(amdsmi_engine_usage_t, mm_activity) - 8usize];
    ["Offset of field: amdsmi_engine_usage_t::reserved"]
        [::std::mem::offset_of!(amdsmi_engine_usage_t, reserved) - 12usize];
};
#[doc = " @brief Process Handle\n\n @cond @tag{gpu_bm_linux} @tag{guest_windows} @endcond"]
pub type amdsmi_process_handle_t = u32;
#[doc = " @brief Process Information\n\n @cond @tag{gpu_bm_linux} @tag{guest_windows} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_proc_info_t {
    pub name: [::std::os::raw::c_char; 256usize],
    pub pid: amdsmi_process_handle_t,
    #[doc = "!< In Bytes"]
    pub mem: u64,
    #[doc = "!< time the process spends using these engines in ns"]
    pub engine_usage: amdsmi_proc_info_t_engine_usage_,
    #[doc = "!< In Bytes"]
    pub memory_usage: amdsmi_proc_info_t_memory_usage_,
    pub container_name: [::std::os::raw::c_char; 256usize],
    #[doc = "!< Num CUs utilized"]
    pub cu_occupancy: u32,
    #[doc = "!< Time that queues are evicted on a GPU in milliseconds"]
    pub evicted_time: u32,
    pub reserved: [u32; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_proc_info_t_engine_usage_ {
    #[doc = "!< In nano-secs"]
    pub gfx: u64,
    #[doc = "!< In nano-secs"]
    pub enc: u64,
    pub reserved: [u32; 12usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_proc_info_t_engine_usage_"][::std::mem::size_of::<amdsmi_proc_info_t_engine_usage_>() - 64usize];
    ["Alignment of amdsmi_proc_info_t_engine_usage_"]
        [::std::mem::align_of::<amdsmi_proc_info_t_engine_usage_>() - 8usize];
    ["Offset of field: amdsmi_proc_info_t_engine_usage_::gfx"]
        [::std::mem::offset_of!(amdsmi_proc_info_t_engine_usage_, gfx) - 0usize];
    ["Offset of field: amdsmi_proc_info_t_engine_usage_::enc"]
        [::std::mem::offset_of!(amdsmi_proc_info_t_engine_usage_, enc) - 8usize];
    ["Offset of field: amdsmi_proc_info_t_engine_usage_::reserved"]
        [::std::mem::offset_of!(amdsmi_proc_info_t_engine_usage_, reserved) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_proc_info_t_memory_usage_ {
    #[doc = "!< In Bytes"]
    pub gtt_mem: u64,
    #[doc = "!< In Bytes"]
    pub cpu_mem: u64,
    #[doc = "!< In Bytes"]
    pub vram_mem: u64,
    pub reserved: [u32; 10usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_proc_info_t_memory_usage_"][::std::mem::size_of::<amdsmi_proc_info_t_memory_usage_>() - 64usize];
    ["Alignment of amdsmi_proc_info_t_memory_usage_"]
        [::std::mem::align_of::<amdsmi_proc_info_t_memory_usage_>() - 8usize];
    ["Offset of field: amdsmi_proc_info_t_memory_usage_::gtt_mem"]
        [::std::mem::offset_of!(amdsmi_proc_info_t_memory_usage_, gtt_mem) - 0usize];
    ["Offset of field: amdsmi_proc_info_t_memory_usage_::cpu_mem"]
        [::std::mem::offset_of!(amdsmi_proc_info_t_memory_usage_, cpu_mem) - 8usize];
    ["Offset of field: amdsmi_proc_info_t_memory_usage_::vram_mem"]
        [::std::mem::offset_of!(amdsmi_proc_info_t_memory_usage_, vram_mem) - 16usize];
    ["Offset of field: amdsmi_proc_info_t_memory_usage_::reserved"]
        [::std::mem::offset_of!(amdsmi_proc_info_t_memory_usage_, reserved) - 24usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_proc_info_t"][::std::mem::size_of::<amdsmi_proc_info_t>() - 704usize];
    ["Alignment of amdsmi_proc_info_t"][::std::mem::align_of::<amdsmi_proc_info_t>() - 8usize];
    ["Offset of field: amdsmi_proc_info_t::name"][::std::mem::offset_of!(amdsmi_proc_info_t, name) - 0usize];
    ["Offset of field: amdsmi_proc_info_t::pid"][::std::mem::offset_of!(amdsmi_proc_info_t, pid) - 256usize];
    ["Offset of field: amdsmi_proc_info_t::mem"][::std::mem::offset_of!(amdsmi_proc_info_t, mem) - 264usize];
    ["Offset of field: amdsmi_proc_info_t::engine_usage"]
        [::std::mem::offset_of!(amdsmi_proc_info_t, engine_usage) - 272usize];
    ["Offset of field: amdsmi_proc_info_t::memory_usage"]
        [::std::mem::offset_of!(amdsmi_proc_info_t, memory_usage) - 336usize];
    ["Offset of field: amdsmi_proc_info_t::container_name"]
        [::std::mem::offset_of!(amdsmi_proc_info_t, container_name) - 400usize];
    ["Offset of field: amdsmi_proc_info_t::cu_occupancy"]
        [::std::mem::offset_of!(amdsmi_proc_info_t, cu_occupancy) - 656usize];
    ["Offset of field: amdsmi_proc_info_t::evicted_time"]
        [::std::mem::offset_of!(amdsmi_proc_info_t, evicted_time) - 660usize];
    ["Offset of field: amdsmi_proc_info_t::reserved"][::std::mem::offset_of!(amdsmi_proc_info_t, reserved) - 664usize];
};
#[doc = " @brief IO Link P2P Capability\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_p2p_capability_t {
    #[doc = "!< 1 = true, 0 = false, UINT8_MAX = Not defined"]
    pub is_iolink_coherent: u8,
    #[doc = "!< 1 = true, 0 = false, UINT8_MAX = Not defined"]
    pub is_iolink_atomics_32bit: u8,
    #[doc = "!< 1 = true, 0 = false, UINT8_MAX = Not defined"]
    pub is_iolink_atomics_64bit: u8,
    #[doc = "!< 1 = true, 0 = false, UINT8_MAX = Not defined"]
    pub is_iolink_dma: u8,
    #[doc = "!< 1 = true, 0 = false, UINT8_MAX = Not defined"]
    pub is_iolink_bi_directional: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_p2p_capability_t"][::std::mem::size_of::<amdsmi_p2p_capability_t>() - 5usize];
    ["Alignment of amdsmi_p2p_capability_t"][::std::mem::align_of::<amdsmi_p2p_capability_t>() - 1usize];
    ["Offset of field: amdsmi_p2p_capability_t::is_iolink_coherent"]
        [::std::mem::offset_of!(amdsmi_p2p_capability_t, is_iolink_coherent) - 0usize];
    ["Offset of field: amdsmi_p2p_capability_t::is_iolink_atomics_32bit"]
        [::std::mem::offset_of!(amdsmi_p2p_capability_t, is_iolink_atomics_32bit) - 1usize];
    ["Offset of field: amdsmi_p2p_capability_t::is_iolink_atomics_64bit"]
        [::std::mem::offset_of!(amdsmi_p2p_capability_t, is_iolink_atomics_64bit) - 2usize];
    ["Offset of field: amdsmi_p2p_capability_t::is_iolink_dma"]
        [::std::mem::offset_of!(amdsmi_p2p_capability_t, is_iolink_dma) - 3usize];
    ["Offset of field: amdsmi_p2p_capability_t::is_iolink_bi_directional"]
        [::std::mem::offset_of!(amdsmi_p2p_capability_t, is_iolink_bi_directional) - 4usize];
};
#[doc = "!< Performance level is \"auto\""]
pub const amdsmi_dev_perf_level_t_AMDSMI_DEV_PERF_LEVEL_AUTO: amdsmi_dev_perf_level_t = 0;
pub const amdsmi_dev_perf_level_t_AMDSMI_DEV_PERF_LEVEL_FIRST: amdsmi_dev_perf_level_t = 0;
#[doc = "!< Keep PowerPlay levels \"low\", regardless of workload"]
pub const amdsmi_dev_perf_level_t_AMDSMI_DEV_PERF_LEVEL_LOW: amdsmi_dev_perf_level_t = 1;
#[doc = "!< Keep PowerPlay levels \"high\", regardless of workload"]
pub const amdsmi_dev_perf_level_t_AMDSMI_DEV_PERF_LEVEL_HIGH: amdsmi_dev_perf_level_t = 2;
#[doc = "< Only use values defined by manually\nsetting the AMDSMI_CLK_TYPE_SYS speed"]
pub const amdsmi_dev_perf_level_t_AMDSMI_DEV_PERF_LEVEL_MANUAL: amdsmi_dev_perf_level_t = 3;
#[doc = "!< Stable power state with profiling clocks"]
pub const amdsmi_dev_perf_level_t_AMDSMI_DEV_PERF_LEVEL_STABLE_STD: amdsmi_dev_perf_level_t = 4;
#[doc = "!< Stable power state with peak clocks"]
pub const amdsmi_dev_perf_level_t_AMDSMI_DEV_PERF_LEVEL_STABLE_PEAK: amdsmi_dev_perf_level_t = 5;
#[doc = "!< Stable power state with minimum memory clock"]
pub const amdsmi_dev_perf_level_t_AMDSMI_DEV_PERF_LEVEL_STABLE_MIN_MCLK: amdsmi_dev_perf_level_t = 6;
#[doc = "!< Stable power state with minimum system clock"]
pub const amdsmi_dev_perf_level_t_AMDSMI_DEV_PERF_LEVEL_STABLE_MIN_SCLK: amdsmi_dev_perf_level_t = 7;
#[doc = "!< Performance determinism state"]
pub const amdsmi_dev_perf_level_t_AMDSMI_DEV_PERF_LEVEL_DETERMINISM: amdsmi_dev_perf_level_t = 8;
pub const amdsmi_dev_perf_level_t_AMDSMI_DEV_PERF_LEVEL_LAST: amdsmi_dev_perf_level_t = 8;
#[doc = "!< Unknown performance level"]
pub const amdsmi_dev_perf_level_t_AMDSMI_DEV_PERF_LEVEL_UNKNOWN: amdsmi_dev_perf_level_t = 256;
#[doc = " @brief PowerPlay performance levels\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_dev_perf_level_t = ::std::os::raw::c_uint;
#[doc = " @brief Handle to performance event counter\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_event_handle_t = usize;
#[doc = "!< Data Fabric (XGMI) related events"]
pub const amdsmi_event_group_t_AMDSMI_EVNT_GRP_XGMI: amdsmi_event_group_t = 0;
#[doc = "!< XGMI Outbound data"]
pub const amdsmi_event_group_t_AMDSMI_EVNT_GRP_XGMI_DATA_OUT: amdsmi_event_group_t = 10;
#[doc = "!< Unknown Event Group"]
pub const amdsmi_event_group_t_AMDSMI_EVNT_GRP_INVALID: amdsmi_event_group_t = 4294967295;
#[doc = " @brief Event Groups\n Enum denoting an event group. The value of the enum is the\n base value for all the event enums in the group.\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_event_group_t = ::std::os::raw::c_uint;
pub const amdsmi_event_type_t_AMDSMI_EVNT_FIRST: amdsmi_event_type_t = 0;
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_FIRST: amdsmi_event_type_t = 0;
#[doc = "!< NOPs sent to neighbor 0"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_0_NOP_TX: amdsmi_event_type_t = 0;
#[doc = "!< Outgoing requests to neighbor 0"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_0_REQUEST_TX: amdsmi_event_type_t = 1;
#[doc = "!< Outgoing responses to neighbor 0"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_0_RESPONSE_TX: amdsmi_event_type_t = 2;
#[doc = "!< Throughput = BEATS/time_running 10^9 bytes/sec"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_0_BEATS_TX: amdsmi_event_type_t = 3;
#[doc = "!< NOPs sent to neighbor 1"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_1_NOP_TX: amdsmi_event_type_t = 4;
#[doc = "!< Outgoing requests to neighbor 1"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_1_REQUEST_TX: amdsmi_event_type_t = 5;
#[doc = "!< Outgoing responses to neighbor 1"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_1_RESPONSE_TX: amdsmi_event_type_t = 6;
#[doc = "!< Data beats sent to neighbor 1; Each beat represents 32 bytes"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_1_BEATS_TX: amdsmi_event_type_t = 7;
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_LAST: amdsmi_event_type_t = 7;
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_DATA_OUT_FIRST: amdsmi_event_type_t = 10;
#[doc = "!< Outbound beats to neighbor 0"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_DATA_OUT_0: amdsmi_event_type_t = 10;
#[doc = "!< Outbound beats to neighbor 1"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_DATA_OUT_1: amdsmi_event_type_t = 11;
#[doc = "!< Outbound beats to neighbor 2"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_DATA_OUT_2: amdsmi_event_type_t = 12;
#[doc = "!< Outbound beats to neighbor 3"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_DATA_OUT_3: amdsmi_event_type_t = 13;
#[doc = "!< Outbound beats to neighbor 4"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_DATA_OUT_4: amdsmi_event_type_t = 14;
#[doc = "!< Outbound beats to neighbor 5"]
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_DATA_OUT_5: amdsmi_event_type_t = 15;
pub const amdsmi_event_type_t_AMDSMI_EVNT_XGMI_DATA_OUT_LAST: amdsmi_event_type_t = 15;
pub const amdsmi_event_type_t_AMDSMI_EVNT_LAST: amdsmi_event_type_t = 15;
#[doc = " @brief Event types\n Event type enum. Events belonging to a particular event group\n ::amdsmi_event_group_t should begin enumerating at the ::amdsmi_event_group_t\n value for that group.\n\n Data beats sent to neighbor 0; Each beat represents 32 bytes.<br><br>\n\n XGMI throughput can be calculated by multiplying a BEATs event\n such as ::AMDSMI_EVNT_XGMI_0_BEATS_TX by 32 and dividing by\n the time for which event collection occurred,\n ::amdsmi_counter_value_t.time_running (which is in nanoseconds). To get\n bytes per second, multiply this value by 10<sup>9</sup>.<br>\n <br>\n Throughput = BEATS/time_running * 10<sup>9</sup>  (bytes/second)<br>\n\n Events in the AMDSMI_EVNT_GRP_XGMI_DATA_OUT group measure\n the number of beats sent on an XGMI link. Each beat represents\n 32 bytes. AMDSMI_EVNT_XGMI_DATA_OUT_n represents the number of\n outbound beats (each representing 32 bytes) on link n.<br><br>\n\n XGMI throughput can be calculated by multiplying a event\n such as ::AMDSMI_EVNT_XGMI_DATA_OUT_n by 32 and dividing by\n the time for which event collection occurred,\n ::amdsmi_counter_value_t.time_running (which is in nanoseconds). To get\n bytes per second, multiply this value by 10<sup>9</sup>.<br>\n <br>\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_event_type_t = ::std::os::raw::c_uint;
#[doc = "!< Start the counter"]
pub const amdsmi_counter_command_t_AMDSMI_CNTR_CMD_START: amdsmi_counter_command_t = 0;
#[doc = "< Stop the counter; note that this should not\nbe used before reading"]
pub const amdsmi_counter_command_t_AMDSMI_CNTR_CMD_STOP: amdsmi_counter_command_t = 1;
#[doc = " @brief Event counter commands\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_counter_command_t = ::std::os::raw::c_uint;
#[doc = " @brief Counter value\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_counter_value_t {
    #[doc = "!< Counter value"]
    pub value: u64,
    #[doc = "!< Time that the counter was enabled in nanoseconds"]
    pub time_enabled: u64,
    #[doc = "!< Time that the counter was running in nanoseconds"]
    pub time_running: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_counter_value_t"][::std::mem::size_of::<amdsmi_counter_value_t>() - 24usize];
    ["Alignment of amdsmi_counter_value_t"][::std::mem::align_of::<amdsmi_counter_value_t>() - 8usize];
    ["Offset of field: amdsmi_counter_value_t::value"][::std::mem::offset_of!(amdsmi_counter_value_t, value) - 0usize];
    ["Offset of field: amdsmi_counter_value_t::time_enabled"]
        [::std::mem::offset_of!(amdsmi_counter_value_t, time_enabled) - 8usize];
    ["Offset of field: amdsmi_counter_value_t::time_running"]
        [::std::mem::offset_of!(amdsmi_counter_value_t, time_running) - 16usize];
};
#[doc = "!< No events"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_NONE: amdsmi_evt_notification_type_t = 0;
#[doc = "!< Virtual Memory Page Fault Event"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_VMFAULT: amdsmi_evt_notification_type_t = 1;
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_FIRST: amdsmi_evt_notification_type_t = 1;
#[doc = "!< thermal throttle"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_THERMAL_THROTTLE: amdsmi_evt_notification_type_t = 2;
#[doc = "!< pre-reset"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_GPU_PRE_RESET: amdsmi_evt_notification_type_t = 3;
#[doc = "!< post-reset"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_GPU_POST_RESET: amdsmi_evt_notification_type_t = 4;
#[doc = "!< migrate start"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_MIGRATE_START: amdsmi_evt_notification_type_t = 5;
#[doc = "!< migrate end"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_MIGRATE_END: amdsmi_evt_notification_type_t = 6;
#[doc = "!< page fault start"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_PAGE_FAULT_START: amdsmi_evt_notification_type_t = 7;
#[doc = "!< page fault end"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_PAGE_FAULT_END: amdsmi_evt_notification_type_t = 8;
#[doc = "!< queue eviction"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_QUEUE_EVICTION: amdsmi_evt_notification_type_t = 9;
#[doc = "!< queue restore"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_QUEUE_RESTORE: amdsmi_evt_notification_type_t = 10;
#[doc = "!< unmap from GPU"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_UNMAP_FROM_GPU: amdsmi_evt_notification_type_t = 11;
#[doc = "!< KFD process start"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_PROCESS_START: amdsmi_evt_notification_type_t = 12;
#[doc = "!< KFD process end"]
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_PROCESS_END: amdsmi_evt_notification_type_t = 13;
pub const amdsmi_evt_notification_type_t_AMDSMI_EVT_NOTIF_LAST: amdsmi_evt_notification_type_t = 13;
#[doc = " @brief Event notification event types\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_evt_notification_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Event notification data returned from event notification API\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_evt_notification_data_t {
    #[doc = "!< Handler of device that corresponds to the event"]
    pub processor_handle: amdsmi_processor_handle,
    #[doc = "!< Event type"]
    pub event: amdsmi_evt_notification_type_t,
    #[doc = "!< Event message"]
    pub message: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_evt_notification_data_t"][::std::mem::size_of::<amdsmi_evt_notification_data_t>() - 272usize];
    ["Alignment of amdsmi_evt_notification_data_t"][::std::mem::align_of::<amdsmi_evt_notification_data_t>() - 8usize];
    ["Offset of field: amdsmi_evt_notification_data_t::processor_handle"]
        [::std::mem::offset_of!(amdsmi_evt_notification_data_t, processor_handle) - 0usize];
    ["Offset of field: amdsmi_evt_notification_data_t::event"]
        [::std::mem::offset_of!(amdsmi_evt_notification_data_t, event) - 8usize];
    ["Offset of field: amdsmi_evt_notification_data_t::message"]
        [::std::mem::offset_of!(amdsmi_evt_notification_data_t, message) - 12usize];
};
#[doc = "!< Current temperature"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_CURRENT: amdsmi_temperature_metric_t = 0;
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_FIRST: amdsmi_temperature_metric_t = 0;
#[doc = "!< Max temperature"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_MAX: amdsmi_temperature_metric_t = 1;
#[doc = "!< Min temperature"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_MIN: amdsmi_temperature_metric_t = 2;
#[doc = "< Max limit hysteresis temperature\n(Absolute temperature, not a delta)"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_MAX_HYST: amdsmi_temperature_metric_t = 3;
#[doc = "< Min limit hysteresis temperature\n(Absolute temperature, not a delta)"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_MIN_HYST: amdsmi_temperature_metric_t = 4;
#[doc = "< Critical max limit temperature, typically\ngreater than max temperatures"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_CRITICAL: amdsmi_temperature_metric_t = 5;
#[doc = "< Critical hysteresis limit temperature\n(Absolute temperature, not a delta)"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_CRITICAL_HYST: amdsmi_temperature_metric_t = 6;
#[doc = "< Emergency max temperature, for chips\nsupporting more than two upper temperature\nlimits. Must be equal or greater than\ncorresponding temp_crit values"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_EMERGENCY: amdsmi_temperature_metric_t = 7;
#[doc = "< Emergency hysteresis limit temperature\n(Absolute temperature, not a delta)"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_EMERGENCY_HYST: amdsmi_temperature_metric_t = 8;
#[doc = "< Critical min temperature, typically\nlower than minimum temperatures"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_CRIT_MIN: amdsmi_temperature_metric_t = 9;
#[doc = "< Min Hysteresis critical limit temperature\n(Absolute temperature, not a delta)"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_CRIT_MIN_HYST: amdsmi_temperature_metric_t = 10;
#[doc = "< Temperature offset which is added to the\ntemperature reading by the chip"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_OFFSET: amdsmi_temperature_metric_t = 11;
#[doc = "!< Historical min temperature"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_LOWEST: amdsmi_temperature_metric_t = 12;
#[doc = "!< Historical max temperature"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_HIGHEST: amdsmi_temperature_metric_t = 13;
#[doc = "!< Shutdown temperature"]
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_SHUTDOWN: amdsmi_temperature_metric_t = 14;
pub const amdsmi_temperature_metric_t_AMDSMI_TEMP_LAST: amdsmi_temperature_metric_t = 14;
#[doc = " @brief Temperature Metrics. This enum is used to identify various\n temperature metrics. Corresponding values will be in Celcius\n\n @cond @tag{gpu_bm_linux} @tag{host} @tag{guest_windows} @endcond"]
pub type amdsmi_temperature_metric_t = ::std::os::raw::c_uint;
#[doc = "!< Voltage current value."]
pub const amdsmi_voltage_metric_t_AMDSMI_VOLT_CURRENT: amdsmi_voltage_metric_t = 0;
pub const amdsmi_voltage_metric_t_AMDSMI_VOLT_FIRST: amdsmi_voltage_metric_t = 0;
#[doc = "!< Voltage max value."]
pub const amdsmi_voltage_metric_t_AMDSMI_VOLT_MAX: amdsmi_voltage_metric_t = 1;
#[doc = "!< Voltage critical min value."]
pub const amdsmi_voltage_metric_t_AMDSMI_VOLT_MIN_CRIT: amdsmi_voltage_metric_t = 2;
#[doc = "!< Voltage min value."]
pub const amdsmi_voltage_metric_t_AMDSMI_VOLT_MIN: amdsmi_voltage_metric_t = 3;
#[doc = "!< Voltage critical max value."]
pub const amdsmi_voltage_metric_t_AMDSMI_VOLT_MAX_CRIT: amdsmi_voltage_metric_t = 4;
#[doc = "!< Average voltage."]
pub const amdsmi_voltage_metric_t_AMDSMI_VOLT_AVERAGE: amdsmi_voltage_metric_t = 5;
#[doc = "!< Historical minimum voltage."]
pub const amdsmi_voltage_metric_t_AMDSMI_VOLT_LOWEST: amdsmi_voltage_metric_t = 6;
#[doc = "!< Historical maximum voltage."]
pub const amdsmi_voltage_metric_t_AMDSMI_VOLT_HIGHEST: amdsmi_voltage_metric_t = 7;
pub const amdsmi_voltage_metric_t_AMDSMI_VOLT_LAST: amdsmi_voltage_metric_t = 7;
#[doc = " @brief Voltage Metrics.  This enum is used to identify various\n Volatge metrics. Corresponding values will be in millivolt.\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_voltage_metric_t = ::std::os::raw::c_uint;
pub const amdsmi_voltage_type_t_AMDSMI_VOLT_TYPE_FIRST: amdsmi_voltage_type_t = 0;
#[doc = "!< Vddgfx GPU voltage"]
pub const amdsmi_voltage_type_t_AMDSMI_VOLT_TYPE_VDDGFX: amdsmi_voltage_type_t = 0;
#[doc = "!< Voltage for VDDBOARD"]
pub const amdsmi_voltage_type_t_AMDSMI_VOLT_TYPE_VDDBOARD: amdsmi_voltage_type_t = 1;
pub const amdsmi_voltage_type_t_AMDSMI_VOLT_TYPE_LAST: amdsmi_voltage_type_t = 1;
#[doc = "!< Invalid type"]
pub const amdsmi_voltage_type_t_AMDSMI_VOLT_TYPE_INVALID: amdsmi_voltage_type_t = 4294967295;
#[doc = " @brief This ennumeration is used to indicate which type of\n voltage reading should be obtained.\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_voltage_type_t = ::std::os::raw::c_uint;
#[doc = "!< Custom Power Profile"]
pub const amdsmi_power_profile_preset_masks_t_AMDSMI_PWR_PROF_PRST_CUSTOM_MASK: amdsmi_power_profile_preset_masks_t = 1;
#[doc = "!< Video Power Profile"]
pub const amdsmi_power_profile_preset_masks_t_AMDSMI_PWR_PROF_PRST_VIDEO_MASK: amdsmi_power_profile_preset_masks_t = 2;
#[doc = "!< Power Saving Profile"]
pub const amdsmi_power_profile_preset_masks_t_AMDSMI_PWR_PROF_PRST_POWER_SAVING_MASK:
    amdsmi_power_profile_preset_masks_t = 4;
#[doc = "!< Compute Saving Profile"]
pub const amdsmi_power_profile_preset_masks_t_AMDSMI_PWR_PROF_PRST_COMPUTE_MASK: amdsmi_power_profile_preset_masks_t =
    8;
#[doc = "!< VR Power Profile"]
pub const amdsmi_power_profile_preset_masks_t_AMDSMI_PWR_PROF_PRST_VR_MASK: amdsmi_power_profile_preset_masks_t = 16;
#[doc = "!< 3D Full Screen Profile"]
pub const amdsmi_power_profile_preset_masks_t_AMDSMI_PWR_PROF_PRST_3D_FULL_SCR_MASK:
    amdsmi_power_profile_preset_masks_t = 32;
#[doc = "!< Default Boot Up Profile"]
pub const amdsmi_power_profile_preset_masks_t_AMDSMI_PWR_PROF_PRST_BOOTUP_DEFAULT: amdsmi_power_profile_preset_masks_t =
    64;
pub const amdsmi_power_profile_preset_masks_t_AMDSMI_PWR_PROF_PRST_LAST: amdsmi_power_profile_preset_masks_t = 64;
#[doc = "!< Invalid Power Profile"]
pub const amdsmi_power_profile_preset_masks_t_AMDSMI_PWR_PROF_PRST_INVALID: amdsmi_power_profile_preset_masks_t =
    18446744073709551615;
#[doc = " @brief Pre-set Profile Selections. These bitmasks can be AND'd with the\n ::amdsmi_power_profile_status_t.available_profiles returned from\n :: amdsmi_get_gpu_power_profile_presets to determine which power profiles\n are supported by the system.\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_power_profile_preset_masks_t = ::std::os::raw::c_ulong;
#[doc = "!< Invalid block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_INVALID: amdsmi_gpu_block_t = 0;
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_FIRST: amdsmi_gpu_block_t = 1;
#[doc = "!< UMC block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_UMC: amdsmi_gpu_block_t = 1;
#[doc = "!< SDMA block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_SDMA: amdsmi_gpu_block_t = 2;
#[doc = "!< GFX block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_GFX: amdsmi_gpu_block_t = 4;
#[doc = "!< MMHUB block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_MMHUB: amdsmi_gpu_block_t = 8;
#[doc = "!< ATHUB block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_ATHUB: amdsmi_gpu_block_t = 16;
#[doc = "!< PCIE_BIF block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_PCIE_BIF: amdsmi_gpu_block_t = 32;
#[doc = "!< HDP block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_HDP: amdsmi_gpu_block_t = 64;
#[doc = "!< XGMI block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_XGMI_WAFL: amdsmi_gpu_block_t = 128;
#[doc = "!< DF block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_DF: amdsmi_gpu_block_t = 256;
#[doc = "!< SMN block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_SMN: amdsmi_gpu_block_t = 512;
#[doc = "!< SEM block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_SEM: amdsmi_gpu_block_t = 1024;
#[doc = "!< MP0 block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_MP0: amdsmi_gpu_block_t = 2048;
#[doc = "!< MP1 block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_MP1: amdsmi_gpu_block_t = 4096;
#[doc = "!< Fuse block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_FUSE: amdsmi_gpu_block_t = 8192;
#[doc = "!< MCA block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_MCA: amdsmi_gpu_block_t = 16384;
#[doc = "!< VCN block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_VCN: amdsmi_gpu_block_t = 32768;
#[doc = "!< JPEG block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_JPEG: amdsmi_gpu_block_t = 65536;
#[doc = "!< IH block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_IH: amdsmi_gpu_block_t = 131072;
#[doc = "!< MPIO block"]
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_MPIO: amdsmi_gpu_block_t = 262144;
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_LAST: amdsmi_gpu_block_t = 262144;
pub const amdsmi_gpu_block_t_AMDSMI_GPU_BLOCK_RESERVED: amdsmi_gpu_block_t = 9223372036854775808;
#[doc = " @brief This enum is used to identify different GPU blocks.\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_gpu_block_t = ::std::os::raw::c_ulong;
#[doc = "!< Min Clock value in MHz"]
pub const amdsmi_clk_limit_type_t_CLK_LIMIT_MIN: amdsmi_clk_limit_type_t = 0;
#[doc = "!< Max Clock value in MHz"]
pub const amdsmi_clk_limit_type_t_CLK_LIMIT_MAX: amdsmi_clk_limit_type_t = 1;
#[doc = " @brief The clk limit type\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_clk_limit_type_t = ::std::os::raw::c_uint;
#[doc = "!< CPER Non-Fatal Uncorrected severity"]
pub const amdsmi_cper_sev_t_AMDSMI_CPER_SEV_NON_FATAL_UNCORRECTED: amdsmi_cper_sev_t = 0;
#[doc = "!< CPER Fatal severity"]
pub const amdsmi_cper_sev_t_AMDSMI_CPER_SEV_FATAL: amdsmi_cper_sev_t = 1;
#[doc = "!< CPER Non-Fatal Corrected severity"]
pub const amdsmi_cper_sev_t_AMDSMI_CPER_SEV_NON_FATAL_CORRECTED: amdsmi_cper_sev_t = 2;
#[doc = "!< CPER severity Number"]
pub const amdsmi_cper_sev_t_AMDSMI_CPER_SEV_NUM: amdsmi_cper_sev_t = 3;
#[doc = "!< CPER Unused severity"]
pub const amdsmi_cper_sev_t_AMDSMI_CPER_SEV_UNUSED: amdsmi_cper_sev_t = 10;
#[doc = " @brief Cper sev\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_cper_sev_t = ::std::os::raw::c_uint;
#[doc = "!< Corrected Memory Check"]
pub const amdsmi_cper_notify_type_t_AMDSMI_CPER_NOTIFY_TYPE_CMC: amdsmi_cper_notify_type_t = 4976123370175105969;
#[doc = "!< Corrected Platform Error"]
pub const amdsmi_cper_notify_type_t_AMDSMI_CPER_NOTIFY_TYPE_CPE: amdsmi_cper_notify_type_t = 5356425115412803478;
#[doc = "!< Machine Check Exception"]
pub const amdsmi_cper_notify_type_t_AMDSMI_CPER_NOTIFY_TYPE_MCE: amdsmi_cper_notify_type_t = 5531987820403847166;
#[doc = "!< PCI Express Error"]
pub const amdsmi_cper_notify_type_t_AMDSMI_CPER_NOTIFY_TYPE_PCIE: amdsmi_cper_notify_type_t = 5619395120325705759;
#[doc = "!< Initialization Error"]
pub const amdsmi_cper_notify_type_t_AMDSMI_CPER_NOTIFY_TYPE_INIT: amdsmi_cper_notify_type_t = 4992964802890589160;
#[doc = "!< Non_Maskable Interrupt"]
pub const amdsmi_cper_notify_type_t_AMDSMI_CPER_NOTIFY_TYPE_NMI: amdsmi_cper_notify_type_t = 4812579876830546431;
#[doc = "!< Boot Error"]
pub const amdsmi_cper_notify_type_t_AMDSMI_CPER_NOTIFY_TYPE_BOOT: amdsmi_cper_notify_type_t = 4655221457236894822;
#[doc = "!< Direct Memory Access Remapping Error"]
pub const amdsmi_cper_notify_type_t_AMDSMI_CPER_NOTIFY_TYPE_DMAR: amdsmi_cper_notify_type_t = 5487573144795207569;
#[doc = "!< System Error Architecture"]
pub const amdsmi_cper_notify_type_t_AMDSMI_CPER_NOTIFY_TYPE_SEA: amdsmi_cper_notify_type_t = 1289362001033197706;
#[doc = "!< System Error Interface"]
pub const amdsmi_cper_notify_type_t_AMDSMI_CPER_NOTIFY_TYPE_SEI: amdsmi_cper_notify_type_t = 5658685719731260545;
#[doc = "!< Platform Error Interface"]
pub const amdsmi_cper_notify_type_t_AMDSMI_CPER_NOTIFY_TYPE_PEI: amdsmi_cper_notify_type_t = 4761520883332928940;
#[doc = "!< Compute Express Link Component Error"]
pub const amdsmi_cper_notify_type_t_AMDSMI_CPER_NOTIFY_TYPE_CXL_COMPONENT: amdsmi_cper_notify_type_t =
    5306157213770398665;
#[doc = " @brief Cper notify\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_cper_notify_type_t = ::std::os::raw::c_ulong;
#[doc = "!< No current errors"]
pub const amdsmi_ras_err_state_t_AMDSMI_RAS_ERR_STATE_NONE: amdsmi_ras_err_state_t = 0;
#[doc = "!< ECC is disabled"]
pub const amdsmi_ras_err_state_t_AMDSMI_RAS_ERR_STATE_DISABLED: amdsmi_ras_err_state_t = 1;
#[doc = "!< ECC errors present, but type unknown"]
pub const amdsmi_ras_err_state_t_AMDSMI_RAS_ERR_STATE_PARITY: amdsmi_ras_err_state_t = 2;
#[doc = "!< Single correctable error"]
pub const amdsmi_ras_err_state_t_AMDSMI_RAS_ERR_STATE_SING_C: amdsmi_ras_err_state_t = 3;
#[doc = "!< Multiple uncorrectable errors"]
pub const amdsmi_ras_err_state_t_AMDSMI_RAS_ERR_STATE_MULT_UC: amdsmi_ras_err_state_t = 4;
#[doc = "< Firmware detected error and isolated\npage. Treat as uncorrectable"]
pub const amdsmi_ras_err_state_t_AMDSMI_RAS_ERR_STATE_POISON: amdsmi_ras_err_state_t = 5;
#[doc = "!< ECC is enabled"]
pub const amdsmi_ras_err_state_t_AMDSMI_RAS_ERR_STATE_ENABLED: amdsmi_ras_err_state_t = 6;
pub const amdsmi_ras_err_state_t_AMDSMI_RAS_ERR_STATE_LAST: amdsmi_ras_err_state_t = 6;
pub const amdsmi_ras_err_state_t_AMDSMI_RAS_ERR_STATE_INVALID: amdsmi_ras_err_state_t = 4294967295;
#[doc = " @brief The current ECC state\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_ras_err_state_t = ::std::os::raw::c_uint;
pub const amdsmi_memory_type_t_AMDSMI_MEM_TYPE_FIRST: amdsmi_memory_type_t = 0;
#[doc = "!< VRAM memory"]
pub const amdsmi_memory_type_t_AMDSMI_MEM_TYPE_VRAM: amdsmi_memory_type_t = 0;
#[doc = "!< VRAM memory that is visible"]
pub const amdsmi_memory_type_t_AMDSMI_MEM_TYPE_VIS_VRAM: amdsmi_memory_type_t = 1;
#[doc = "!< GTT memory"]
pub const amdsmi_memory_type_t_AMDSMI_MEM_TYPE_GTT: amdsmi_memory_type_t = 2;
pub const amdsmi_memory_type_t_AMDSMI_MEM_TYPE_LAST: amdsmi_memory_type_t = 2;
#[doc = " @brief Types of memory\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_memory_type_t = ::std::os::raw::c_uint;
#[doc = "!< Index used for the minimum frequency value"]
pub const amdsmi_freq_ind_t_AMDSMI_FREQ_IND_MIN: amdsmi_freq_ind_t = 0;
#[doc = "!< Index used for the maximum frequency value"]
pub const amdsmi_freq_ind_t_AMDSMI_FREQ_IND_MAX: amdsmi_freq_ind_t = 1;
#[doc = "!< An invalid frequency index"]
pub const amdsmi_freq_ind_t_AMDSMI_FREQ_IND_INVALID: amdsmi_freq_ind_t = 4294967295;
#[doc = " @brief The values of this enum are used as frequency identifiers.\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_freq_ind_t = ::std::os::raw::c_uint;
#[doc = "!< XGMI No Errors"]
pub const amdsmi_xgmi_status_t_AMDSMI_XGMI_STATUS_NO_ERRORS: amdsmi_xgmi_status_t = 0;
#[doc = "!< XGMI Errors"]
pub const amdsmi_xgmi_status_t_AMDSMI_XGMI_STATUS_ERROR: amdsmi_xgmi_status_t = 1;
#[doc = "!< XGMI Multiple Errors"]
pub const amdsmi_xgmi_status_t_AMDSMI_XGMI_STATUS_MULTIPLE_ERRORS: amdsmi_xgmi_status_t = 2;
#[doc = " @brief XGMI Status\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_xgmi_status_t = ::std::os::raw::c_uint;
#[doc = " @brief Bitfield used in various AMDSMI calls\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_bit_field_t = u64;
#[doc = "!< Reserved. This gpu page is reserved and not available for use"]
pub const amdsmi_memory_page_status_t_AMDSMI_MEM_PAGE_STATUS_RESERVED: amdsmi_memory_page_status_t = 0;
#[doc = "< Pending. This gpu page is marked as bad and will be marked\nreserved at the next window"]
pub const amdsmi_memory_page_status_t_AMDSMI_MEM_PAGE_STATUS_PENDING: amdsmi_memory_page_status_t = 1;
#[doc = "!< Unable to reserve this page"]
pub const amdsmi_memory_page_status_t_AMDSMI_MEM_PAGE_STATUS_UNRESERVABLE: amdsmi_memory_page_status_t = 2;
#[doc = " @brief Reserved Memory Page States\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_memory_page_status_t = ::std::os::raw::c_uint;
pub const amdsmi_utilization_counter_type_t_AMDSMI_UTILIZATION_COUNTER_FIRST: amdsmi_utilization_counter_type_t = 0;
#[doc = "!< Course Grain Graphic Activity"]
pub const amdsmi_utilization_counter_type_t_AMDSMI_COARSE_GRAIN_GFX_ACTIVITY: amdsmi_utilization_counter_type_t = 0;
#[doc = "!< Course Grain Memory Activity"]
pub const amdsmi_utilization_counter_type_t_AMDSMI_COARSE_GRAIN_MEM_ACTIVITY: amdsmi_utilization_counter_type_t = 1;
#[doc = "!< Course Grain Decoder Activity"]
pub const amdsmi_utilization_counter_type_t_AMDSMI_COARSE_DECODER_ACTIVITY: amdsmi_utilization_counter_type_t = 2;
#[doc = "!< Fine Grain Graphic Activity"]
pub const amdsmi_utilization_counter_type_t_AMDSMI_FINE_GRAIN_GFX_ACTIVITY: amdsmi_utilization_counter_type_t = 100;
#[doc = "!< Fine Grain Memory Activity"]
pub const amdsmi_utilization_counter_type_t_AMDSMI_FINE_GRAIN_MEM_ACTIVITY: amdsmi_utilization_counter_type_t = 101;
#[doc = "!< Fine Grain Decoder Activity"]
pub const amdsmi_utilization_counter_type_t_AMDSMI_FINE_DECODER_ACTIVITY: amdsmi_utilization_counter_type_t = 102;
pub const amdsmi_utilization_counter_type_t_AMDSMI_UTILIZATION_COUNTER_LAST: amdsmi_utilization_counter_type_t = 102;
#[doc = " @brief The utilization counter type\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_utilization_counter_type_t = ::std::os::raw::c_uint;
#[doc = " @brief The utilization counter data\n\n The max number of values per counter type\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_utilization_counter_t {
    #[doc = "!< Utilization counter type"]
    pub type_: amdsmi_utilization_counter_type_t,
    #[doc = "!< Coarse grain activity counter value (average)"]
    pub value: u64,
    #[doc = "!< Utilization counter value"]
    pub fine_value: [u64; 4usize],
    pub fine_value_count: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_utilization_counter_t"][::std::mem::size_of::<amdsmi_utilization_counter_t>() - 56usize];
    ["Alignment of amdsmi_utilization_counter_t"][::std::mem::align_of::<amdsmi_utilization_counter_t>() - 8usize];
    ["Offset of field: amdsmi_utilization_counter_t::type_"]
        [::std::mem::offset_of!(amdsmi_utilization_counter_t, type_) - 0usize];
    ["Offset of field: amdsmi_utilization_counter_t::value"]
        [::std::mem::offset_of!(amdsmi_utilization_counter_t, value) - 8usize];
    ["Offset of field: amdsmi_utilization_counter_t::fine_value"]
        [::std::mem::offset_of!(amdsmi_utilization_counter_t, fine_value) - 16usize];
    ["Offset of field: amdsmi_utilization_counter_t::fine_value_count"]
        [::std::mem::offset_of!(amdsmi_utilization_counter_t, fine_value_count) - 48usize];
};
#[doc = " @brief Reserved Memory Page Record\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_retired_page_record_t {
    #[doc = "!< Start address of page"]
    pub page_address: u64,
    #[doc = "!< Page size"]
    pub page_size: u64,
    #[doc = "!< Page \"reserved\" status"]
    pub status: amdsmi_memory_page_status_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_retired_page_record_t"][::std::mem::size_of::<amdsmi_retired_page_record_t>() - 24usize];
    ["Alignment of amdsmi_retired_page_record_t"][::std::mem::align_of::<amdsmi_retired_page_record_t>() - 8usize];
    ["Offset of field: amdsmi_retired_page_record_t::page_address"]
        [::std::mem::offset_of!(amdsmi_retired_page_record_t, page_address) - 0usize];
    ["Offset of field: amdsmi_retired_page_record_t::page_size"]
        [::std::mem::offset_of!(amdsmi_retired_page_record_t, page_size) - 8usize];
    ["Offset of field: amdsmi_retired_page_record_t::status"]
        [::std::mem::offset_of!(amdsmi_retired_page_record_t, status) - 16usize];
};
#[doc = " @brief This structure contains information about which power profiles are\n supported by the system for a given device, and which power profile is\n currently active.\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_power_profile_status_t {
    #[doc = "!< Which profiles are supported by this system"]
    pub available_profiles: amdsmi_bit_field_t,
    #[doc = "!< Which power profile is currently active"]
    pub current: amdsmi_power_profile_preset_masks_t,
    #[doc = "!< How many power profiles are available"]
    pub num_profiles: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_power_profile_status_t"][::std::mem::size_of::<amdsmi_power_profile_status_t>() - 24usize];
    ["Alignment of amdsmi_power_profile_status_t"][::std::mem::align_of::<amdsmi_power_profile_status_t>() - 8usize];
    ["Offset of field: amdsmi_power_profile_status_t::available_profiles"]
        [::std::mem::offset_of!(amdsmi_power_profile_status_t, available_profiles) - 0usize];
    ["Offset of field: amdsmi_power_profile_status_t::current"]
        [::std::mem::offset_of!(amdsmi_power_profile_status_t, current) - 8usize];
    ["Offset of field: amdsmi_power_profile_status_t::num_profiles"]
        [::std::mem::offset_of!(amdsmi_power_profile_status_t, num_profiles) - 16usize];
};
#[doc = " @brief This structure holds information about clock frequencies.\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_frequencies_t {
    #[doc = "!< Deep Sleep frequency is only supported by some GPUs"]
    pub has_deep_sleep: bool,
    #[doc = "!< The number of supported frequencies"]
    pub num_supported: u32,
    #[doc = "!< The current frequency index in MHz"]
    pub current: u32,
    #[doc = "< List of frequencies in MHz.\nOnly the first num_supported frequencies are valid"]
    pub frequency: [u64; 33usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_frequencies_t"][::std::mem::size_of::<amdsmi_frequencies_t>() - 280usize];
    ["Alignment of amdsmi_frequencies_t"][::std::mem::align_of::<amdsmi_frequencies_t>() - 8usize];
    ["Offset of field: amdsmi_frequencies_t::has_deep_sleep"]
        [::std::mem::offset_of!(amdsmi_frequencies_t, has_deep_sleep) - 0usize];
    ["Offset of field: amdsmi_frequencies_t::num_supported"]
        [::std::mem::offset_of!(amdsmi_frequencies_t, num_supported) - 4usize];
    ["Offset of field: amdsmi_frequencies_t::current"][::std::mem::offset_of!(amdsmi_frequencies_t, current) - 8usize];
    ["Offset of field: amdsmi_frequencies_t::frequency"]
        [::std::mem::offset_of!(amdsmi_frequencies_t, frequency) - 16usize];
};
#[doc = " @brief The dpm policy.\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_dpm_policy_entry_t {
    pub policy_id: u32,
    pub policy_description: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_dpm_policy_entry_t"][::std::mem::size_of::<amdsmi_dpm_policy_entry_t>() - 260usize];
    ["Alignment of amdsmi_dpm_policy_entry_t"][::std::mem::align_of::<amdsmi_dpm_policy_entry_t>() - 4usize];
    ["Offset of field: amdsmi_dpm_policy_entry_t::policy_id"]
        [::std::mem::offset_of!(amdsmi_dpm_policy_entry_t, policy_id) - 0usize];
    ["Offset of field: amdsmi_dpm_policy_entry_t::policy_description"]
        [::std::mem::offset_of!(amdsmi_dpm_policy_entry_t, policy_description) - 4usize];
};
#[doc = " @brief DPM Policy\n\n Only the first num_supported policies are valid.\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_dpm_policy_t {
    #[doc = "!< The number of supported policies"]
    pub num_supported: u32,
    #[doc = "!< The current policy index"]
    pub current: u32,
    #[doc = "!< List of policies."]
    pub policies: [amdsmi_dpm_policy_entry_t; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_dpm_policy_t"][::std::mem::size_of::<amdsmi_dpm_policy_t>() - 8328usize];
    ["Alignment of amdsmi_dpm_policy_t"][::std::mem::align_of::<amdsmi_dpm_policy_t>() - 4usize];
    ["Offset of field: amdsmi_dpm_policy_t::num_supported"]
        [::std::mem::offset_of!(amdsmi_dpm_policy_t, num_supported) - 0usize];
    ["Offset of field: amdsmi_dpm_policy_t::current"][::std::mem::offset_of!(amdsmi_dpm_policy_t, current) - 4usize];
    ["Offset of field: amdsmi_dpm_policy_t::policies"][::std::mem::offset_of!(amdsmi_dpm_policy_t, policies) - 8usize];
};
#[doc = " @brief This structure holds information about the possible PCIe\n bandwidths. Specifically, the possible transfer rates and their\n associated numbers of lanes are stored here.\n\n Only the first num_supported bandwidths are valid.\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_pcie_bandwidth_t {
    #[doc = "!< Transfer rates (T/s) that are possible"]
    pub transfer_rate: amdsmi_frequencies_t,
    #[doc = "!< List of lanes for corresponding transfer rate."]
    pub lanes: [u32; 33usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_pcie_bandwidth_t"][::std::mem::size_of::<amdsmi_pcie_bandwidth_t>() - 416usize];
    ["Alignment of amdsmi_pcie_bandwidth_t"][::std::mem::align_of::<amdsmi_pcie_bandwidth_t>() - 8usize];
    ["Offset of field: amdsmi_pcie_bandwidth_t::transfer_rate"]
        [::std::mem::offset_of!(amdsmi_pcie_bandwidth_t, transfer_rate) - 0usize];
    ["Offset of field: amdsmi_pcie_bandwidth_t::lanes"]
        [::std::mem::offset_of!(amdsmi_pcie_bandwidth_t, lanes) - 280usize];
};
#[doc = " @brief This structure holds version information.\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_version_t {
    #[doc = "!< Major version"]
    pub major: u32,
    #[doc = "!< Minor version"]
    pub minor: u32,
    #[doc = "!< Patch, build or stepping version"]
    pub release: u32,
    #[doc = "!< Full Build version string"]
    pub build: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_version_t"][::std::mem::size_of::<amdsmi_version_t>() - 24usize];
    ["Alignment of amdsmi_version_t"][::std::mem::align_of::<amdsmi_version_t>() - 8usize];
    ["Offset of field: amdsmi_version_t::major"][::std::mem::offset_of!(amdsmi_version_t, major) - 0usize];
    ["Offset of field: amdsmi_version_t::minor"][::std::mem::offset_of!(amdsmi_version_t, minor) - 4usize];
    ["Offset of field: amdsmi_version_t::release"][::std::mem::offset_of!(amdsmi_version_t, release) - 8usize];
    ["Offset of field: amdsmi_version_t::build"][::std::mem::offset_of!(amdsmi_version_t, build) - 16usize];
};
#[doc = " @brief This structure represents a point on the frequency-voltage plane.\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_od_vddc_point_t {
    #[doc = "!< Frequency coordinate (in Hz)"]
    pub frequency: u64,
    #[doc = "!< Voltage coordinate (in mV)"]
    pub voltage: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_od_vddc_point_t"][::std::mem::size_of::<amdsmi_od_vddc_point_t>() - 16usize];
    ["Alignment of amdsmi_od_vddc_point_t"][::std::mem::align_of::<amdsmi_od_vddc_point_t>() - 8usize];
    ["Offset of field: amdsmi_od_vddc_point_t::frequency"]
        [::std::mem::offset_of!(amdsmi_od_vddc_point_t, frequency) - 0usize];
    ["Offset of field: amdsmi_od_vddc_point_t::voltage"]
        [::std::mem::offset_of!(amdsmi_od_vddc_point_t, voltage) - 8usize];
};
#[doc = " @brief This structure holds 2 ::amdsmi_range_t's, one for frequency and one for\n voltage. These 2 ranges indicate the range of possible values for the\n corresponding ::amdsmi_od_vddc_point_t.\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_freq_volt_region_t {
    #[doc = "!< The frequency range for this VDDC Curve point"]
    pub freq_range: amdsmi_range_t,
    #[doc = "!< The voltage range for this VDDC Curve point"]
    pub volt_range: amdsmi_range_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_freq_volt_region_t"][::std::mem::size_of::<amdsmi_freq_volt_region_t>() - 64usize];
    ["Alignment of amdsmi_freq_volt_region_t"][::std::mem::align_of::<amdsmi_freq_volt_region_t>() - 8usize];
    ["Offset of field: amdsmi_freq_volt_region_t::freq_range"]
        [::std::mem::offset_of!(amdsmi_freq_volt_region_t, freq_range) - 0usize];
    ["Offset of field: amdsmi_freq_volt_region_t::volt_range"]
        [::std::mem::offset_of!(amdsmi_freq_volt_region_t, volt_range) - 32usize];
};
#[doc = " @brief OD Vold Curve\n ::AMDSMI_NUM_VOLTAGE_CURVE_POINTS number of ::amdsmi_od_vddc_point_t's\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_od_volt_curve_t {
    #[doc = "!< make up the voltage frequency curve points."]
    pub vc_points: [amdsmi_od_vddc_point_t; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_od_volt_curve_t"][::std::mem::size_of::<amdsmi_od_volt_curve_t>() - 48usize];
    ["Alignment of amdsmi_od_volt_curve_t"][::std::mem::align_of::<amdsmi_od_volt_curve_t>() - 8usize];
    ["Offset of field: amdsmi_od_volt_curve_t::vc_points"]
        [::std::mem::offset_of!(amdsmi_od_volt_curve_t, vc_points) - 0usize];
};
#[doc = " @brief This structure holds the frequency-voltage values for a device.\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_od_volt_freq_data_t {
    #[doc = "!< The current SCLK frequency range in MHz"]
    pub curr_sclk_range: amdsmi_range_t,
    #[doc = "!< The current MCLK frequency range, upper bound only in MHz"]
    pub curr_mclk_range: amdsmi_range_t,
    #[doc = "!< The range possible of SCLK values in MHz"]
    pub sclk_freq_limits: amdsmi_range_t,
    #[doc = "!< The range possible of MCLK values in MHz"]
    pub mclk_freq_limits: amdsmi_range_t,
    #[doc = "!< The current voltage curve"]
    pub curve: amdsmi_od_volt_curve_t,
    #[doc = "!< The number of voltage curve regions"]
    pub num_regions: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_od_volt_freq_data_t"][::std::mem::size_of::<amdsmi_od_volt_freq_data_t>() - 184usize];
    ["Alignment of amdsmi_od_volt_freq_data_t"][::std::mem::align_of::<amdsmi_od_volt_freq_data_t>() - 8usize];
    ["Offset of field: amdsmi_od_volt_freq_data_t::curr_sclk_range"]
        [::std::mem::offset_of!(amdsmi_od_volt_freq_data_t, curr_sclk_range) - 0usize];
    ["Offset of field: amdsmi_od_volt_freq_data_t::curr_mclk_range"]
        [::std::mem::offset_of!(amdsmi_od_volt_freq_data_t, curr_mclk_range) - 32usize];
    ["Offset of field: amdsmi_od_volt_freq_data_t::sclk_freq_limits"]
        [::std::mem::offset_of!(amdsmi_od_volt_freq_data_t, sclk_freq_limits) - 64usize];
    ["Offset of field: amdsmi_od_volt_freq_data_t::mclk_freq_limits"]
        [::std::mem::offset_of!(amdsmi_od_volt_freq_data_t, mclk_freq_limits) - 96usize];
    ["Offset of field: amdsmi_od_volt_freq_data_t::curve"]
        [::std::mem::offset_of!(amdsmi_od_volt_freq_data_t, curve) - 128usize];
    ["Offset of field: amdsmi_od_volt_freq_data_t::num_regions"]
        [::std::mem::offset_of!(amdsmi_od_volt_freq_data_t, num_regions) - 176usize];
};
#[doc = " @brief Structure holds the gpu metrics table header for a device\n\n Size and version information of metrics data\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amd_metrics_table_header_t {
    #[doc = " \\cond Ignore in docs."]
    pub structure_size: u16,
    pub format_revision: u8,
    pub content_revision: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amd_metrics_table_header_t"][::std::mem::size_of::<amd_metrics_table_header_t>() - 4usize];
    ["Alignment of amd_metrics_table_header_t"][::std::mem::align_of::<amd_metrics_table_header_t>() - 2usize];
    ["Offset of field: amd_metrics_table_header_t::structure_size"]
        [::std::mem::offset_of!(amd_metrics_table_header_t, structure_size) - 0usize];
    ["Offset of field: amd_metrics_table_header_t::format_revision"]
        [::std::mem::offset_of!(amd_metrics_table_header_t, format_revision) - 2usize];
    ["Offset of field: amd_metrics_table_header_t::content_revision"]
        [::std::mem::offset_of!(amd_metrics_table_header_t, content_revision) - 3usize];
};
#[doc = " @brief The following structures hold the gpu statistics for a device.\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_gpu_xcp_metrics_t {
    #[doc = "!< Utilization Instantaneous in %"]
    pub gfx_busy_inst: [u32; 8usize],
    #[doc = "!< Utilization Instantaneous in % (UPDATED: to 40 in v1.8)"]
    pub jpeg_busy: [u16; 40usize],
    #[doc = "!< Utilization Instantaneous in %"]
    pub vcn_busy: [u16; 4usize],
    #[doc = "!< Utilization Accumulated in %"]
    pub gfx_busy_acc: [u64; 8usize],
    #[doc = "!< Total App Clock Counter Accumulated"]
    pub gfx_below_host_limit_acc: [u64; 8usize],
    #[doc = " @brief v1.8 additions"]
    pub gfx_below_host_limit_ppt_acc: [u64; 8usize],
    pub gfx_below_host_limit_thm_acc: [u64; 8usize],
    pub gfx_low_utilization_acc: [u64; 8usize],
    pub gfx_below_host_limit_total_acc: [u64; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_gpu_xcp_metrics_t"][::std::mem::size_of::<amdsmi_gpu_xcp_metrics_t>() - 504usize];
    ["Alignment of amdsmi_gpu_xcp_metrics_t"][::std::mem::align_of::<amdsmi_gpu_xcp_metrics_t>() - 8usize];
    ["Offset of field: amdsmi_gpu_xcp_metrics_t::gfx_busy_inst"]
        [::std::mem::offset_of!(amdsmi_gpu_xcp_metrics_t, gfx_busy_inst) - 0usize];
    ["Offset of field: amdsmi_gpu_xcp_metrics_t::jpeg_busy"]
        [::std::mem::offset_of!(amdsmi_gpu_xcp_metrics_t, jpeg_busy) - 32usize];
    ["Offset of field: amdsmi_gpu_xcp_metrics_t::vcn_busy"]
        [::std::mem::offset_of!(amdsmi_gpu_xcp_metrics_t, vcn_busy) - 112usize];
    ["Offset of field: amdsmi_gpu_xcp_metrics_t::gfx_busy_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_xcp_metrics_t, gfx_busy_acc) - 120usize];
    ["Offset of field: amdsmi_gpu_xcp_metrics_t::gfx_below_host_limit_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_xcp_metrics_t, gfx_below_host_limit_acc) - 184usize];
    ["Offset of field: amdsmi_gpu_xcp_metrics_t::gfx_below_host_limit_ppt_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_xcp_metrics_t, gfx_below_host_limit_ppt_acc) - 248usize];
    ["Offset of field: amdsmi_gpu_xcp_metrics_t::gfx_below_host_limit_thm_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_xcp_metrics_t, gfx_below_host_limit_thm_acc) - 312usize];
    ["Offset of field: amdsmi_gpu_xcp_metrics_t::gfx_low_utilization_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_xcp_metrics_t, gfx_low_utilization_acc) - 376usize];
    ["Offset of field: amdsmi_gpu_xcp_metrics_t::gfx_below_host_limit_total_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_xcp_metrics_t, gfx_below_host_limit_total_acc) - 440usize];
};
#[doc = " @brief Structure holds the gpu metrics values for a device\n\n This structure is extended to fit the needs of different GPU metric\n versions when exposing data through the structure.\n Depending on the version, some data members will hold data, and\n some will not. A good example is the set of 'current clocks':\n current_gfxclk, current_socclk, current_vclk0, current_dclk0.\n These are single-valued data members, up to version 1.3.\n For version 1.4 and up these are multi-valued data members (arrays)\n and their counterparts; current_gfxclks[], current_socclks[],\n current_vclk0s[], current_dclk0s[], will hold the data\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_gpu_metrics_t {
    pub common_header: amd_metrics_table_header_t,
    #[doc = " @brief v1.0 Base\n\n Temperature in C"]
    pub temperature_edge: u16,
    pub temperature_hotspot: u16,
    pub temperature_mem: u16,
    pub temperature_vrgfx: u16,
    pub temperature_vrsoc: u16,
    pub temperature_vrmem: u16,
    #[doc = "!< gfx"]
    pub average_gfx_activity: u16,
    #[doc = "!< memory controller"]
    pub average_umc_activity: u16,
    #[doc = "!< UVD or VCN"]
    pub average_mm_activity: u16,
    #[doc = " @brief Power (W) /Energy (15.259uJ per 1ns)"]
    pub average_socket_power: u16,
    #[doc = "!< v1 mod. (32->64)"]
    pub energy_accumulator: u64,
    #[doc = "!< v1 mod. (moved from top of struct)"]
    pub system_clock_counter: u64,
    #[doc = " @brief Average clocks (MHz)"]
    pub average_gfxclk_frequency: u16,
    pub average_socclk_frequency: u16,
    pub average_uclk_frequency: u16,
    pub average_vclk0_frequency: u16,
    pub average_dclk0_frequency: u16,
    pub average_vclk1_frequency: u16,
    pub average_dclk1_frequency: u16,
    #[doc = " @brief Current clocks (MHz)"]
    pub current_gfxclk: u16,
    pub current_socclk: u16,
    pub current_uclk: u16,
    pub current_vclk0: u16,
    pub current_dclk0: u16,
    pub current_vclk1: u16,
    pub current_dclk1: u16,
    #[doc = "!< Throttle status"]
    pub throttle_status: u32,
    #[doc = "!< Fans (RPM)"]
    pub current_fan_speed: u16,
    #[doc = "!< v1 mod.(8->16)"]
    pub pcie_link_width: u16,
    #[doc = "!< in 0.1 GT/s; v1 mod. (8->16)"]
    pub pcie_link_speed: u16,
    #[doc = "!< new in v1"]
    pub gfx_activity_acc: u32,
    #[doc = "!< new in v1"]
    pub mem_activity_acc: u32,
    #[doc = "!< new in v1"]
    pub temperature_hbm: [u16; 4usize],
    #[doc = "!< PMFW attached timestamp (10ns resolution)"]
    pub firmware_timestamp: u64,
    #[doc = "!< In mV"]
    pub voltage_soc: u16,
    #[doc = "!< In mV"]
    pub voltage_gfx: u16,
    #[doc = "!< In mV"]
    pub voltage_mem: u16,
    #[doc = "!< Throttle status"]
    pub indep_throttle_status: u64,
    #[doc = "!< In Watts"]
    pub current_socket_power: u16,
    #[doc = "!< Utilization (%)"]
    pub vcn_activity: [u16; 4usize],
    #[doc = "!< Clock Lock Status. Each bit corresponds to clock instance"]
    pub gfxclk_lock_status: u32,
    #[doc = "!< XGMI bus width in GB/s"]
    pub xgmi_link_width: u16,
    #[doc = "!< XGMI bus bitrate in GB/s"]
    pub xgmi_link_speed: u16,
    #[doc = "!< PCIE accumulated bandwidth (GB/sec)"]
    pub pcie_bandwidth_acc: u64,
    #[doc = "!< PCIE instantaneous bandwidth (GB/sec)"]
    pub pcie_bandwidth_inst: u64,
    #[doc = "!< PCIE L0 to recovery state transition accumulated count"]
    pub pcie_l0_to_recov_count_acc: u64,
    #[doc = "!< PCIE replay accumulated count"]
    pub pcie_replay_count_acc: u64,
    #[doc = "!< PCIE replay rollover accumulated count"]
    pub pcie_replay_rover_count_acc: u64,
    #[doc = "!< In KB"]
    pub xgmi_read_data_acc: [u64; 8usize],
    #[doc = "!< In KB"]
    pub xgmi_write_data_acc: [u64; 8usize],
    #[doc = "!< In KB"]
    pub current_gfxclks: [u16; 8usize],
    #[doc = "!< In KB"]
    pub current_socclks: [u16; 4usize],
    #[doc = "!< In KB"]
    pub current_vclk0s: [u16; 4usize],
    #[doc = "!< In KB"]
    pub current_dclk0s: [u16; 4usize],
    #[doc = "!< JPEG activity percent (encode/decode)"]
    pub jpeg_activity: [u16; 32usize],
    #[doc = "!< PCIE NAK sent accumulated count"]
    pub pcie_nak_sent_count_acc: u32,
    #[doc = "!< PCIE NAK received accumulated count"]
    pub pcie_nak_rcvd_count_acc: u32,
    #[doc = "!< Accumulation cycle counter"]
    pub accumulation_counter: u64,
    #[doc = " @brief Accumulated throttler residencies"]
    pub prochot_residency_acc: u64,
    #[doc = " @brief Accumulated throttler residencies\n\n Prochot (thermal) - PPT (power)\n Package Power Tracking (PPT) violation % (greater than 0% is a violation);\n aka PVIOL\n\n Ex. PVIOL/TVIOL calculations\n Where A and B are measurments recorded at prior points in time.\n Typically A is the earlier measured value and B is the latest measured value.\n\n PVIOL % = (PptResidencyAcc (B) - PptResidencyAcc (A)) * 100/ (AccumulationCounter (B) - AccumulationCounter (A))\n TVIOL % = (SocketThmResidencyAcc (B) -  SocketThmResidencyAcc (A)) * 100 / (AccumulationCounter (B) - AccumulationCounter (A))"]
    pub ppt_residency_acc: u64,
    #[doc = " @brief Accumulated throttler residencies\n\n Socket (thermal) -\n Socket thermal violation % (greater than 0% is a violation);\n aka TVIOL\n\n Ex. PVIOL/TVIOL calculations\n Where A and B are measurments recorded at prior points in time.\n Typically A is the earlier measured value and B is the latest measured value.\n\n PVIOL % = (PptResidencyAcc (B) - PptResidencyAcc (A)) * 100/ (AccumulationCounter (B) - AccumulationCounter (A))\n TVIOL % = (SocketThmResidencyAcc (B) -  SocketThmResidencyAcc (A)) * 100 / (AccumulationCounter (B) - AccumulationCounter (A))"]
    pub socket_thm_residency_acc: u64,
    pub vr_thm_residency_acc: u64,
    pub hbm_thm_residency_acc: u64,
    #[doc = "!< Number of current partition"]
    pub num_partition: u16,
    #[doc = "!< XCP (Graphic Cluster Partitions) metrics stats"]
    pub xcp_stats: [amdsmi_gpu_xcp_metrics_t; 8usize],
    #[doc = "!< PCIE other end recovery counter"]
    pub pcie_lc_perf_other_end_recovery: u32,
    #[doc = "!< VRAM max bandwidth at max memory clock (GB/s)"]
    pub vram_max_bandwidth: u64,
    #[doc = "!< XGMI link status(up/down)"]
    pub xgmi_link_status: [u16; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_gpu_metrics_t"][::std::mem::size_of::<amdsmi_gpu_metrics_t>() - 4544usize];
    ["Alignment of amdsmi_gpu_metrics_t"][::std::mem::align_of::<amdsmi_gpu_metrics_t>() - 8usize];
    ["Offset of field: amdsmi_gpu_metrics_t::common_header"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, common_header) - 0usize];
    ["Offset of field: amdsmi_gpu_metrics_t::temperature_edge"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, temperature_edge) - 4usize];
    ["Offset of field: amdsmi_gpu_metrics_t::temperature_hotspot"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, temperature_hotspot) - 6usize];
    ["Offset of field: amdsmi_gpu_metrics_t::temperature_mem"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, temperature_mem) - 8usize];
    ["Offset of field: amdsmi_gpu_metrics_t::temperature_vrgfx"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, temperature_vrgfx) - 10usize];
    ["Offset of field: amdsmi_gpu_metrics_t::temperature_vrsoc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, temperature_vrsoc) - 12usize];
    ["Offset of field: amdsmi_gpu_metrics_t::temperature_vrmem"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, temperature_vrmem) - 14usize];
    ["Offset of field: amdsmi_gpu_metrics_t::average_gfx_activity"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, average_gfx_activity) - 16usize];
    ["Offset of field: amdsmi_gpu_metrics_t::average_umc_activity"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, average_umc_activity) - 18usize];
    ["Offset of field: amdsmi_gpu_metrics_t::average_mm_activity"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, average_mm_activity) - 20usize];
    ["Offset of field: amdsmi_gpu_metrics_t::average_socket_power"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, average_socket_power) - 22usize];
    ["Offset of field: amdsmi_gpu_metrics_t::energy_accumulator"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, energy_accumulator) - 24usize];
    ["Offset of field: amdsmi_gpu_metrics_t::system_clock_counter"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, system_clock_counter) - 32usize];
    ["Offset of field: amdsmi_gpu_metrics_t::average_gfxclk_frequency"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, average_gfxclk_frequency) - 40usize];
    ["Offset of field: amdsmi_gpu_metrics_t::average_socclk_frequency"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, average_socclk_frequency) - 42usize];
    ["Offset of field: amdsmi_gpu_metrics_t::average_uclk_frequency"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, average_uclk_frequency) - 44usize];
    ["Offset of field: amdsmi_gpu_metrics_t::average_vclk0_frequency"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, average_vclk0_frequency) - 46usize];
    ["Offset of field: amdsmi_gpu_metrics_t::average_dclk0_frequency"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, average_dclk0_frequency) - 48usize];
    ["Offset of field: amdsmi_gpu_metrics_t::average_vclk1_frequency"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, average_vclk1_frequency) - 50usize];
    ["Offset of field: amdsmi_gpu_metrics_t::average_dclk1_frequency"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, average_dclk1_frequency) - 52usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_gfxclk"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_gfxclk) - 54usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_socclk"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_socclk) - 56usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_uclk"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_uclk) - 58usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_vclk0"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_vclk0) - 60usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_dclk0"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_dclk0) - 62usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_vclk1"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_vclk1) - 64usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_dclk1"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_dclk1) - 66usize];
    ["Offset of field: amdsmi_gpu_metrics_t::throttle_status"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, throttle_status) - 68usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_fan_speed"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_fan_speed) - 72usize];
    ["Offset of field: amdsmi_gpu_metrics_t::pcie_link_width"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, pcie_link_width) - 74usize];
    ["Offset of field: amdsmi_gpu_metrics_t::pcie_link_speed"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, pcie_link_speed) - 76usize];
    ["Offset of field: amdsmi_gpu_metrics_t::gfx_activity_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, gfx_activity_acc) - 80usize];
    ["Offset of field: amdsmi_gpu_metrics_t::mem_activity_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, mem_activity_acc) - 84usize];
    ["Offset of field: amdsmi_gpu_metrics_t::temperature_hbm"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, temperature_hbm) - 88usize];
    ["Offset of field: amdsmi_gpu_metrics_t::firmware_timestamp"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, firmware_timestamp) - 96usize];
    ["Offset of field: amdsmi_gpu_metrics_t::voltage_soc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, voltage_soc) - 104usize];
    ["Offset of field: amdsmi_gpu_metrics_t::voltage_gfx"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, voltage_gfx) - 106usize];
    ["Offset of field: amdsmi_gpu_metrics_t::voltage_mem"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, voltage_mem) - 108usize];
    ["Offset of field: amdsmi_gpu_metrics_t::indep_throttle_status"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, indep_throttle_status) - 112usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_socket_power"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_socket_power) - 120usize];
    ["Offset of field: amdsmi_gpu_metrics_t::vcn_activity"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, vcn_activity) - 122usize];
    ["Offset of field: amdsmi_gpu_metrics_t::gfxclk_lock_status"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, gfxclk_lock_status) - 132usize];
    ["Offset of field: amdsmi_gpu_metrics_t::xgmi_link_width"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, xgmi_link_width) - 136usize];
    ["Offset of field: amdsmi_gpu_metrics_t::xgmi_link_speed"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, xgmi_link_speed) - 138usize];
    ["Offset of field: amdsmi_gpu_metrics_t::pcie_bandwidth_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, pcie_bandwidth_acc) - 144usize];
    ["Offset of field: amdsmi_gpu_metrics_t::pcie_bandwidth_inst"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, pcie_bandwidth_inst) - 152usize];
    ["Offset of field: amdsmi_gpu_metrics_t::pcie_l0_to_recov_count_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, pcie_l0_to_recov_count_acc) - 160usize];
    ["Offset of field: amdsmi_gpu_metrics_t::pcie_replay_count_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, pcie_replay_count_acc) - 168usize];
    ["Offset of field: amdsmi_gpu_metrics_t::pcie_replay_rover_count_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, pcie_replay_rover_count_acc) - 176usize];
    ["Offset of field: amdsmi_gpu_metrics_t::xgmi_read_data_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, xgmi_read_data_acc) - 184usize];
    ["Offset of field: amdsmi_gpu_metrics_t::xgmi_write_data_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, xgmi_write_data_acc) - 248usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_gfxclks"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_gfxclks) - 312usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_socclks"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_socclks) - 328usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_vclk0s"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_vclk0s) - 336usize];
    ["Offset of field: amdsmi_gpu_metrics_t::current_dclk0s"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, current_dclk0s) - 344usize];
    ["Offset of field: amdsmi_gpu_metrics_t::jpeg_activity"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, jpeg_activity) - 352usize];
    ["Offset of field: amdsmi_gpu_metrics_t::pcie_nak_sent_count_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, pcie_nak_sent_count_acc) - 416usize];
    ["Offset of field: amdsmi_gpu_metrics_t::pcie_nak_rcvd_count_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, pcie_nak_rcvd_count_acc) - 420usize];
    ["Offset of field: amdsmi_gpu_metrics_t::accumulation_counter"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, accumulation_counter) - 424usize];
    ["Offset of field: amdsmi_gpu_metrics_t::prochot_residency_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, prochot_residency_acc) - 432usize];
    ["Offset of field: amdsmi_gpu_metrics_t::ppt_residency_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, ppt_residency_acc) - 440usize];
    ["Offset of field: amdsmi_gpu_metrics_t::socket_thm_residency_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, socket_thm_residency_acc) - 448usize];
    ["Offset of field: amdsmi_gpu_metrics_t::vr_thm_residency_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, vr_thm_residency_acc) - 456usize];
    ["Offset of field: amdsmi_gpu_metrics_t::hbm_thm_residency_acc"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, hbm_thm_residency_acc) - 464usize];
    ["Offset of field: amdsmi_gpu_metrics_t::num_partition"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, num_partition) - 472usize];
    ["Offset of field: amdsmi_gpu_metrics_t::xcp_stats"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, xcp_stats) - 480usize];
    ["Offset of field: amdsmi_gpu_metrics_t::pcie_lc_perf_other_end_recovery"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, pcie_lc_perf_other_end_recovery) - 4512usize];
    ["Offset of field: amdsmi_gpu_metrics_t::vram_max_bandwidth"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, vram_max_bandwidth) - 4520usize];
    ["Offset of field: amdsmi_gpu_metrics_t::xgmi_link_status"]
        [::std::mem::offset_of!(amdsmi_gpu_metrics_t, xgmi_link_status) - 4528usize];
};
#[doc = "!< XGMI link status is down"]
pub const amdsmi_xgmi_link_status_type_t_AMDSMI_XGMI_LINK_DOWN: amdsmi_xgmi_link_status_type_t = 0;
#[doc = "!< XGMI link status is up"]
pub const amdsmi_xgmi_link_status_type_t_AMDSMI_XGMI_LINK_UP: amdsmi_xgmi_link_status_type_t = 1;
#[doc = "!< XGMI link status is disabled"]
pub const amdsmi_xgmi_link_status_type_t_AMDSMI_XGMI_LINK_DISABLE: amdsmi_xgmi_link_status_type_t = 2;
#[doc = " @brief XGMI Link Status Type\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_xgmi_link_status_type_t = ::std::os::raw::c_uint;
#[doc = " @brief XGMI Link Status\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_xgmi_link_status_t {
    #[doc = "!< The total links in the status array"]
    pub total_links: u32,
    pub status: [amdsmi_xgmi_link_status_type_t; 8usize],
    pub reserved: [u64; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_xgmi_link_status_t"][::std::mem::size_of::<amdsmi_xgmi_link_status_t>() - 96usize];
    ["Alignment of amdsmi_xgmi_link_status_t"][::std::mem::align_of::<amdsmi_xgmi_link_status_t>() - 8usize];
    ["Offset of field: amdsmi_xgmi_link_status_t::total_links"]
        [::std::mem::offset_of!(amdsmi_xgmi_link_status_t, total_links) - 0usize];
    ["Offset of field: amdsmi_xgmi_link_status_t::status"]
        [::std::mem::offset_of!(amdsmi_xgmi_link_status_t, status) - 4usize];
    ["Offset of field: amdsmi_xgmi_link_status_t::reserved"]
        [::std::mem::offset_of!(amdsmi_xgmi_link_status_t, reserved) - 40usize];
};
#[doc = " @brief This structure holds the name value pairs\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_name_value_t {
    #[doc = "!< Name"]
    pub name: [::std::os::raw::c_char; 256usize],
    #[doc = "!< Use uint64_t to make it universal"]
    pub value: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_name_value_t"][::std::mem::size_of::<amdsmi_name_value_t>() - 264usize];
    ["Alignment of amdsmi_name_value_t"][::std::mem::align_of::<amdsmi_name_value_t>() - 8usize];
    ["Offset of field: amdsmi_name_value_t::name"][::std::mem::offset_of!(amdsmi_name_value_t, name) - 0usize];
    ["Offset of field: amdsmi_name_value_t::value"][::std::mem::offset_of!(amdsmi_name_value_t, value) - 256usize];
};
#[doc = "!< XGMI registers"]
pub const amdsmi_reg_type_t_AMDSMI_REG_XGMI: amdsmi_reg_type_t = 0;
#[doc = "!< WAFL registers"]
pub const amdsmi_reg_type_t_AMDSMI_REG_WAFL: amdsmi_reg_type_t = 1;
#[doc = "!< PCIe registers"]
pub const amdsmi_reg_type_t_AMDSMI_REG_PCIE: amdsmi_reg_type_t = 2;
#[doc = "!< Usr registers"]
pub const amdsmi_reg_type_t_AMDSMI_REG_USR: amdsmi_reg_type_t = 3;
#[doc = "!< Usr1 registers"]
pub const amdsmi_reg_type_t_AMDSMI_REG_USR1: amdsmi_reg_type_t = 4;
#[doc = " @brief This register type for register table\n\n @cond @tag{gpu_bm_linux} @endcond"]
pub type amdsmi_reg_type_t = ::std::os::raw::c_uint;
#[doc = " @brief This structure holds ras feature\n\n @cond @tag{gpu_bm_linux} @platform{guest_windows} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_ras_feature_t {
    #[doc = "< PARITY error(bit 0), Single Bit correctable (bit1),\nDouble bit error detection (bit2), Poison (bit 3)."]
    pub ras_eeprom_version: u32,
    #[doc = "< ecc_correction_schema mask.\nPARITY error(bit 0), Single Bit correctable (bit1),\nDouble bit error detection (bit2), Poison (bit 3)"]
    pub ecc_correction_schema_flag: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_ras_feature_t"][::std::mem::size_of::<amdsmi_ras_feature_t>() - 8usize];
    ["Alignment of amdsmi_ras_feature_t"][::std::mem::align_of::<amdsmi_ras_feature_t>() - 4usize];
    ["Offset of field: amdsmi_ras_feature_t::ras_eeprom_version"]
        [::std::mem::offset_of!(amdsmi_ras_feature_t, ras_eeprom_version) - 0usize];
    ["Offset of field: amdsmi_ras_feature_t::ecc_correction_schema_flag"]
        [::std::mem::offset_of!(amdsmi_ras_feature_t, ecc_correction_schema_flag) - 4usize];
};
#[doc = " @brief This structure holds error counts.\n\n @cond @tag{gpu_bm_linux} @tag{guest_windows} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_error_count_t {
    #[doc = "!< Accumulated correctable errors"]
    pub correctable_count: u64,
    #[doc = "!< Accumulated uncorrectable errors"]
    pub uncorrectable_count: u64,
    #[doc = "!< Accumulated deferred errors"]
    pub deferred_count: u64,
    pub reserved: [u64; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_error_count_t"][::std::mem::size_of::<amdsmi_error_count_t>() - 64usize];
    ["Alignment of amdsmi_error_count_t"][::std::mem::align_of::<amdsmi_error_count_t>() - 8usize];
    ["Offset of field: amdsmi_error_count_t::correctable_count"]
        [::std::mem::offset_of!(amdsmi_error_count_t, correctable_count) - 0usize];
    ["Offset of field: amdsmi_error_count_t::uncorrectable_count"]
        [::std::mem::offset_of!(amdsmi_error_count_t, uncorrectable_count) - 8usize];
    ["Offset of field: amdsmi_error_count_t::deferred_count"]
        [::std::mem::offset_of!(amdsmi_error_count_t, deferred_count) - 16usize];
    ["Offset of field: amdsmi_error_count_t::reserved"]
        [::std::mem::offset_of!(amdsmi_error_count_t, reserved) - 24usize];
};
#[doc = " @brief This structure contains information specific to a process.\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_process_info_t {
    #[doc = "!< Process ID"]
    pub process_id: u32,
    #[doc = "!< VRAM usage in MB"]
    pub vram_usage: u64,
    #[doc = "!< SDMA usage in microseconds"]
    pub sdma_usage: u64,
    #[doc = "!< Compute Unit usage in percent"]
    pub cu_occupancy: u32,
    #[doc = "!< Time that queues are evicted on a GPU in milliseconds"]
    pub evicted_time: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_process_info_t"][::std::mem::size_of::<amdsmi_process_info_t>() - 32usize];
    ["Alignment of amdsmi_process_info_t"][::std::mem::align_of::<amdsmi_process_info_t>() - 8usize];
    ["Offset of field: amdsmi_process_info_t::process_id"]
        [::std::mem::offset_of!(amdsmi_process_info_t, process_id) - 0usize];
    ["Offset of field: amdsmi_process_info_t::vram_usage"]
        [::std::mem::offset_of!(amdsmi_process_info_t, vram_usage) - 8usize];
    ["Offset of field: amdsmi_process_info_t::sdma_usage"]
        [::std::mem::offset_of!(amdsmi_process_info_t, sdma_usage) - 16usize];
    ["Offset of field: amdsmi_process_info_t::cu_occupancy"]
        [::std::mem::offset_of!(amdsmi_process_info_t, cu_occupancy) - 24usize];
    ["Offset of field: amdsmi_process_info_t::evicted_time"]
        [::std::mem::offset_of!(amdsmi_process_info_t, evicted_time) - 28usize];
};
#[doc = " @brief Topology Nearest\n\n @cond @tag{gpu_bm_linux} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_topology_nearest_t {
    pub count: u32,
    pub processor_list: [amdsmi_processor_handle; 256usize],
    pub reserved: [u64; 15usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_topology_nearest_t"][::std::mem::size_of::<amdsmi_topology_nearest_t>() - 2176usize];
    ["Alignment of amdsmi_topology_nearest_t"][::std::mem::align_of::<amdsmi_topology_nearest_t>() - 8usize];
    ["Offset of field: amdsmi_topology_nearest_t::count"]
        [::std::mem::offset_of!(amdsmi_topology_nearest_t, count) - 0usize];
    ["Offset of field: amdsmi_topology_nearest_t::processor_list"]
        [::std::mem::offset_of!(amdsmi_topology_nearest_t, processor_list) - 8usize];
    ["Offset of field: amdsmi_topology_nearest_t::reserved"]
        [::std::mem::offset_of!(amdsmi_topology_nearest_t, reserved) - 2056usize];
};
#[doc = "!< Unknown Virtualization Mode"]
pub const amdsmi_virtualization_mode_t_AMDSMI_VIRTUALIZATION_MODE_UNKNOWN: amdsmi_virtualization_mode_t = 0;
#[doc = "!< Baremetal Virtualization Mode"]
pub const amdsmi_virtualization_mode_t_AMDSMI_VIRTUALIZATION_MODE_BAREMETAL: amdsmi_virtualization_mode_t = 1;
#[doc = "!< Host Virtualization Mode"]
pub const amdsmi_virtualization_mode_t_AMDSMI_VIRTUALIZATION_MODE_HOST: amdsmi_virtualization_mode_t = 2;
#[doc = "!< Guest Virtualization Mode"]
pub const amdsmi_virtualization_mode_t_AMDSMI_VIRTUALIZATION_MODE_GUEST: amdsmi_virtualization_mode_t = 3;
#[doc = "!< Passthrough Virtualization Mode"]
pub const amdsmi_virtualization_mode_t_AMDSMI_VIRTUALIZATION_MODE_PASSTHROUGH: amdsmi_virtualization_mode_t = 4;
#[doc = " @brief Variant placeholder\n\n Place-holder \"variant\" for functions that have don't have any variants,\n but do have monitors or sensors.\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_virtualization_mode_t = ::std::os::raw::c_uint;
#[doc = "!< Memory affinity as numa node"]
pub const amdsmi_affinity_scope_t_AMDSMI_AFFINITY_SCOPE_NODE: amdsmi_affinity_scope_t = 0;
#[doc = "!< socket affinity"]
pub const amdsmi_affinity_scope_t_AMDSMI_AFFINITY_SCOPE_SOCKET: amdsmi_affinity_scope_t = 1;
#[doc = " @brief Scope for Numa affinity or Socket affinity\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_affinity_scope_t = ::std::os::raw::c_uint;
pub const amdsmi_npm_status_t_AMDSMI_NPM_STATUS_DISABLED: amdsmi_npm_status_t = 0;
pub const amdsmi_npm_status_t_AMDSMI_NPM_STATUS_ENABLED: amdsmi_npm_status_t = 1;
#[doc = " @brief NPM status\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
pub type amdsmi_npm_status_t = ::std::os::raw::c_uint;
#[doc = " @brief NPM info\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_npm_info_t {
    #[doc = "!< NPM status (enabled/disabled)."]
    pub status: amdsmi_npm_status_t,
    #[doc = "!< Node-level power limit in Watts."]
    pub limit: u64,
    pub reserved: [u64; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_npm_info_t"][::std::mem::size_of::<amdsmi_npm_info_t>() - 64usize];
    ["Alignment of amdsmi_npm_info_t"][::std::mem::align_of::<amdsmi_npm_info_t>() - 8usize];
    ["Offset of field: amdsmi_npm_info_t::status"][::std::mem::offset_of!(amdsmi_npm_info_t, status) - 0usize];
    ["Offset of field: amdsmi_npm_info_t::limit"][::std::mem::offset_of!(amdsmi_npm_info_t, limit) - 8usize];
    ["Offset of field: amdsmi_npm_info_t::reserved"][::std::mem::offset_of!(amdsmi_npm_info_t, reserved) - 16usize];
};
#[doc = " @brief cpu socket info data\n\n @cond @tag{cpu_bm} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_sock_info_t {
    pub socket_id: u32,
    pub cores_per_socket: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_sock_info_t"][::std::mem::size_of::<amdsmi_sock_info_t>() - 8usize];
    ["Alignment of amdsmi_sock_info_t"][::std::mem::align_of::<amdsmi_sock_info_t>() - 4usize];
    ["Offset of field: amdsmi_sock_info_t::socket_id"][::std::mem::offset_of!(amdsmi_sock_info_t, socket_id) - 0usize];
    ["Offset of field: amdsmi_sock_info_t::cores_per_socket"]
        [::std::mem::offset_of!(amdsmi_sock_info_t, cores_per_socket) - 4usize];
};
#[doc = " @brief Cper\n\n @cond @tag{gpu_bm_linux} @tag{host} @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_cper_guid_t {
    pub b: [::std::os::raw::c_uchar; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_cper_guid_t"][::std::mem::size_of::<amdsmi_cper_guid_t>() - 16usize];
    ["Alignment of amdsmi_cper_guid_t"][::std::mem::align_of::<amdsmi_cper_guid_t>() - 1usize];
    ["Offset of field: amdsmi_cper_guid_t::b"][::std::mem::offset_of!(amdsmi_cper_guid_t, b) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_cper_timestamp_t {
    pub seconds: u8,
    pub minutes: u8,
    pub hours: u8,
    pub flag: u8,
    pub day: u8,
    pub month: u8,
    pub year: u8,
    pub century: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_cper_timestamp_t"][::std::mem::size_of::<amdsmi_cper_timestamp_t>() - 8usize];
    ["Alignment of amdsmi_cper_timestamp_t"][::std::mem::align_of::<amdsmi_cper_timestamp_t>() - 1usize];
    ["Offset of field: amdsmi_cper_timestamp_t::seconds"]
        [::std::mem::offset_of!(amdsmi_cper_timestamp_t, seconds) - 0usize];
    ["Offset of field: amdsmi_cper_timestamp_t::minutes"]
        [::std::mem::offset_of!(amdsmi_cper_timestamp_t, minutes) - 1usize];
    ["Offset of field: amdsmi_cper_timestamp_t::hours"]
        [::std::mem::offset_of!(amdsmi_cper_timestamp_t, hours) - 2usize];
    ["Offset of field: amdsmi_cper_timestamp_t::flag"][::std::mem::offset_of!(amdsmi_cper_timestamp_t, flag) - 3usize];
    ["Offset of field: amdsmi_cper_timestamp_t::day"][::std::mem::offset_of!(amdsmi_cper_timestamp_t, day) - 4usize];
    ["Offset of field: amdsmi_cper_timestamp_t::month"]
        [::std::mem::offset_of!(amdsmi_cper_timestamp_t, month) - 5usize];
    ["Offset of field: amdsmi_cper_timestamp_t::year"][::std::mem::offset_of!(amdsmi_cper_timestamp_t, year) - 6usize];
    ["Offset of field: amdsmi_cper_timestamp_t::century"]
        [::std::mem::offset_of!(amdsmi_cper_timestamp_t, century) - 7usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union amdsmi_cper_valid_bits_t {
    pub valid_bits: amdsmi_cper_valid_bits_t_valid_bits_,
    pub valid_mask: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amdsmi_cper_valid_bits_t_valid_bits_ {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_cper_valid_bits_t_valid_bits_"]
        [::std::mem::size_of::<amdsmi_cper_valid_bits_t_valid_bits_>() - 4usize];
    ["Alignment of amdsmi_cper_valid_bits_t_valid_bits_"]
        [::std::mem::align_of::<amdsmi_cper_valid_bits_t_valid_bits_>() - 1usize];
};
impl amdsmi_cper_valid_bits_t_valid_bits_ {
    #[inline]
    pub fn platform_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_platform_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn platform_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_platform_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn timestamp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn timestamp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_timestamp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn partition_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_partition_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn partition_id_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_partition_id_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        platform_id: u32,
        timestamp: u32,
        partition_id: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let platform_id: u32 = unsafe { ::std::mem::transmute(platform_id) };
            platform_id as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let timestamp: u32 = unsafe { ::std::mem::transmute(timestamp) };
            timestamp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let partition_id: u32 = unsafe { ::std::mem::transmute(partition_id) };
            partition_id as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_cper_valid_bits_t"][::std::mem::size_of::<amdsmi_cper_valid_bits_t>() - 4usize];
    ["Alignment of amdsmi_cper_valid_bits_t"][::std::mem::align_of::<amdsmi_cper_valid_bits_t>() - 1usize];
    ["Offset of field: amdsmi_cper_valid_bits_t::valid_bits"]
        [::std::mem::offset_of!(amdsmi_cper_valid_bits_t, valid_bits) - 0usize];
    ["Offset of field: amdsmi_cper_valid_bits_t::valid_mask"]
        [::std::mem::offset_of!(amdsmi_cper_valid_bits_t, valid_mask) - 0usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct amdsmi_cper_hdr_t {
    #[doc = "!< \"CPER\""]
    pub signature: [::std::os::raw::c_char; 4usize],
    pub revision: u16,
    #[doc = "!< 0xFFFFFFFF"]
    pub signature_end: u32,
    pub sec_cnt: u16,
    pub error_severity: amdsmi_cper_sev_t,
    pub cper_valid_bits: amdsmi_cper_valid_bits_t,
    #[doc = "!< Total size of CPER Entry"]
    pub record_length: u32,
    pub timestamp: amdsmi_cper_timestamp_t,
    pub platform_id: [::std::os::raw::c_char; 16usize],
    #[doc = "!< Reserved"]
    pub partition_id: amdsmi_cper_guid_t,
    pub creator_id: [::std::os::raw::c_char; 16usize],
    #[doc = "!< CMC, MCE, can use amdsmi_cper_notifiy_type_t to decode"]
    pub notify_type: amdsmi_cper_guid_t,
    #[doc = "!< Unique CPER Entry ID"]
    pub record_id: [::std::os::raw::c_char; 8usize],
    #[doc = "!< Reserved"]
    pub flags: u32,
    #[doc = "!< Reserved"]
    pub persistence_info: u64,
    #[doc = "!< Reserved"]
    pub reserved: [u8; 12usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of amdsmi_cper_hdr_t"][::std::mem::size_of::<amdsmi_cper_hdr_t>() - 128usize];
    ["Alignment of amdsmi_cper_hdr_t"][::std::mem::align_of::<amdsmi_cper_hdr_t>() - 1usize];
    ["Offset of field: amdsmi_cper_hdr_t::signature"][::std::mem::offset_of!(amdsmi_cper_hdr_t, signature) - 0usize];
    ["Offset of field: amdsmi_cper_hdr_t::revision"][::std::mem::offset_of!(amdsmi_cper_hdr_t, revision) - 4usize];
    ["Offset of field: amdsmi_cper_hdr_t::signature_end"]
        [::std::mem::offset_of!(amdsmi_cper_hdr_t, signature_end) - 6usize];
    ["Offset of field: amdsmi_cper_hdr_t::sec_cnt"][::std::mem::offset_of!(amdsmi_cper_hdr_t, sec_cnt) - 10usize];
    ["Offset of field: amdsmi_cper_hdr_t::error_severity"]
        [::std::mem::offset_of!(amdsmi_cper_hdr_t, error_severity) - 12usize];
    ["Offset of field: amdsmi_cper_hdr_t::cper_valid_bits"]
        [::std::mem::offset_of!(amdsmi_cper_hdr_t, cper_valid_bits) - 16usize];
    ["Offset of field: amdsmi_cper_hdr_t::record_length"]
        [::std::mem::offset_of!(amdsmi_cper_hdr_t, record_length) - 20usize];
    ["Offset of field: amdsmi_cper_hdr_t::timestamp"][::std::mem::offset_of!(amdsmi_cper_hdr_t, timestamp) - 24usize];
    ["Offset of field: amdsmi_cper_hdr_t::platform_id"]
        [::std::mem::offset_of!(amdsmi_cper_hdr_t, platform_id) - 32usize];
    ["Offset of field: amdsmi_cper_hdr_t::partition_id"]
        [::std::mem::offset_of!(amdsmi_cper_hdr_t, partition_id) - 48usize];
    ["Offset of field: amdsmi_cper_hdr_t::creator_id"][::std::mem::offset_of!(amdsmi_cper_hdr_t, creator_id) - 64usize];
    ["Offset of field: amdsmi_cper_hdr_t::notify_type"]
        [::std::mem::offset_of!(amdsmi_cper_hdr_t, notify_type) - 80usize];
    ["Offset of field: amdsmi_cper_hdr_t::record_id"][::std::mem::offset_of!(amdsmi_cper_hdr_t, record_id) - 96usize];
    ["Offset of field: amdsmi_cper_hdr_t::flags"][::std::mem::offset_of!(amdsmi_cper_hdr_t, flags) - 104usize];
    ["Offset of field: amdsmi_cper_hdr_t::persistence_info"]
        [::std::mem::offset_of!(amdsmi_cper_hdr_t, persistence_info) - 108usize];
    ["Offset of field: amdsmi_cper_hdr_t::reserved"][::std::mem::offset_of!(amdsmi_cper_hdr_t, reserved) - 116usize];
};
pub struct libamd_smi {
    __library: ::libloading::Library,
    pub __ctype_get_mb_cur_max: Result<unsafe extern "C" fn() -> usize, ::libloading::Error>,
    pub atof: Result<unsafe extern "C" fn(__nptr: *const ::std::os::raw::c_char) -> f64, ::libloading::Error>,
    pub atoi: Result<
        unsafe extern "C" fn(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub atol: Result<
        unsafe extern "C" fn(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub atoll: Result<
        unsafe extern "C" fn(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub strtod: Result<
        unsafe extern "C" fn(__nptr: *const ::std::os::raw::c_char, __endptr: *mut *mut ::std::os::raw::c_char) -> f64,
        ::libloading::Error,
    >,
    pub strtof: Result<
        unsafe extern "C" fn(__nptr: *const ::std::os::raw::c_char, __endptr: *mut *mut ::std::os::raw::c_char) -> f32,
        ::libloading::Error,
    >,
    pub strtold: Result<
        unsafe extern "C" fn(__nptr: *const ::std::os::raw::c_char, __endptr: *mut *mut ::std::os::raw::c_char) -> u128,
        ::libloading::Error,
    >,
    pub strtol: Result<
        unsafe extern "C" fn(
            __nptr: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub strtoul: Result<
        unsafe extern "C" fn(
            __nptr: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong,
        ::libloading::Error,
    >,
    pub strtoq: Result<
        unsafe extern "C" fn(
            __nptr: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub strtouq: Result<
        unsafe extern "C" fn(
            __nptr: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub strtoll: Result<
        unsafe extern "C" fn(
            __nptr: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub strtoull: Result<
        unsafe extern "C" fn(
            __nptr: *const ::std::os::raw::c_char,
            __endptr: *mut *mut ::std::os::raw::c_char,
            __base: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub l64a:
        Result<unsafe extern "C" fn(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char, ::libloading::Error>,
    pub a64l:
        Result<unsafe extern "C" fn(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long, ::libloading::Error>,
    pub select: Result<
        unsafe extern "C" fn(
            __nfds: ::std::os::raw::c_int,
            __readfds: *mut fd_set,
            __writefds: *mut fd_set,
            __exceptfds: *mut fd_set,
            __timeout: *mut timeval,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub pselect: Result<
        unsafe extern "C" fn(
            __nfds: ::std::os::raw::c_int,
            __readfds: *mut fd_set,
            __writefds: *mut fd_set,
            __exceptfds: *mut fd_set,
            __timeout: *const timespec,
            __sigmask: *const __sigset_t,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub random: Result<unsafe extern "C" fn() -> ::std::os::raw::c_long, ::libloading::Error>,
    pub srandom: Result<unsafe extern "C" fn(__seed: ::std::os::raw::c_uint), ::libloading::Error>,
    pub initstate: Result<
        unsafe extern "C" fn(
            __seed: ::std::os::raw::c_uint,
            __statebuf: *mut ::std::os::raw::c_char,
            __statelen: usize,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub setstate: Result<
        unsafe extern "C" fn(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub random_r: Result<
        unsafe extern "C" fn(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub srandom_r: Result<
        unsafe extern "C" fn(__seed: ::std::os::raw::c_uint, __buf: *mut random_data) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub initstate_r: Result<
        unsafe extern "C" fn(
            __seed: ::std::os::raw::c_uint,
            __statebuf: *mut ::std::os::raw::c_char,
            __statelen: usize,
            __buf: *mut random_data,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub setstate_r: Result<
        unsafe extern "C" fn(__statebuf: *mut ::std::os::raw::c_char, __buf: *mut random_data) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub rand: Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub srand: Result<unsafe extern "C" fn(__seed: ::std::os::raw::c_uint), ::libloading::Error>,
    pub rand_r:
        Result<unsafe extern "C" fn(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int, ::libloading::Error>,
    pub drand48: Result<unsafe extern "C" fn() -> f64, ::libloading::Error>,
    pub erand48: Result<unsafe extern "C" fn(__xsubi: *mut ::std::os::raw::c_ushort) -> f64, ::libloading::Error>,
    pub lrand48: Result<unsafe extern "C" fn() -> ::std::os::raw::c_long, ::libloading::Error>,
    pub nrand48: Result<
        unsafe extern "C" fn(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub mrand48: Result<unsafe extern "C" fn() -> ::std::os::raw::c_long, ::libloading::Error>,
    pub jrand48: Result<
        unsafe extern "C" fn(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long,
        ::libloading::Error,
    >,
    pub srand48: Result<unsafe extern "C" fn(__seedval: ::std::os::raw::c_long), ::libloading::Error>,
    pub seed48: Result<
        unsafe extern "C" fn(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort,
        ::libloading::Error,
    >,
    pub lcong48: Result<unsafe extern "C" fn(__param: *mut ::std::os::raw::c_ushort), ::libloading::Error>,
    pub drand48_r: Result<
        unsafe extern "C" fn(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub erand48_r: Result<
        unsafe extern "C" fn(
            __xsubi: *mut ::std::os::raw::c_ushort,
            __buffer: *mut drand48_data,
            __result: *mut f64,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lrand48_r: Result<
        unsafe extern "C" fn(
            __buffer: *mut drand48_data,
            __result: *mut ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub nrand48_r: Result<
        unsafe extern "C" fn(
            __xsubi: *mut ::std::os::raw::c_ushort,
            __buffer: *mut drand48_data,
            __result: *mut ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub mrand48_r: Result<
        unsafe extern "C" fn(
            __buffer: *mut drand48_data,
            __result: *mut ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub jrand48_r: Result<
        unsafe extern "C" fn(
            __xsubi: *mut ::std::os::raw::c_ushort,
            __buffer: *mut drand48_data,
            __result: *mut ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub srand48_r: Result<
        unsafe extern "C" fn(__seedval: ::std::os::raw::c_long, __buffer: *mut drand48_data) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub seed48_r: Result<
        unsafe extern "C" fn(
            __seed16v: *mut ::std::os::raw::c_ushort,
            __buffer: *mut drand48_data,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub lcong48_r: Result<
        unsafe extern "C" fn(
            __param: *mut ::std::os::raw::c_ushort,
            __buffer: *mut drand48_data,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub arc4random: Result<unsafe extern "C" fn() -> __uint32_t, ::libloading::Error>,
    pub arc4random_buf:
        Result<unsafe extern "C" fn(__buf: *mut ::std::os::raw::c_void, __size: usize), ::libloading::Error>,
    pub arc4random_uniform: Result<unsafe extern "C" fn(__upper_bound: __uint32_t) -> __uint32_t, ::libloading::Error>,
    pub malloc: Result<
        unsafe extern "C" fn(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub calloc: Result<
        unsafe extern "C" fn(
            __nmemb: ::std::os::raw::c_ulong,
            __size: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub realloc: Result<
        unsafe extern "C" fn(
            __ptr: *mut ::std::os::raw::c_void,
            __size: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub free: Result<unsafe extern "C" fn(__ptr: *mut ::std::os::raw::c_void), ::libloading::Error>,
    pub reallocarray: Result<
        unsafe extern "C" fn(
            __ptr: *mut ::std::os::raw::c_void,
            __nmemb: usize,
            __size: usize,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub alloca: Result<
        unsafe extern "C" fn(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub valloc: Result<unsafe extern "C" fn(__size: usize) -> *mut ::std::os::raw::c_void, ::libloading::Error>,
    pub posix_memalign: Result<
        unsafe extern "C" fn(
            __memptr: *mut *mut ::std::os::raw::c_void,
            __alignment: usize,
            __size: usize,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub aligned_alloc: Result<
        unsafe extern "C" fn(
            __alignment: ::std::os::raw::c_ulong,
            __size: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub abort: Result<unsafe extern "C" fn() -> !, ::libloading::Error>,
    pub atexit: Result<
        unsafe extern "C" fn(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub at_quick_exit: Result<
        unsafe extern "C" fn(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub on_exit: Result<
        unsafe extern "C" fn(
            __func: ::std::option::Option<
                unsafe extern "C" fn(__status: ::std::os::raw::c_int, __arg: *mut ::std::os::raw::c_void),
            >,
            __arg: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub exit: Result<unsafe extern "C" fn(__status: ::std::os::raw::c_int) -> !, ::libloading::Error>,
    pub quick_exit: Result<unsafe extern "C" fn(__status: ::std::os::raw::c_int) -> !, ::libloading::Error>,
    pub _Exit: Result<unsafe extern "C" fn(__status: ::std::os::raw::c_int) -> !, ::libloading::Error>,
    pub getenv: Result<
        unsafe extern "C" fn(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub putenv: Result<
        unsafe extern "C" fn(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub setenv: Result<
        unsafe extern "C" fn(
            __name: *const ::std::os::raw::c_char,
            __value: *const ::std::os::raw::c_char,
            __replace: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub unsetenv: Result<
        unsafe extern "C" fn(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub clearenv: Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub mktemp: Result<
        unsafe extern "C" fn(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub mkstemp: Result<
        unsafe extern "C" fn(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub mkstemps: Result<
        unsafe extern "C" fn(
            __template: *mut ::std::os::raw::c_char,
            __suffixlen: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub mkdtemp: Result<
        unsafe extern "C" fn(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub system: Result<
        unsafe extern "C" fn(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub realpath: Result<
        unsafe extern "C" fn(
            __name: *const ::std::os::raw::c_char,
            __resolved: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub bsearch: Result<
        unsafe extern "C" fn(
            __key: *const ::std::os::raw::c_void,
            __base: *const ::std::os::raw::c_void,
            __nmemb: usize,
            __size: usize,
            __compar: __compar_fn_t,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub qsort: Result<
        unsafe extern "C" fn(
            __base: *mut ::std::os::raw::c_void,
            __nmemb: usize,
            __size: usize,
            __compar: __compar_fn_t,
        ),
        ::libloading::Error,
    >,
    pub abs: Result<unsafe extern "C" fn(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int, ::libloading::Error>,
    pub labs: Result<unsafe extern "C" fn(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long, ::libloading::Error>,
    pub llabs: Result<
        unsafe extern "C" fn(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub div: Result<
        unsafe extern "C" fn(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t,
        ::libloading::Error,
    >,
    pub ldiv: Result<
        unsafe extern "C" fn(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t,
        ::libloading::Error,
    >,
    pub lldiv: Result<
        unsafe extern "C" fn(__numer: ::std::os::raw::c_longlong, __denom: ::std::os::raw::c_longlong) -> lldiv_t,
        ::libloading::Error,
    >,
    pub ecvt: Result<
        unsafe extern "C" fn(
            __value: f64,
            __ndigit: ::std::os::raw::c_int,
            __decpt: *mut ::std::os::raw::c_int,
            __sign: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub fcvt: Result<
        unsafe extern "C" fn(
            __value: f64,
            __ndigit: ::std::os::raw::c_int,
            __decpt: *mut ::std::os::raw::c_int,
            __sign: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub gcvt: Result<
        unsafe extern "C" fn(
            __value: f64,
            __ndigit: ::std::os::raw::c_int,
            __buf: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub qecvt: Result<
        unsafe extern "C" fn(
            __value: u128,
            __ndigit: ::std::os::raw::c_int,
            __decpt: *mut ::std::os::raw::c_int,
            __sign: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub qfcvt: Result<
        unsafe extern "C" fn(
            __value: u128,
            __ndigit: ::std::os::raw::c_int,
            __decpt: *mut ::std::os::raw::c_int,
            __sign: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub qgcvt: Result<
        unsafe extern "C" fn(
            __value: u128,
            __ndigit: ::std::os::raw::c_int,
            __buf: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub ecvt_r: Result<
        unsafe extern "C" fn(
            __value: f64,
            __ndigit: ::std::os::raw::c_int,
            __decpt: *mut ::std::os::raw::c_int,
            __sign: *mut ::std::os::raw::c_int,
            __buf: *mut ::std::os::raw::c_char,
            __len: usize,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub fcvt_r: Result<
        unsafe extern "C" fn(
            __value: f64,
            __ndigit: ::std::os::raw::c_int,
            __decpt: *mut ::std::os::raw::c_int,
            __sign: *mut ::std::os::raw::c_int,
            __buf: *mut ::std::os::raw::c_char,
            __len: usize,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub qecvt_r: Result<
        unsafe extern "C" fn(
            __value: u128,
            __ndigit: ::std::os::raw::c_int,
            __decpt: *mut ::std::os::raw::c_int,
            __sign: *mut ::std::os::raw::c_int,
            __buf: *mut ::std::os::raw::c_char,
            __len: usize,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub qfcvt_r: Result<
        unsafe extern "C" fn(
            __value: u128,
            __ndigit: ::std::os::raw::c_int,
            __decpt: *mut ::std::os::raw::c_int,
            __sign: *mut ::std::os::raw::c_int,
            __buf: *mut ::std::os::raw::c_char,
            __len: usize,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub mblen: Result<
        unsafe extern "C" fn(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub mbtowc: Result<
        unsafe extern "C" fn(
            __pwc: *mut wchar_t,
            __s: *const ::std::os::raw::c_char,
            __n: usize,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub wctomb: Result<
        unsafe extern "C" fn(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub mbstowcs: Result<
        unsafe extern "C" fn(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize,
        ::libloading::Error,
    >,
    pub wcstombs: Result<
        unsafe extern "C" fn(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize,
        ::libloading::Error,
    >,
    pub rpmatch: Result<
        unsafe extern "C" fn(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub getsubopt: Result<
        unsafe extern "C" fn(
            __optionp: *mut *mut ::std::os::raw::c_char,
            __tokens: *const *mut ::std::os::raw::c_char,
            __valuep: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub getloadavg: Result<
        unsafe extern "C" fn(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub amdsmi_init: Result<unsafe extern "C" fn(init_flags: u64) -> amdsmi_status_t, ::libloading::Error>,
    pub amdsmi_shut_down: Result<unsafe extern "C" fn() -> amdsmi_status_t, ::libloading::Error>,
    pub amdsmi_get_socket_handles: Result<
        unsafe extern "C" fn(socket_count: *mut u32, socket_handles: *mut amdsmi_socket_handle) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_socket_info: Result<
        unsafe extern "C" fn(
            socket_handle: amdsmi_socket_handle,
            len: usize,
            name: *mut ::std::os::raw::c_char,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_processor_handles: Result<
        unsafe extern "C" fn(
            socket_handle: amdsmi_socket_handle,
            processor_count: *mut u32,
            processor_handles: *mut amdsmi_processor_handle,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_node_handle: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            node_handle: *mut amdsmi_node_handle,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_processor_type: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            processor_type: *mut processor_type_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_processor_handle_from_bdf: Result<
        unsafe extern "C" fn(bdf: amdsmi_bdf_t, processor_handle: *mut amdsmi_processor_handle) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_device_bdf: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, bdf: *mut amdsmi_bdf_t) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_device_uuid: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            uuid_length: *mut ::std::os::raw::c_uint,
            uuid: *mut ::std::os::raw::c_char,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_enumeration_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_enumeration_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_cpu_affinity_with_scope: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            cpu_set_size: u32,
            cpu_set: *mut u64,
            scope: amdsmi_affinity_scope_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_virtualization_mode: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            mode: *mut amdsmi_virtualization_mode_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_id: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, id: *mut u16) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_revision: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, revision: *mut u16) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_vendor_name: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            name: *mut ::std::os::raw::c_char,
            len: usize,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_vram_vendor: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            brand: *mut ::std::os::raw::c_char,
            len: u32,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_subsystem_id: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, id: *mut u16) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_subsystem_name: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            name: *mut ::std::os::raw::c_char,
            len: usize,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_pci_bandwidth: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            bandwidth: *mut amdsmi_pcie_bandwidth_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_bdf_id: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, bdfid: *mut u64) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_topo_numa_affinity: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, numa_node: *mut i32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_pci_throughput: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            sent: *mut u64,
            received: *mut u64,
            max_pkt_sz: *mut u64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_pci_replay_counter: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, counter: *mut u64) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_pci_bandwidth: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, bw_bitmask: u64) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_energy_count: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            energy_accumulator: *mut u64,
            counter_resolution: *mut f32,
            timestamp: *mut u64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_power_cap: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, sensor_ind: u32, cap: u64) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_power_profile: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            reserved: u32,
            profile: amdsmi_power_profile_preset_masks_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_supported_power_cap: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            sensor_count: *mut u32,
            sensor_inds: *mut u32,
            sensor_types: *mut amdsmi_power_cap_type_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_cpu_socket_power: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, ppower: *mut u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_cpu_socket_power_cap: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, pcap: *mut u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_cpu_socket_power_cap_max: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, pmax: *mut u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_cpu_pwr_svi_telemetry_all_rails: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, power: *mut u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_cpu_socket_power_cap: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, pcap: u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_cpu_pwr_efficiency_mode: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, mode: u8) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_memory_total: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            mem_type: amdsmi_memory_type_t,
            total: *mut u64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_memory_usage: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            mem_type: amdsmi_memory_type_t,
            used: *mut u64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_bad_page_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            num_pages: *mut u32,
            info: *mut amdsmi_retired_page_record_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_bad_page_threshold: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, threshold: *mut u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_gpu_validate_ras_eeprom:
        Result<unsafe extern "C" fn(processor_handle: amdsmi_processor_handle) -> amdsmi_status_t, ::libloading::Error>,
    pub amdsmi_get_gpu_ras_block_features_enabled: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            block: amdsmi_gpu_block_t,
            state: *mut amdsmi_ras_err_state_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_memory_reserved_pages: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            num_pages: *mut u32,
            records: *mut amdsmi_retired_page_record_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_fan_rpms: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            sensor_ind: u32,
            speed: *mut i64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_fan_speed: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            sensor_ind: u32,
            speed: *mut i64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_fan_speed_max: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            sensor_ind: u32,
            max_speed: *mut u64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_cache_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_gpu_cache_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_volt_metric: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            sensor_type: amdsmi_voltage_type_t,
            metric: amdsmi_voltage_metric_t,
            voltage: *mut i64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_reset_gpu_fan: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, sensor_ind: u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_fan_speed: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, sensor_ind: u32, speed: u64) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_busy_percent: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, gpu_busy_percent: *mut u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_utilization_count: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            utilization_counters: *mut amdsmi_utilization_counter_t,
            count: u32,
            timestamp: *mut u64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_perf_level: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            perf: *mut amdsmi_dev_perf_level_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_perf_determinism_mode: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, clkvalue: u64) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_overdrive_level: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, od: *mut u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_mem_overdrive_level: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, od: *mut u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_clk_freq: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            clk_type: amdsmi_clk_type_t,
            f: *mut amdsmi_frequencies_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_reset_gpu:
        Result<unsafe extern "C" fn(processor_handle: amdsmi_processor_handle) -> amdsmi_status_t, ::libloading::Error>,
    pub amdsmi_get_gpu_od_volt_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            odv: *mut amdsmi_od_volt_freq_data_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_metrics_header_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            header_value: *mut amd_metrics_table_header_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_metrics_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            pgpu_metrics: *mut amdsmi_gpu_metrics_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_partition_metrics_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            pgpu_metrics: *mut amdsmi_gpu_metrics_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_pm_metrics_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            pm_metrics: *mut *mut amdsmi_name_value_t,
            num_of_metrics: *mut u32,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_reg_table_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            reg_type: amdsmi_reg_type_t,
            reg_metrics: *mut *mut amdsmi_name_value_t,
            num_of_metrics: *mut u32,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_clk_range: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            minclkvalue: u64,
            maxclkvalue: u64,
            clkType: amdsmi_clk_type_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_clk_limit: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            clk_type: amdsmi_clk_type_t,
            limit_type: amdsmi_clk_limit_type_t,
            clk_value: u64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_od_clk_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            level: amdsmi_freq_ind_t,
            clkvalue: u64,
            clkType: amdsmi_clk_type_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_od_volt_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            vpoint: u32,
            clkvalue: u64,
            voltvalue: u64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_od_volt_curve_regions: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            num_regions: *mut u32,
            buffer: *mut amdsmi_freq_volt_region_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_power_profile_presets: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            sensor_ind: u32,
            status: *mut amdsmi_power_profile_status_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_perf_level: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            perf_lvl: amdsmi_dev_perf_level_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_overdrive_level: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, od: u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_clk_freq: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            clk_type: amdsmi_clk_type_t,
            freq_bitmask: u64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_soc_pstate: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            policy: *mut amdsmi_dpm_policy_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_soc_pstate: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, policy_id: u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_xgmi_plpd: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            xgmi_plpd: *mut amdsmi_dpm_policy_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_xgmi_plpd: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, policy_id: u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_process_isolation: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, pisolate: *mut u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_process_isolation: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, pisolate: u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_clean_gpu_local_data:
        Result<unsafe extern "C" fn(processor_handle: amdsmi_processor_handle) -> amdsmi_status_t, ::libloading::Error>,
    pub amdsmi_get_lib_version:
        Result<unsafe extern "C" fn(version: *mut amdsmi_version_t) -> amdsmi_status_t, ::libloading::Error>,
    pub amdsmi_get_gpu_ecc_count: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            block: amdsmi_gpu_block_t,
            ec: *mut amdsmi_error_count_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_ecc_enabled: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, enabled_blocks: *mut u64) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_total_ecc_count: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            ec: *mut amdsmi_error_count_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_cper_entries: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            severity_mask: u32,
            cper_data: *mut ::std::os::raw::c_char,
            buf_size: *mut u64,
            cper_hdrs: *mut *mut amdsmi_cper_hdr_t,
            entry_count: *mut u64,
            cursor: *mut u64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_afids_from_cper: Result<
        unsafe extern "C" fn(
            cper_buffer: *mut ::std::os::raw::c_char,
            buf_size: u32,
            afids: *mut u64,
            num_afids: *mut u32,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_ras_feature_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            ras_feature: *mut amdsmi_ras_feature_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_ecc_status: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            block: amdsmi_gpu_block_t,
            state: *mut amdsmi_ras_err_state_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_status_code_to_string: Result<
        unsafe extern "C" fn(
            status: amdsmi_status_t,
            status_string: *mut *const ::std::os::raw::c_char,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_gpu_counter_group_supported: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, group: amdsmi_event_group_t) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_gpu_create_counter: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            type_: amdsmi_event_type_t,
            evnt_handle: *mut amdsmi_event_handle_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_gpu_destroy_counter:
        Result<unsafe extern "C" fn(evnt_handle: amdsmi_event_handle_t) -> amdsmi_status_t, ::libloading::Error>,
    pub amdsmi_gpu_control_counter: Result<
        unsafe extern "C" fn(
            evt_handle: amdsmi_event_handle_t,
            cmd: amdsmi_counter_command_t,
            cmd_args: *mut ::std::os::raw::c_void,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_gpu_read_counter: Result<
        unsafe extern "C" fn(evt_handle: amdsmi_event_handle_t, value: *mut amdsmi_counter_value_t) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_available_counters: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            grp: amdsmi_event_group_t,
            available: *mut u32,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_compute_process_info: Result<
        unsafe extern "C" fn(procs: *mut amdsmi_process_info_t, num_items: *mut u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_compute_process_info_by_pid: Result<
        unsafe extern "C" fn(pid: u32, proc_: *mut amdsmi_process_info_t) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_compute_process_gpus: Result<
        unsafe extern "C" fn(pid: u32, dv_indices: *mut u32, num_devices: *mut u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_gpu_xgmi_error_status: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            status: *mut amdsmi_xgmi_status_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_reset_gpu_xgmi_error:
        Result<unsafe extern "C" fn(processor_handle: amdsmi_processor_handle) -> amdsmi_status_t, ::libloading::Error>,
    pub amdsmi_get_xgmi_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_xgmi_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_xgmi_link_status: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            link_status: *mut amdsmi_xgmi_link_status_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_link_metrics: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            link_metrics: *mut amdsmi_link_metrics_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_topo_get_numa_node_number: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, numa_node: *mut u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_topo_get_link_weight: Result<
        unsafe extern "C" fn(
            processor_handle_src: amdsmi_processor_handle,
            processor_handle_dst: amdsmi_processor_handle,
            weight: *mut u64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_minmax_bandwidth_between_processors: Result<
        unsafe extern "C" fn(
            processor_handle_src: amdsmi_processor_handle,
            processor_handle_dst: amdsmi_processor_handle,
            min_bandwidth: *mut u64,
            max_bandwidth: *mut u64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_topo_get_link_type: Result<
        unsafe extern "C" fn(
            processor_handle_src: amdsmi_processor_handle,
            processor_handle_dst: amdsmi_processor_handle,
            hops: *mut u64,
            type_: *mut amdsmi_link_type_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_link_topology_nearest: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            link_type: amdsmi_link_type_t,
            topology_nearest_info: *mut amdsmi_topology_nearest_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_is_P2P_accessible: Result<
        unsafe extern "C" fn(
            processor_handle_src: amdsmi_processor_handle,
            processor_handle_dst: amdsmi_processor_handle,
            accessible: *mut bool,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_topo_get_p2p_status: Result<
        unsafe extern "C" fn(
            processor_handle_src: amdsmi_processor_handle,
            processor_handle_dst: amdsmi_processor_handle,
            type_: *mut amdsmi_link_type_t,
            cap: *mut amdsmi_p2p_capability_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_compute_partition: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            compute_partition: *mut ::std::os::raw::c_char,
            len: u32,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_compute_partition: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            compute_partition: amdsmi_compute_partition_type_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_memory_partition: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            memory_partition: *mut ::std::os::raw::c_char,
            len: u32,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_memory_partition: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            memory_partition: amdsmi_memory_partition_type_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_memory_partition_config: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            config: *mut amdsmi_memory_partition_config_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_memory_partition_mode: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            mode: amdsmi_memory_partition_type_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_accelerator_partition_profile_config: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            profile_config: *mut amdsmi_accelerator_partition_profile_config_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_accelerator_partition_profile: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            profile: *mut amdsmi_accelerator_partition_profile_t,
            partition_id: *mut u32,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_set_gpu_accelerator_partition_profile: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, profile_index: u32) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_init_gpu_event_notification:
        Result<unsafe extern "C" fn(processor_handle: amdsmi_processor_handle) -> amdsmi_status_t, ::libloading::Error>,
    pub amdsmi_set_gpu_event_notification_mask: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, mask: u64) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_event_notification: Result<
        unsafe extern "C" fn(
            timeout_ms: ::std::os::raw::c_int,
            num_elem: *mut u32,
            data: *mut amdsmi_evt_notification_data_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_stop_gpu_event_notification:
        Result<unsafe extern "C" fn(processor_handle: amdsmi_processor_handle) -> amdsmi_status_t, ::libloading::Error>,
    pub amdsmi_get_gpu_driver_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_driver_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_asic_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_asic_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_kfd_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_kfd_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_vram_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_vram_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_board_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_board_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_power_cap_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            sensor_ind: u32,
            info: *mut amdsmi_power_cap_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_pcie_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_pcie_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_xcd_counter: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, xcd_count: *mut u16) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_npm_info: Result<
        unsafe extern "C" fn(node_handle: amdsmi_node_handle, info: *mut amdsmi_npm_info_t) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_fw_info: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, info: *mut amdsmi_fw_info_t) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_vbios_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_vbios_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_temp_metric: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            sensor_type: amdsmi_temperature_type_t,
            metric: amdsmi_temperature_metric_t,
            temperature: *mut i64,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_activity: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_engine_usage_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_power_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_power_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_is_gpu_power_management_enabled: Result<
        unsafe extern "C" fn(processor_handle: amdsmi_processor_handle, enabled: *mut bool) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_clock_info: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            clk_type: amdsmi_clk_type_t,
            info: *mut amdsmi_clk_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_vram_usage: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_vram_usage_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_violation_status: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            info: *mut amdsmi_violation_status_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_get_gpu_process_list: Result<
        unsafe extern "C" fn(
            processor_handle: amdsmi_processor_handle,
            max_processes: *mut u32,
            list: *mut amdsmi_proc_info_t,
        ) -> amdsmi_status_t,
        ::libloading::Error,
    >,
    pub amdsmi_gpu_driver_reload: Result<unsafe extern "C" fn() -> amdsmi_status_t, ::libloading::Error>,
}
impl libamd_smi {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let __ctype_get_mb_cur_max = __library.get(b"__ctype_get_mb_cur_max\0").map(|sym| *sym);
        let atof = __library.get(b"atof\0").map(|sym| *sym);
        let atoi = __library.get(b"atoi\0").map(|sym| *sym);
        let atol = __library.get(b"atol\0").map(|sym| *sym);
        let atoll = __library.get(b"atoll\0").map(|sym| *sym);
        let strtod = __library.get(b"strtod\0").map(|sym| *sym);
        let strtof = __library.get(b"strtof\0").map(|sym| *sym);
        let strtold = __library.get(b"strtold\0").map(|sym| *sym);
        let strtol = __library.get(b"strtol\0").map(|sym| *sym);
        let strtoul = __library.get(b"strtoul\0").map(|sym| *sym);
        let strtoq = __library.get(b"strtoq\0").map(|sym| *sym);
        let strtouq = __library.get(b"strtouq\0").map(|sym| *sym);
        let strtoll = __library.get(b"strtoll\0").map(|sym| *sym);
        let strtoull = __library.get(b"strtoull\0").map(|sym| *sym);
        let l64a = __library.get(b"l64a\0").map(|sym| *sym);
        let a64l = __library.get(b"a64l\0").map(|sym| *sym);
        let select = __library.get(b"select\0").map(|sym| *sym);
        let pselect = __library.get(b"pselect\0").map(|sym| *sym);
        let random = __library.get(b"random\0").map(|sym| *sym);
        let srandom = __library.get(b"srandom\0").map(|sym| *sym);
        let initstate = __library.get(b"initstate\0").map(|sym| *sym);
        let setstate = __library.get(b"setstate\0").map(|sym| *sym);
        let random_r = __library.get(b"random_r\0").map(|sym| *sym);
        let srandom_r = __library.get(b"srandom_r\0").map(|sym| *sym);
        let initstate_r = __library.get(b"initstate_r\0").map(|sym| *sym);
        let setstate_r = __library.get(b"setstate_r\0").map(|sym| *sym);
        let rand = __library.get(b"rand\0").map(|sym| *sym);
        let srand = __library.get(b"srand\0").map(|sym| *sym);
        let rand_r = __library.get(b"rand_r\0").map(|sym| *sym);
        let drand48 = __library.get(b"drand48\0").map(|sym| *sym);
        let erand48 = __library.get(b"erand48\0").map(|sym| *sym);
        let lrand48 = __library.get(b"lrand48\0").map(|sym| *sym);
        let nrand48 = __library.get(b"nrand48\0").map(|sym| *sym);
        let mrand48 = __library.get(b"mrand48\0").map(|sym| *sym);
        let jrand48 = __library.get(b"jrand48\0").map(|sym| *sym);
        let srand48 = __library.get(b"srand48\0").map(|sym| *sym);
        let seed48 = __library.get(b"seed48\0").map(|sym| *sym);
        let lcong48 = __library.get(b"lcong48\0").map(|sym| *sym);
        let drand48_r = __library.get(b"drand48_r\0").map(|sym| *sym);
        let erand48_r = __library.get(b"erand48_r\0").map(|sym| *sym);
        let lrand48_r = __library.get(b"lrand48_r\0").map(|sym| *sym);
        let nrand48_r = __library.get(b"nrand48_r\0").map(|sym| *sym);
        let mrand48_r = __library.get(b"mrand48_r\0").map(|sym| *sym);
        let jrand48_r = __library.get(b"jrand48_r\0").map(|sym| *sym);
        let srand48_r = __library.get(b"srand48_r\0").map(|sym| *sym);
        let seed48_r = __library.get(b"seed48_r\0").map(|sym| *sym);
        let lcong48_r = __library.get(b"lcong48_r\0").map(|sym| *sym);
        let arc4random = __library.get(b"arc4random\0").map(|sym| *sym);
        let arc4random_buf = __library.get(b"arc4random_buf\0").map(|sym| *sym);
        let arc4random_uniform = __library.get(b"arc4random_uniform\0").map(|sym| *sym);
        let malloc = __library.get(b"malloc\0").map(|sym| *sym);
        let calloc = __library.get(b"calloc\0").map(|sym| *sym);
        let realloc = __library.get(b"realloc\0").map(|sym| *sym);
        let free = __library.get(b"free\0").map(|sym| *sym);
        let reallocarray = __library.get(b"reallocarray\0").map(|sym| *sym);
        let alloca = __library.get(b"alloca\0").map(|sym| *sym);
        let valloc = __library.get(b"valloc\0").map(|sym| *sym);
        let posix_memalign = __library.get(b"posix_memalign\0").map(|sym| *sym);
        let aligned_alloc = __library.get(b"aligned_alloc\0").map(|sym| *sym);
        let abort = __library.get(b"abort\0").map(|sym| *sym);
        let atexit = __library.get(b"atexit\0").map(|sym| *sym);
        let at_quick_exit = __library.get(b"at_quick_exit\0").map(|sym| *sym);
        let on_exit = __library.get(b"on_exit\0").map(|sym| *sym);
        let exit = __library.get(b"exit\0").map(|sym| *sym);
        let quick_exit = __library.get(b"quick_exit\0").map(|sym| *sym);
        let _Exit = __library.get(b"_Exit\0").map(|sym| *sym);
        let getenv = __library.get(b"getenv\0").map(|sym| *sym);
        let putenv = __library.get(b"putenv\0").map(|sym| *sym);
        let setenv = __library.get(b"setenv\0").map(|sym| *sym);
        let unsetenv = __library.get(b"unsetenv\0").map(|sym| *sym);
        let clearenv = __library.get(b"clearenv\0").map(|sym| *sym);
        let mktemp = __library.get(b"mktemp\0").map(|sym| *sym);
        let mkstemp = __library.get(b"mkstemp\0").map(|sym| *sym);
        let mkstemps = __library.get(b"mkstemps\0").map(|sym| *sym);
        let mkdtemp = __library.get(b"mkdtemp\0").map(|sym| *sym);
        let system = __library.get(b"system\0").map(|sym| *sym);
        let realpath = __library.get(b"realpath\0").map(|sym| *sym);
        let bsearch = __library.get(b"bsearch\0").map(|sym| *sym);
        let qsort = __library.get(b"qsort\0").map(|sym| *sym);
        let abs = __library.get(b"abs\0").map(|sym| *sym);
        let labs = __library.get(b"labs\0").map(|sym| *sym);
        let llabs = __library.get(b"llabs\0").map(|sym| *sym);
        let div = __library.get(b"div\0").map(|sym| *sym);
        let ldiv = __library.get(b"ldiv\0").map(|sym| *sym);
        let lldiv = __library.get(b"lldiv\0").map(|sym| *sym);
        let ecvt = __library.get(b"ecvt\0").map(|sym| *sym);
        let fcvt = __library.get(b"fcvt\0").map(|sym| *sym);
        let gcvt = __library.get(b"gcvt\0").map(|sym| *sym);
        let qecvt = __library.get(b"qecvt\0").map(|sym| *sym);
        let qfcvt = __library.get(b"qfcvt\0").map(|sym| *sym);
        let qgcvt = __library.get(b"qgcvt\0").map(|sym| *sym);
        let ecvt_r = __library.get(b"ecvt_r\0").map(|sym| *sym);
        let fcvt_r = __library.get(b"fcvt_r\0").map(|sym| *sym);
        let qecvt_r = __library.get(b"qecvt_r\0").map(|sym| *sym);
        let qfcvt_r = __library.get(b"qfcvt_r\0").map(|sym| *sym);
        let mblen = __library.get(b"mblen\0").map(|sym| *sym);
        let mbtowc = __library.get(b"mbtowc\0").map(|sym| *sym);
        let wctomb = __library.get(b"wctomb\0").map(|sym| *sym);
        let mbstowcs = __library.get(b"mbstowcs\0").map(|sym| *sym);
        let wcstombs = __library.get(b"wcstombs\0").map(|sym| *sym);
        let rpmatch = __library.get(b"rpmatch\0").map(|sym| *sym);
        let getsubopt = __library.get(b"getsubopt\0").map(|sym| *sym);
        let getloadavg = __library.get(b"getloadavg\0").map(|sym| *sym);
        let amdsmi_init = __library.get(b"amdsmi_init\0").map(|sym| *sym);
        let amdsmi_shut_down = __library.get(b"amdsmi_shut_down\0").map(|sym| *sym);
        let amdsmi_get_socket_handles = __library.get(b"amdsmi_get_socket_handles\0").map(|sym| *sym);
        let amdsmi_get_socket_info = __library.get(b"amdsmi_get_socket_info\0").map(|sym| *sym);
        let amdsmi_get_processor_handles = __library.get(b"amdsmi_get_processor_handles\0").map(|sym| *sym);
        let amdsmi_get_node_handle = __library.get(b"amdsmi_get_node_handle\0").map(|sym| *sym);
        let amdsmi_get_processor_type = __library.get(b"amdsmi_get_processor_type\0").map(|sym| *sym);
        let amdsmi_get_processor_handle_from_bdf =
            __library.get(b"amdsmi_get_processor_handle_from_bdf\0").map(|sym| *sym);
        let amdsmi_get_gpu_device_bdf = __library.get(b"amdsmi_get_gpu_device_bdf\0").map(|sym| *sym);
        let amdsmi_get_gpu_device_uuid = __library.get(b"amdsmi_get_gpu_device_uuid\0").map(|sym| *sym);
        let amdsmi_get_gpu_enumeration_info = __library.get(b"amdsmi_get_gpu_enumeration_info\0").map(|sym| *sym);
        let amdsmi_get_cpu_affinity_with_scope = __library.get(b"amdsmi_get_cpu_affinity_with_scope\0").map(|sym| *sym);
        let amdsmi_get_gpu_virtualization_mode = __library.get(b"amdsmi_get_gpu_virtualization_mode\0").map(|sym| *sym);
        let amdsmi_get_gpu_id = __library.get(b"amdsmi_get_gpu_id\0").map(|sym| *sym);
        let amdsmi_get_gpu_revision = __library.get(b"amdsmi_get_gpu_revision\0").map(|sym| *sym);
        let amdsmi_get_gpu_vendor_name = __library.get(b"amdsmi_get_gpu_vendor_name\0").map(|sym| *sym);
        let amdsmi_get_gpu_vram_vendor = __library.get(b"amdsmi_get_gpu_vram_vendor\0").map(|sym| *sym);
        let amdsmi_get_gpu_subsystem_id = __library.get(b"amdsmi_get_gpu_subsystem_id\0").map(|sym| *sym);
        let amdsmi_get_gpu_subsystem_name = __library.get(b"amdsmi_get_gpu_subsystem_name\0").map(|sym| *sym);
        let amdsmi_get_gpu_pci_bandwidth = __library.get(b"amdsmi_get_gpu_pci_bandwidth\0").map(|sym| *sym);
        let amdsmi_get_gpu_bdf_id = __library.get(b"amdsmi_get_gpu_bdf_id\0").map(|sym| *sym);
        let amdsmi_get_gpu_topo_numa_affinity = __library.get(b"amdsmi_get_gpu_topo_numa_affinity\0").map(|sym| *sym);
        let amdsmi_get_gpu_pci_throughput = __library.get(b"amdsmi_get_gpu_pci_throughput\0").map(|sym| *sym);
        let amdsmi_get_gpu_pci_replay_counter = __library.get(b"amdsmi_get_gpu_pci_replay_counter\0").map(|sym| *sym);
        let amdsmi_set_gpu_pci_bandwidth = __library.get(b"amdsmi_set_gpu_pci_bandwidth\0").map(|sym| *sym);
        let amdsmi_get_energy_count = __library.get(b"amdsmi_get_energy_count\0").map(|sym| *sym);
        let amdsmi_set_power_cap = __library.get(b"amdsmi_set_power_cap\0").map(|sym| *sym);
        let amdsmi_set_gpu_power_profile = __library.get(b"amdsmi_set_gpu_power_profile\0").map(|sym| *sym);
        let amdsmi_get_supported_power_cap = __library.get(b"amdsmi_get_supported_power_cap\0").map(|sym| *sym);
        let amdsmi_get_cpu_socket_power = __library.get(b"amdsmi_get_cpu_socket_power\0").map(|sym| *sym);
        let amdsmi_get_cpu_socket_power_cap = __library.get(b"amdsmi_get_cpu_socket_power_cap\0").map(|sym| *sym);
        let amdsmi_get_cpu_socket_power_cap_max =
            __library.get(b"amdsmi_get_cpu_socket_power_cap_max\0").map(|sym| *sym);
        let amdsmi_get_cpu_pwr_svi_telemetry_all_rails = __library
            .get(b"amdsmi_get_cpu_pwr_svi_telemetry_all_rails\0")
            .map(|sym| *sym);
        let amdsmi_set_cpu_socket_power_cap = __library.get(b"amdsmi_set_cpu_socket_power_cap\0").map(|sym| *sym);
        let amdsmi_set_cpu_pwr_efficiency_mode = __library.get(b"amdsmi_set_cpu_pwr_efficiency_mode\0").map(|sym| *sym);
        let amdsmi_get_gpu_memory_total = __library.get(b"amdsmi_get_gpu_memory_total\0").map(|sym| *sym);
        let amdsmi_get_gpu_memory_usage = __library.get(b"amdsmi_get_gpu_memory_usage\0").map(|sym| *sym);
        let amdsmi_get_gpu_bad_page_info = __library.get(b"amdsmi_get_gpu_bad_page_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_bad_page_threshold = __library.get(b"amdsmi_get_gpu_bad_page_threshold\0").map(|sym| *sym);
        let amdsmi_gpu_validate_ras_eeprom = __library.get(b"amdsmi_gpu_validate_ras_eeprom\0").map(|sym| *sym);
        let amdsmi_get_gpu_ras_block_features_enabled = __library
            .get(b"amdsmi_get_gpu_ras_block_features_enabled\0")
            .map(|sym| *sym);
        let amdsmi_get_gpu_memory_reserved_pages =
            __library.get(b"amdsmi_get_gpu_memory_reserved_pages\0").map(|sym| *sym);
        let amdsmi_get_gpu_fan_rpms = __library.get(b"amdsmi_get_gpu_fan_rpms\0").map(|sym| *sym);
        let amdsmi_get_gpu_fan_speed = __library.get(b"amdsmi_get_gpu_fan_speed\0").map(|sym| *sym);
        let amdsmi_get_gpu_fan_speed_max = __library.get(b"amdsmi_get_gpu_fan_speed_max\0").map(|sym| *sym);
        let amdsmi_get_gpu_cache_info = __library.get(b"amdsmi_get_gpu_cache_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_volt_metric = __library.get(b"amdsmi_get_gpu_volt_metric\0").map(|sym| *sym);
        let amdsmi_reset_gpu_fan = __library.get(b"amdsmi_reset_gpu_fan\0").map(|sym| *sym);
        let amdsmi_set_gpu_fan_speed = __library.get(b"amdsmi_set_gpu_fan_speed\0").map(|sym| *sym);
        let amdsmi_get_gpu_busy_percent = __library.get(b"amdsmi_get_gpu_busy_percent\0").map(|sym| *sym);
        let amdsmi_get_utilization_count = __library.get(b"amdsmi_get_utilization_count\0").map(|sym| *sym);
        let amdsmi_get_gpu_perf_level = __library.get(b"amdsmi_get_gpu_perf_level\0").map(|sym| *sym);
        let amdsmi_set_gpu_perf_determinism_mode =
            __library.get(b"amdsmi_set_gpu_perf_determinism_mode\0").map(|sym| *sym);
        let amdsmi_get_gpu_overdrive_level = __library.get(b"amdsmi_get_gpu_overdrive_level\0").map(|sym| *sym);
        let amdsmi_get_gpu_mem_overdrive_level = __library.get(b"amdsmi_get_gpu_mem_overdrive_level\0").map(|sym| *sym);
        let amdsmi_get_clk_freq = __library.get(b"amdsmi_get_clk_freq\0").map(|sym| *sym);
        let amdsmi_reset_gpu = __library.get(b"amdsmi_reset_gpu\0").map(|sym| *sym);
        let amdsmi_get_gpu_od_volt_info = __library.get(b"amdsmi_get_gpu_od_volt_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_metrics_header_info = __library.get(b"amdsmi_get_gpu_metrics_header_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_metrics_info = __library.get(b"amdsmi_get_gpu_metrics_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_partition_metrics_info = __library
            .get(b"amdsmi_get_gpu_partition_metrics_info\0")
            .map(|sym| *sym);
        let amdsmi_get_gpu_pm_metrics_info = __library.get(b"amdsmi_get_gpu_pm_metrics_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_reg_table_info = __library.get(b"amdsmi_get_gpu_reg_table_info\0").map(|sym| *sym);
        let amdsmi_set_gpu_clk_range = __library.get(b"amdsmi_set_gpu_clk_range\0").map(|sym| *sym);
        let amdsmi_set_gpu_clk_limit = __library.get(b"amdsmi_set_gpu_clk_limit\0").map(|sym| *sym);
        let amdsmi_set_gpu_od_clk_info = __library.get(b"amdsmi_set_gpu_od_clk_info\0").map(|sym| *sym);
        let amdsmi_set_gpu_od_volt_info = __library.get(b"amdsmi_set_gpu_od_volt_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_od_volt_curve_regions =
            __library.get(b"amdsmi_get_gpu_od_volt_curve_regions\0").map(|sym| *sym);
        let amdsmi_get_gpu_power_profile_presets =
            __library.get(b"amdsmi_get_gpu_power_profile_presets\0").map(|sym| *sym);
        let amdsmi_set_gpu_perf_level = __library.get(b"amdsmi_set_gpu_perf_level\0").map(|sym| *sym);
        let amdsmi_set_gpu_overdrive_level = __library.get(b"amdsmi_set_gpu_overdrive_level\0").map(|sym| *sym);
        let amdsmi_set_clk_freq = __library.get(b"amdsmi_set_clk_freq\0").map(|sym| *sym);
        let amdsmi_get_soc_pstate = __library.get(b"amdsmi_get_soc_pstate\0").map(|sym| *sym);
        let amdsmi_set_soc_pstate = __library.get(b"amdsmi_set_soc_pstate\0").map(|sym| *sym);
        let amdsmi_get_xgmi_plpd = __library.get(b"amdsmi_get_xgmi_plpd\0").map(|sym| *sym);
        let amdsmi_set_xgmi_plpd = __library.get(b"amdsmi_set_xgmi_plpd\0").map(|sym| *sym);
        let amdsmi_get_gpu_process_isolation = __library.get(b"amdsmi_get_gpu_process_isolation\0").map(|sym| *sym);
        let amdsmi_set_gpu_process_isolation = __library.get(b"amdsmi_set_gpu_process_isolation\0").map(|sym| *sym);
        let amdsmi_clean_gpu_local_data = __library.get(b"amdsmi_clean_gpu_local_data\0").map(|sym| *sym);
        let amdsmi_get_lib_version = __library.get(b"amdsmi_get_lib_version\0").map(|sym| *sym);
        let amdsmi_get_gpu_ecc_count = __library.get(b"amdsmi_get_gpu_ecc_count\0").map(|sym| *sym);
        let amdsmi_get_gpu_ecc_enabled = __library.get(b"amdsmi_get_gpu_ecc_enabled\0").map(|sym| *sym);
        let amdsmi_get_gpu_total_ecc_count = __library.get(b"amdsmi_get_gpu_total_ecc_count\0").map(|sym| *sym);
        let amdsmi_get_gpu_cper_entries = __library.get(b"amdsmi_get_gpu_cper_entries\0").map(|sym| *sym);
        let amdsmi_get_afids_from_cper = __library.get(b"amdsmi_get_afids_from_cper\0").map(|sym| *sym);
        let amdsmi_get_gpu_ras_feature_info = __library.get(b"amdsmi_get_gpu_ras_feature_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_ecc_status = __library.get(b"amdsmi_get_gpu_ecc_status\0").map(|sym| *sym);
        let amdsmi_status_code_to_string = __library.get(b"amdsmi_status_code_to_string\0").map(|sym| *sym);
        let amdsmi_gpu_counter_group_supported = __library.get(b"amdsmi_gpu_counter_group_supported\0").map(|sym| *sym);
        let amdsmi_gpu_create_counter = __library.get(b"amdsmi_gpu_create_counter\0").map(|sym| *sym);
        let amdsmi_gpu_destroy_counter = __library.get(b"amdsmi_gpu_destroy_counter\0").map(|sym| *sym);
        let amdsmi_gpu_control_counter = __library.get(b"amdsmi_gpu_control_counter\0").map(|sym| *sym);
        let amdsmi_gpu_read_counter = __library.get(b"amdsmi_gpu_read_counter\0").map(|sym| *sym);
        let amdsmi_get_gpu_available_counters = __library.get(b"amdsmi_get_gpu_available_counters\0").map(|sym| *sym);
        let amdsmi_get_gpu_compute_process_info =
            __library.get(b"amdsmi_get_gpu_compute_process_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_compute_process_info_by_pid = __library
            .get(b"amdsmi_get_gpu_compute_process_info_by_pid\0")
            .map(|sym| *sym);
        let amdsmi_get_gpu_compute_process_gpus =
            __library.get(b"amdsmi_get_gpu_compute_process_gpus\0").map(|sym| *sym);
        let amdsmi_gpu_xgmi_error_status = __library.get(b"amdsmi_gpu_xgmi_error_status\0").map(|sym| *sym);
        let amdsmi_reset_gpu_xgmi_error = __library.get(b"amdsmi_reset_gpu_xgmi_error\0").map(|sym| *sym);
        let amdsmi_get_xgmi_info = __library.get(b"amdsmi_get_xgmi_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_xgmi_link_status = __library.get(b"amdsmi_get_gpu_xgmi_link_status\0").map(|sym| *sym);
        let amdsmi_get_link_metrics = __library.get(b"amdsmi_get_link_metrics\0").map(|sym| *sym);
        let amdsmi_topo_get_numa_node_number = __library.get(b"amdsmi_topo_get_numa_node_number\0").map(|sym| *sym);
        let amdsmi_topo_get_link_weight = __library.get(b"amdsmi_topo_get_link_weight\0").map(|sym| *sym);
        let amdsmi_get_minmax_bandwidth_between_processors = __library
            .get(b"amdsmi_get_minmax_bandwidth_between_processors\0")
            .map(|sym| *sym);
        let amdsmi_topo_get_link_type = __library.get(b"amdsmi_topo_get_link_type\0").map(|sym| *sym);
        let amdsmi_get_link_topology_nearest = __library.get(b"amdsmi_get_link_topology_nearest\0").map(|sym| *sym);
        let amdsmi_is_P2P_accessible = __library.get(b"amdsmi_is_P2P_accessible\0").map(|sym| *sym);
        let amdsmi_topo_get_p2p_status = __library.get(b"amdsmi_topo_get_p2p_status\0").map(|sym| *sym);
        let amdsmi_get_gpu_compute_partition = __library.get(b"amdsmi_get_gpu_compute_partition\0").map(|sym| *sym);
        let amdsmi_set_gpu_compute_partition = __library.get(b"amdsmi_set_gpu_compute_partition\0").map(|sym| *sym);
        let amdsmi_get_gpu_memory_partition = __library.get(b"amdsmi_get_gpu_memory_partition\0").map(|sym| *sym);
        let amdsmi_set_gpu_memory_partition = __library.get(b"amdsmi_set_gpu_memory_partition\0").map(|sym| *sym);
        let amdsmi_get_gpu_memory_partition_config = __library
            .get(b"amdsmi_get_gpu_memory_partition_config\0")
            .map(|sym| *sym);
        let amdsmi_set_gpu_memory_partition_mode =
            __library.get(b"amdsmi_set_gpu_memory_partition_mode\0").map(|sym| *sym);
        let amdsmi_get_gpu_accelerator_partition_profile_config = __library
            .get(b"amdsmi_get_gpu_accelerator_partition_profile_config\0")
            .map(|sym| *sym);
        let amdsmi_get_gpu_accelerator_partition_profile = __library
            .get(b"amdsmi_get_gpu_accelerator_partition_profile\0")
            .map(|sym| *sym);
        let amdsmi_set_gpu_accelerator_partition_profile = __library
            .get(b"amdsmi_set_gpu_accelerator_partition_profile\0")
            .map(|sym| *sym);
        let amdsmi_init_gpu_event_notification = __library.get(b"amdsmi_init_gpu_event_notification\0").map(|sym| *sym);
        let amdsmi_set_gpu_event_notification_mask = __library
            .get(b"amdsmi_set_gpu_event_notification_mask\0")
            .map(|sym| *sym);
        let amdsmi_get_gpu_event_notification = __library.get(b"amdsmi_get_gpu_event_notification\0").map(|sym| *sym);
        let amdsmi_stop_gpu_event_notification = __library.get(b"amdsmi_stop_gpu_event_notification\0").map(|sym| *sym);
        let amdsmi_get_gpu_driver_info = __library.get(b"amdsmi_get_gpu_driver_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_asic_info = __library.get(b"amdsmi_get_gpu_asic_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_kfd_info = __library.get(b"amdsmi_get_gpu_kfd_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_vram_info = __library.get(b"amdsmi_get_gpu_vram_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_board_info = __library.get(b"amdsmi_get_gpu_board_info\0").map(|sym| *sym);
        let amdsmi_get_power_cap_info = __library.get(b"amdsmi_get_power_cap_info\0").map(|sym| *sym);
        let amdsmi_get_pcie_info = __library.get(b"amdsmi_get_pcie_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_xcd_counter = __library.get(b"amdsmi_get_gpu_xcd_counter\0").map(|sym| *sym);
        let amdsmi_get_npm_info = __library.get(b"amdsmi_get_npm_info\0").map(|sym| *sym);
        let amdsmi_get_fw_info = __library.get(b"amdsmi_get_fw_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_vbios_info = __library.get(b"amdsmi_get_gpu_vbios_info\0").map(|sym| *sym);
        let amdsmi_get_temp_metric = __library.get(b"amdsmi_get_temp_metric\0").map(|sym| *sym);
        let amdsmi_get_gpu_activity = __library.get(b"amdsmi_get_gpu_activity\0").map(|sym| *sym);
        let amdsmi_get_power_info = __library.get(b"amdsmi_get_power_info\0").map(|sym| *sym);
        let amdsmi_is_gpu_power_management_enabled = __library
            .get(b"amdsmi_is_gpu_power_management_enabled\0")
            .map(|sym| *sym);
        let amdsmi_get_clock_info = __library.get(b"amdsmi_get_clock_info\0").map(|sym| *sym);
        let amdsmi_get_gpu_vram_usage = __library.get(b"amdsmi_get_gpu_vram_usage\0").map(|sym| *sym);
        let amdsmi_get_violation_status = __library.get(b"amdsmi_get_violation_status\0").map(|sym| *sym);
        let amdsmi_get_gpu_process_list = __library.get(b"amdsmi_get_gpu_process_list\0").map(|sym| *sym);
        let amdsmi_gpu_driver_reload = __library.get(b"amdsmi_gpu_driver_reload\0").map(|sym| *sym);
        Ok(libamd_smi {
            __library,
            __ctype_get_mb_cur_max,
            atof,
            atoi,
            atol,
            atoll,
            strtod,
            strtof,
            strtold,
            strtol,
            strtoul,
            strtoq,
            strtouq,
            strtoll,
            strtoull,
            l64a,
            a64l,
            select,
            pselect,
            random,
            srandom,
            initstate,
            setstate,
            random_r,
            srandom_r,
            initstate_r,
            setstate_r,
            rand,
            srand,
            rand_r,
            drand48,
            erand48,
            lrand48,
            nrand48,
            mrand48,
            jrand48,
            srand48,
            seed48,
            lcong48,
            drand48_r,
            erand48_r,
            lrand48_r,
            nrand48_r,
            mrand48_r,
            jrand48_r,
            srand48_r,
            seed48_r,
            lcong48_r,
            arc4random,
            arc4random_buf,
            arc4random_uniform,
            malloc,
            calloc,
            realloc,
            free,
            reallocarray,
            alloca,
            valloc,
            posix_memalign,
            aligned_alloc,
            abort,
            atexit,
            at_quick_exit,
            on_exit,
            exit,
            quick_exit,
            _Exit,
            getenv,
            putenv,
            setenv,
            unsetenv,
            clearenv,
            mktemp,
            mkstemp,
            mkstemps,
            mkdtemp,
            system,
            realpath,
            bsearch,
            qsort,
            abs,
            labs,
            llabs,
            div,
            ldiv,
            lldiv,
            ecvt,
            fcvt,
            gcvt,
            qecvt,
            qfcvt,
            qgcvt,
            ecvt_r,
            fcvt_r,
            qecvt_r,
            qfcvt_r,
            mblen,
            mbtowc,
            wctomb,
            mbstowcs,
            wcstombs,
            rpmatch,
            getsubopt,
            getloadavg,
            amdsmi_init,
            amdsmi_shut_down,
            amdsmi_get_socket_handles,
            amdsmi_get_socket_info,
            amdsmi_get_processor_handles,
            amdsmi_get_node_handle,
            amdsmi_get_processor_type,
            amdsmi_get_processor_handle_from_bdf,
            amdsmi_get_gpu_device_bdf,
            amdsmi_get_gpu_device_uuid,
            amdsmi_get_gpu_enumeration_info,
            amdsmi_get_cpu_affinity_with_scope,
            amdsmi_get_gpu_virtualization_mode,
            amdsmi_get_gpu_id,
            amdsmi_get_gpu_revision,
            amdsmi_get_gpu_vendor_name,
            amdsmi_get_gpu_vram_vendor,
            amdsmi_get_gpu_subsystem_id,
            amdsmi_get_gpu_subsystem_name,
            amdsmi_get_gpu_pci_bandwidth,
            amdsmi_get_gpu_bdf_id,
            amdsmi_get_gpu_topo_numa_affinity,
            amdsmi_get_gpu_pci_throughput,
            amdsmi_get_gpu_pci_replay_counter,
            amdsmi_set_gpu_pci_bandwidth,
            amdsmi_get_energy_count,
            amdsmi_set_power_cap,
            amdsmi_set_gpu_power_profile,
            amdsmi_get_supported_power_cap,
            amdsmi_get_cpu_socket_power,
            amdsmi_get_cpu_socket_power_cap,
            amdsmi_get_cpu_socket_power_cap_max,
            amdsmi_get_cpu_pwr_svi_telemetry_all_rails,
            amdsmi_set_cpu_socket_power_cap,
            amdsmi_set_cpu_pwr_efficiency_mode,
            amdsmi_get_gpu_memory_total,
            amdsmi_get_gpu_memory_usage,
            amdsmi_get_gpu_bad_page_info,
            amdsmi_get_gpu_bad_page_threshold,
            amdsmi_gpu_validate_ras_eeprom,
            amdsmi_get_gpu_ras_block_features_enabled,
            amdsmi_get_gpu_memory_reserved_pages,
            amdsmi_get_gpu_fan_rpms,
            amdsmi_get_gpu_fan_speed,
            amdsmi_get_gpu_fan_speed_max,
            amdsmi_get_gpu_cache_info,
            amdsmi_get_gpu_volt_metric,
            amdsmi_reset_gpu_fan,
            amdsmi_set_gpu_fan_speed,
            amdsmi_get_gpu_busy_percent,
            amdsmi_get_utilization_count,
            amdsmi_get_gpu_perf_level,
            amdsmi_set_gpu_perf_determinism_mode,
            amdsmi_get_gpu_overdrive_level,
            amdsmi_get_gpu_mem_overdrive_level,
            amdsmi_get_clk_freq,
            amdsmi_reset_gpu,
            amdsmi_get_gpu_od_volt_info,
            amdsmi_get_gpu_metrics_header_info,
            amdsmi_get_gpu_metrics_info,
            amdsmi_get_gpu_partition_metrics_info,
            amdsmi_get_gpu_pm_metrics_info,
            amdsmi_get_gpu_reg_table_info,
            amdsmi_set_gpu_clk_range,
            amdsmi_set_gpu_clk_limit,
            amdsmi_set_gpu_od_clk_info,
            amdsmi_set_gpu_od_volt_info,
            amdsmi_get_gpu_od_volt_curve_regions,
            amdsmi_get_gpu_power_profile_presets,
            amdsmi_set_gpu_perf_level,
            amdsmi_set_gpu_overdrive_level,
            amdsmi_set_clk_freq,
            amdsmi_get_soc_pstate,
            amdsmi_set_soc_pstate,
            amdsmi_get_xgmi_plpd,
            amdsmi_set_xgmi_plpd,
            amdsmi_get_gpu_process_isolation,
            amdsmi_set_gpu_process_isolation,
            amdsmi_clean_gpu_local_data,
            amdsmi_get_lib_version,
            amdsmi_get_gpu_ecc_count,
            amdsmi_get_gpu_ecc_enabled,
            amdsmi_get_gpu_total_ecc_count,
            amdsmi_get_gpu_cper_entries,
            amdsmi_get_afids_from_cper,
            amdsmi_get_gpu_ras_feature_info,
            amdsmi_get_gpu_ecc_status,
            amdsmi_status_code_to_string,
            amdsmi_gpu_counter_group_supported,
            amdsmi_gpu_create_counter,
            amdsmi_gpu_destroy_counter,
            amdsmi_gpu_control_counter,
            amdsmi_gpu_read_counter,
            amdsmi_get_gpu_available_counters,
            amdsmi_get_gpu_compute_process_info,
            amdsmi_get_gpu_compute_process_info_by_pid,
            amdsmi_get_gpu_compute_process_gpus,
            amdsmi_gpu_xgmi_error_status,
            amdsmi_reset_gpu_xgmi_error,
            amdsmi_get_xgmi_info,
            amdsmi_get_gpu_xgmi_link_status,
            amdsmi_get_link_metrics,
            amdsmi_topo_get_numa_node_number,
            amdsmi_topo_get_link_weight,
            amdsmi_get_minmax_bandwidth_between_processors,
            amdsmi_topo_get_link_type,
            amdsmi_get_link_topology_nearest,
            amdsmi_is_P2P_accessible,
            amdsmi_topo_get_p2p_status,
            amdsmi_get_gpu_compute_partition,
            amdsmi_set_gpu_compute_partition,
            amdsmi_get_gpu_memory_partition,
            amdsmi_set_gpu_memory_partition,
            amdsmi_get_gpu_memory_partition_config,
            amdsmi_set_gpu_memory_partition_mode,
            amdsmi_get_gpu_accelerator_partition_profile_config,
            amdsmi_get_gpu_accelerator_partition_profile,
            amdsmi_set_gpu_accelerator_partition_profile,
            amdsmi_init_gpu_event_notification,
            amdsmi_set_gpu_event_notification_mask,
            amdsmi_get_gpu_event_notification,
            amdsmi_stop_gpu_event_notification,
            amdsmi_get_gpu_driver_info,
            amdsmi_get_gpu_asic_info,
            amdsmi_get_gpu_kfd_info,
            amdsmi_get_gpu_vram_info,
            amdsmi_get_gpu_board_info,
            amdsmi_get_power_cap_info,
            amdsmi_get_pcie_info,
            amdsmi_get_gpu_xcd_counter,
            amdsmi_get_npm_info,
            amdsmi_get_fw_info,
            amdsmi_get_gpu_vbios_info,
            amdsmi_get_temp_metric,
            amdsmi_get_gpu_activity,
            amdsmi_get_power_info,
            amdsmi_is_gpu_power_management_enabled,
            amdsmi_get_clock_info,
            amdsmi_get_gpu_vram_usage,
            amdsmi_get_violation_status,
            amdsmi_get_gpu_process_list,
            amdsmi_gpu_driver_reload,
        })
    }
    pub unsafe fn __ctype_get_mb_cur_max(&self) -> usize {
        (self
            .__ctype_get_mb_cur_max
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn atof(&self, __nptr: *const ::std::os::raw::c_char) -> f64 {
        (self.atof.as_ref().expect("Expected function, got error."))(__nptr)
    }
    pub unsafe fn atoi(&self, __nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
        (self.atoi.as_ref().expect("Expected function, got error."))(__nptr)
    }
    pub unsafe fn atol(&self, __nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long {
        (self.atol.as_ref().expect("Expected function, got error."))(__nptr)
    }
    pub unsafe fn atoll(&self, __nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong {
        (self.atoll.as_ref().expect("Expected function, got error."))(__nptr)
    }
    pub unsafe fn strtod(
        &self,
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64 {
        (self.strtod.as_ref().expect("Expected function, got error."))(__nptr, __endptr)
    }
    pub unsafe fn strtof(
        &self,
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32 {
        (self.strtof.as_ref().expect("Expected function, got error."))(__nptr, __endptr)
    }
    pub unsafe fn strtold(
        &self,
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128 {
        (self.strtold.as_ref().expect("Expected function, got error."))(__nptr, __endptr)
    }
    pub unsafe fn strtol(
        &self,
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long {
        (self.strtol.as_ref().expect("Expected function, got error."))(__nptr, __endptr, __base)
    }
    pub unsafe fn strtoul(
        &self,
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong {
        (self.strtoul.as_ref().expect("Expected function, got error."))(__nptr, __endptr, __base)
    }
    pub unsafe fn strtoq(
        &self,
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong {
        (self.strtoq.as_ref().expect("Expected function, got error."))(__nptr, __endptr, __base)
    }
    pub unsafe fn strtouq(
        &self,
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong {
        (self.strtouq.as_ref().expect("Expected function, got error."))(__nptr, __endptr, __base)
    }
    pub unsafe fn strtoll(
        &self,
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong {
        (self.strtoll.as_ref().expect("Expected function, got error."))(__nptr, __endptr, __base)
    }
    pub unsafe fn strtoull(
        &self,
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong {
        (self.strtoull.as_ref().expect("Expected function, got error."))(__nptr, __endptr, __base)
    }
    pub unsafe fn l64a(&self, __n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char {
        (self.l64a.as_ref().expect("Expected function, got error."))(__n)
    }
    pub unsafe fn a64l(&self, __s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long {
        (self.a64l.as_ref().expect("Expected function, got error."))(__s)
    }
    pub unsafe fn select(
        &self,
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int {
        (self.select.as_ref().expect("Expected function, got error."))(
            __nfds,
            __readfds,
            __writefds,
            __exceptfds,
            __timeout,
        )
    }
    pub unsafe fn pselect(
        &self,
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int {
        (self.pselect.as_ref().expect("Expected function, got error."))(
            __nfds,
            __readfds,
            __writefds,
            __exceptfds,
            __timeout,
            __sigmask,
        )
    }
    pub unsafe fn random(&self) -> ::std::os::raw::c_long {
        (self.random.as_ref().expect("Expected function, got error."))()
    }
    pub unsafe fn srandom(&self, __seed: ::std::os::raw::c_uint) {
        (self.srandom.as_ref().expect("Expected function, got error."))(__seed)
    }
    pub unsafe fn initstate(
        &self,
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char {
        (self.initstate.as_ref().expect("Expected function, got error."))(__seed, __statebuf, __statelen)
    }
    pub unsafe fn setstate(&self, __statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
        (self.setstate.as_ref().expect("Expected function, got error."))(__statebuf)
    }
    pub unsafe fn random_r(&self, __buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int {
        (self.random_r.as_ref().expect("Expected function, got error."))(__buf, __result)
    }
    pub unsafe fn srandom_r(&self, __seed: ::std::os::raw::c_uint, __buf: *mut random_data) -> ::std::os::raw::c_int {
        (self.srandom_r.as_ref().expect("Expected function, got error."))(__seed, __buf)
    }
    pub unsafe fn initstate_r(
        &self,
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int {
        (self.initstate_r.as_ref().expect("Expected function, got error."))(__seed, __statebuf, __statelen, __buf)
    }
    pub unsafe fn setstate_r(
        &self,
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int {
        (self.setstate_r.as_ref().expect("Expected function, got error."))(__statebuf, __buf)
    }
    pub unsafe fn rand(&self) -> ::std::os::raw::c_int {
        (self.rand.as_ref().expect("Expected function, got error."))()
    }
    pub unsafe fn srand(&self, __seed: ::std::os::raw::c_uint) {
        (self.srand.as_ref().expect("Expected function, got error."))(__seed)
    }
    pub unsafe fn rand_r(&self, __seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int {
        (self.rand_r.as_ref().expect("Expected function, got error."))(__seed)
    }
    pub unsafe fn drand48(&self) -> f64 {
        (self.drand48.as_ref().expect("Expected function, got error."))()
    }
    pub unsafe fn erand48(&self, __xsubi: *mut ::std::os::raw::c_ushort) -> f64 {
        (self.erand48.as_ref().expect("Expected function, got error."))(__xsubi)
    }
    pub unsafe fn lrand48(&self) -> ::std::os::raw::c_long {
        (self.lrand48.as_ref().expect("Expected function, got error."))()
    }
    pub unsafe fn nrand48(&self, __xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long {
        (self.nrand48.as_ref().expect("Expected function, got error."))(__xsubi)
    }
    pub unsafe fn mrand48(&self) -> ::std::os::raw::c_long {
        (self.mrand48.as_ref().expect("Expected function, got error."))()
    }
    pub unsafe fn jrand48(&self, __xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long {
        (self.jrand48.as_ref().expect("Expected function, got error."))(__xsubi)
    }
    pub unsafe fn srand48(&self, __seedval: ::std::os::raw::c_long) {
        (self.srand48.as_ref().expect("Expected function, got error."))(__seedval)
    }
    pub unsafe fn seed48(&self, __seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort {
        (self.seed48.as_ref().expect("Expected function, got error."))(__seed16v)
    }
    pub unsafe fn lcong48(&self, __param: *mut ::std::os::raw::c_ushort) {
        (self.lcong48.as_ref().expect("Expected function, got error."))(__param)
    }
    pub unsafe fn drand48_r(&self, __buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int {
        (self.drand48_r.as_ref().expect("Expected function, got error."))(__buffer, __result)
    }
    pub unsafe fn erand48_r(
        &self,
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int {
        (self.erand48_r.as_ref().expect("Expected function, got error."))(__xsubi, __buffer, __result)
    }
    pub unsafe fn lrand48_r(
        &self,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int {
        (self.lrand48_r.as_ref().expect("Expected function, got error."))(__buffer, __result)
    }
    pub unsafe fn nrand48_r(
        &self,
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int {
        (self.nrand48_r.as_ref().expect("Expected function, got error."))(__xsubi, __buffer, __result)
    }
    pub unsafe fn mrand48_r(
        &self,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int {
        (self.mrand48_r.as_ref().expect("Expected function, got error."))(__buffer, __result)
    }
    pub unsafe fn jrand48_r(
        &self,
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int {
        (self.jrand48_r.as_ref().expect("Expected function, got error."))(__xsubi, __buffer, __result)
    }
    pub unsafe fn srand48_r(
        &self,
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int {
        (self.srand48_r.as_ref().expect("Expected function, got error."))(__seedval, __buffer)
    }
    pub unsafe fn seed48_r(
        &self,
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int {
        (self.seed48_r.as_ref().expect("Expected function, got error."))(__seed16v, __buffer)
    }
    pub unsafe fn lcong48_r(
        &self,
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int {
        (self.lcong48_r.as_ref().expect("Expected function, got error."))(__param, __buffer)
    }
    pub unsafe fn arc4random(&self) -> __uint32_t {
        (self.arc4random.as_ref().expect("Expected function, got error."))()
    }
    pub unsafe fn arc4random_buf(&self, __buf: *mut ::std::os::raw::c_void, __size: usize) {
        (self.arc4random_buf.as_ref().expect("Expected function, got error."))(__buf, __size)
    }
    pub unsafe fn arc4random_uniform(&self, __upper_bound: __uint32_t) -> __uint32_t {
        (self.arc4random_uniform.as_ref().expect("Expected function, got error."))(__upper_bound)
    }
    pub unsafe fn malloc(&self, __size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void {
        (self.malloc.as_ref().expect("Expected function, got error."))(__size)
    }
    pub unsafe fn calloc(
        &self,
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void {
        (self.calloc.as_ref().expect("Expected function, got error."))(__nmemb, __size)
    }
    pub unsafe fn realloc(
        &self,
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void {
        (self.realloc.as_ref().expect("Expected function, got error."))(__ptr, __size)
    }
    pub unsafe fn free(&self, __ptr: *mut ::std::os::raw::c_void) {
        (self.free.as_ref().expect("Expected function, got error."))(__ptr)
    }
    pub unsafe fn reallocarray(
        &self,
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void {
        (self.reallocarray.as_ref().expect("Expected function, got error."))(__ptr, __nmemb, __size)
    }
    pub unsafe fn alloca(&self, __size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void {
        (self.alloca.as_ref().expect("Expected function, got error."))(__size)
    }
    pub unsafe fn valloc(&self, __size: usize) -> *mut ::std::os::raw::c_void {
        (self.valloc.as_ref().expect("Expected function, got error."))(__size)
    }
    pub unsafe fn posix_memalign(
        &self,
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int {
        (self.posix_memalign.as_ref().expect("Expected function, got error."))(__memptr, __alignment, __size)
    }
    pub unsafe fn aligned_alloc(
        &self,
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void {
        (self.aligned_alloc.as_ref().expect("Expected function, got error."))(__alignment, __size)
    }
    pub unsafe fn abort(&self) -> ! {
        (self.abort.as_ref().expect("Expected function, got error."))()
    }
    pub unsafe fn atexit(&self, __func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int {
        (self.atexit.as_ref().expect("Expected function, got error."))(__func)
    }
    pub unsafe fn at_quick_exit(&self, __func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int {
        (self.at_quick_exit.as_ref().expect("Expected function, got error."))(__func)
    }
    pub unsafe fn on_exit(
        &self,
        __func: ::std::option::Option<
            unsafe extern "C" fn(__status: ::std::os::raw::c_int, __arg: *mut ::std::os::raw::c_void),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        (self.on_exit.as_ref().expect("Expected function, got error."))(__func, __arg)
    }
    pub unsafe fn exit(&self, __status: ::std::os::raw::c_int) -> ! {
        (self.exit.as_ref().expect("Expected function, got error."))(__status)
    }
    pub unsafe fn quick_exit(&self, __status: ::std::os::raw::c_int) -> ! {
        (self.quick_exit.as_ref().expect("Expected function, got error."))(__status)
    }
    pub unsafe fn _Exit(&self, __status: ::std::os::raw::c_int) -> ! {
        (self._Exit.as_ref().expect("Expected function, got error."))(__status)
    }
    pub unsafe fn getenv(&self, __name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
        (self.getenv.as_ref().expect("Expected function, got error."))(__name)
    }
    pub unsafe fn putenv(&self, __string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int {
        (self.putenv.as_ref().expect("Expected function, got error."))(__string)
    }
    pub unsafe fn setenv(
        &self,
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.setenv.as_ref().expect("Expected function, got error."))(__name, __value, __replace)
    }
    pub unsafe fn unsetenv(&self, __name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
        (self.unsetenv.as_ref().expect("Expected function, got error."))(__name)
    }
    pub unsafe fn clearenv(&self) -> ::std::os::raw::c_int {
        (self.clearenv.as_ref().expect("Expected function, got error."))()
    }
    pub unsafe fn mktemp(&self, __template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
        (self.mktemp.as_ref().expect("Expected function, got error."))(__template)
    }
    pub unsafe fn mkstemp(&self, __template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int {
        (self.mkstemp.as_ref().expect("Expected function, got error."))(__template)
    }
    pub unsafe fn mkstemps(
        &self,
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.mkstemps.as_ref().expect("Expected function, got error."))(__template, __suffixlen)
    }
    pub unsafe fn mkdtemp(&self, __template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
        (self.mkdtemp.as_ref().expect("Expected function, got error."))(__template)
    }
    pub unsafe fn system(&self, __command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
        (self.system.as_ref().expect("Expected function, got error."))(__command)
    }
    pub unsafe fn realpath(
        &self,
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        (self.realpath.as_ref().expect("Expected function, got error."))(__name, __resolved)
    }
    pub unsafe fn bsearch(
        &self,
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void {
        (self.bsearch.as_ref().expect("Expected function, got error."))(__key, __base, __nmemb, __size, __compar)
    }
    pub unsafe fn qsort(
        &self,
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) {
        (self.qsort.as_ref().expect("Expected function, got error."))(__base, __nmemb, __size, __compar)
    }
    pub unsafe fn abs(&self, __x: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        (self.abs.as_ref().expect("Expected function, got error."))(__x)
    }
    pub unsafe fn labs(&self, __x: ::std::os::raw::c_long) -> ::std::os::raw::c_long {
        (self.labs.as_ref().expect("Expected function, got error."))(__x)
    }
    pub unsafe fn llabs(&self, __x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong {
        (self.llabs.as_ref().expect("Expected function, got error."))(__x)
    }
    pub unsafe fn div(&self, __numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t {
        (self.div.as_ref().expect("Expected function, got error."))(__numer, __denom)
    }
    pub unsafe fn ldiv(&self, __numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t {
        (self.ldiv.as_ref().expect("Expected function, got error."))(__numer, __denom)
    }
    pub unsafe fn lldiv(&self, __numer: ::std::os::raw::c_longlong, __denom: ::std::os::raw::c_longlong) -> lldiv_t {
        (self.lldiv.as_ref().expect("Expected function, got error."))(__numer, __denom)
    }
    pub unsafe fn ecvt(
        &self,
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self.ecvt.as_ref().expect("Expected function, got error."))(__value, __ndigit, __decpt, __sign)
    }
    pub unsafe fn fcvt(
        &self,
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self.fcvt.as_ref().expect("Expected function, got error."))(__value, __ndigit, __decpt, __sign)
    }
    pub unsafe fn gcvt(
        &self,
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        (self.gcvt.as_ref().expect("Expected function, got error."))(__value, __ndigit, __buf)
    }
    pub unsafe fn qecvt(
        &self,
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self.qecvt.as_ref().expect("Expected function, got error."))(__value, __ndigit, __decpt, __sign)
    }
    pub unsafe fn qfcvt(
        &self,
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        (self.qfcvt.as_ref().expect("Expected function, got error."))(__value, __ndigit, __decpt, __sign)
    }
    pub unsafe fn qgcvt(
        &self,
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        (self.qgcvt.as_ref().expect("Expected function, got error."))(__value, __ndigit, __buf)
    }
    pub unsafe fn ecvt_r(
        &self,
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int {
        (self.ecvt_r.as_ref().expect("Expected function, got error."))(__value, __ndigit, __decpt, __sign, __buf, __len)
    }
    pub unsafe fn fcvt_r(
        &self,
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int {
        (self.fcvt_r.as_ref().expect("Expected function, got error."))(__value, __ndigit, __decpt, __sign, __buf, __len)
    }
    pub unsafe fn qecvt_r(
        &self,
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int {
        (self.qecvt_r.as_ref().expect("Expected function, got error."))(
            __value, __ndigit, __decpt, __sign, __buf, __len,
        )
    }
    pub unsafe fn qfcvt_r(
        &self,
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int {
        (self.qfcvt_r.as_ref().expect("Expected function, got error."))(
            __value, __ndigit, __decpt, __sign, __buf, __len,
        )
    }
    pub unsafe fn mblen(&self, __s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int {
        (self.mblen.as_ref().expect("Expected function, got error."))(__s, __n)
    }
    pub unsafe fn mbtowc(
        &self,
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int {
        (self.mbtowc.as_ref().expect("Expected function, got error."))(__pwc, __s, __n)
    }
    pub unsafe fn wctomb(&self, __s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int {
        (self.wctomb.as_ref().expect("Expected function, got error."))(__s, __wchar)
    }
    pub unsafe fn mbstowcs(&self, __pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize {
        (self.mbstowcs.as_ref().expect("Expected function, got error."))(__pwcs, __s, __n)
    }
    pub unsafe fn wcstombs(&self, __s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize {
        (self.wcstombs.as_ref().expect("Expected function, got error."))(__s, __pwcs, __n)
    }
    pub unsafe fn rpmatch(&self, __response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
        (self.rpmatch.as_ref().expect("Expected function, got error."))(__response)
    }
    pub unsafe fn getsubopt(
        &self,
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.getsubopt.as_ref().expect("Expected function, got error."))(__optionp, __tokens, __valuep)
    }
    pub unsafe fn getloadavg(&self, __loadavg: *mut f64, __nelem: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        (self.getloadavg.as_ref().expect("Expected function, got error."))(__loadavg, __nelem)
    }
    #[doc = "  @brief Initialize the AMD SMI library\n\n  @ingroup tagInitShutdown\n\n  @platform{gpu_bm_linux} @platform{host} @platform{cpu_bm} @platform{guest_1vf}\n  @platform{guest_mvf} @platform{guest_windows}\n\n  @details This function initializes the library and the internal data structures,\n  including those corresponding to sources of information that SMI provides.\n  Singleton Design, requires the same number of inits as shutdowns.\n\n  The @p init_flags decides which type of processor\n  can be discovered by ::amdsmi_get_socket_handles(). AMDSMI_INIT_AMD_GPUS returns\n  sockets with AMD GPUS, and AMDSMI_INIT_AMD_GPUS | AMDSMI_INIT_AMD_CPUS returns\n  sockets with either AMD GPUS or CPUS.\n  Currently, only AMDSMI_INIT_AMD_GPUS is supported.\n\n  @param[in] init_flags Bit flags that tell SMI how to initialze. Values of\n  ::amdsmi_init_flags_t may be OR'd together and passed through @p init_flags\n  to modify how AMDSMI initializes.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_init(&self, init_flags: u64) -> amdsmi_status_t {
        (self.amdsmi_init.as_ref().expect("Expected function, got error."))(init_flags)
    }
    #[doc = "  @brief Shutdown the AMD SMI library\n\n  @ingroup tagInitShutdown\n\n  @platform{gpu_bm_linux} @platform{host} @platform{cpu_bm} @platform{guest_1vf}\n  @platform{guest_mvf} @platform{guest_windows}\n\n  @details This function shuts down the library and internal data structures and\n  performs any necessary clean ups. Singleton Design, requires the same number\n  of inits as shutdowns.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_shut_down(&self) -> amdsmi_status_t {
        (self.amdsmi_shut_down.as_ref().expect("Expected function, got error."))()
    }
    #[doc = "  @brief Get the list of socket handles in the system.\n\n  @ingroup tagProcDiscovery\n\n  @platform{gpu_bm_linux} @platform{host} @platform{cpu_bm} @platform{guest_1vf}\n  @platform{guest_mvf} @platform{guest_windows}\n\n  @details Depends on what flag is passed to ::amdsmi_init.  AMDSMI_INIT_AMD_GPUS\n  returns sockets with AMD GPUS, and AMDSMI_INIT_AMD_GPUS | AMDSMI_INIT_AMD_CPUS returns\n  sockets with either AMD GPUS or CPUS.\n  The socket handles can be used to query the processor handles in that socket, which\n  will be used in other APIs to get processor detail information or telemtries.\n\n  @param[in,out] socket_count As input, the value passed\n  through this parameter is the number of ::amdsmi_socket_handle that\n  may be safely written to the memory pointed to by @p socket_handles. This is the\n  limit on how many socket handles will be written to @p socket_handles. On return, @p\n  socket_count will contain the number of socket handles written to @p socket_handles,\n  or the number of socket handles that could have been written if enough memory had been\n  provided.\n  If @p socket_handles is NULL, as output, @p socket_count will contain\n  how many sockets are available to read in the system.\n\n  @param[in,out] socket_handles A pointer to a block of memory to which the\n  ::amdsmi_socket_handle values will be written. This value may be NULL.\n  In this case, this function can be used to query how many sockets are\n  available to read in the system.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_socket_handles(
        &self,
        socket_count: *mut u32,
        socket_handles: *mut amdsmi_socket_handle,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_socket_handles
            .as_ref()
            .expect("Expected function, got error."))(socket_count, socket_handles)
    }
    #[doc = "  @brief Get information about the given socket\n\n  @ingroup tagProcDiscovery\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf}\n  @platform{guest_mvf} @platform{guest_windows}\n\n  @details This function retrieves socket information. The @p socket_handle must\n  be provided to retrieve the Socket ID.\n\n  @param[in] socket_handle a socket handle\n\n  @param[in] len the length of the caller provided buffer @p name.\n\n  @param[out] name The id of the socket.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_socket_info(
        &self,
        socket_handle: amdsmi_socket_handle,
        len: usize,
        name: *mut ::std::os::raw::c_char,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_socket_info
            .as_ref()
            .expect("Expected function, got error."))(socket_handle, len, name)
    }
    #[doc = "  @brief Get the list of the processor handles associated to a socket.\n\n  @ingroup tagProcDiscovery\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf}\n  @platform{guest_mvf} @platform{guest_windows}\n\n  @details This function retrieves the processor handles of a socket. The\n  @p socket_handle must be provided for the processor. A socket may have mulitple different\n  type processors: An APU on a socket have both CPUs and GPUs.\n  Currently, only AMD GPUs are supported.\n\n  @note Sockets are not supported on the @platform{host}.\n\n  The number of processor count is returned through @p processor_count\n  if @p processor_handles is NULL. Then the number of @p processor_count can be pass\n  as input to retrieval all processors on the socket to @p processor_handles.\n\n  @param[in] socket_handle The socket to query\n\n  @param[in,out] processor_count As input, the value passed\n  through this parameter is the number of ::amdsmi_processor_handle's that\n  may be safely written to the memory pointed to by @p processor_handles. This is the\n  limit on how many processor handles will be written to @p processor_handles. On return, @p\n  processor_count will contain the number of processor handles written to @p processor_handles,\n  or the number of processor handles that could have been written if enough memory had been\n  provided.\n  If @p processor_handles is NULL, as output, @p processor_count will contain\n  how many processors are available to read for the socket.\n\n  @param[in,out] processor_handles A pointer to a block of memory to which the\n  ::amdsmi_processor_handle values will be written. This value may be NULL.\n  In this case, this function can be used to query how many processors are\n  available to read.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_processor_handles(
        &self,
        socket_handle: amdsmi_socket_handle,
        processor_count: *mut u32,
        processor_handles: *mut amdsmi_processor_handle,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_processor_handles
            .as_ref()
            .expect("Expected function, got error."))(socket_handle, processor_count, processor_handles)
    }
    #[doc = "  @brief Get the node handle associated with processor handle.\n\n  @ingroup tagProcDiscovery\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @details This function retrieves the node handle of a processor handler. The\n  @p processor_handle must be provided for the processor.\n  Currently, only AMD GPUs are supported.\n\n  @param[in] processor_handle A pointer to a ::amdsmi_processor_handle, this\n  is required to be OAM ID 0 otherwise the API will fail. OAM ID is sourced\n  from amdsmi_get_gpu_asic_info API.\n\n  @param[out] amdsmi_node_handle* A pointer to a block of memory where amdsmi_node_handle\n  will be written.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_node_handle(
        &self,
        processor_handle: amdsmi_processor_handle,
        node_handle: *mut amdsmi_node_handle,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_node_handle
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, node_handle)
    }
    #[doc = "  @brief Get the processor type of the processor_handle\n\n  @ingroup tagProcDiscovery\n\n  @platform{gpu_bm_linux} @platform{host} @platform{cpu_bm} @platform{guest_1vf}\n  @platform{guest_mvf} @platform{guest_windows}\n\n  @details This function retrieves the processor type. A processor_handle must be provided\n  for that processor.\n\n  @param[in] processor_handle a processor handle\n\n  @param[out] processor_type a pointer to processor_type_t to which the processor type\n  will be written. If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_processor_type(
        &self,
        processor_handle: amdsmi_processor_handle,
        processor_type: *mut processor_type_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_processor_type
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, processor_type)
    }
    #[doc = "  @brief Get processor handle with the matching bdf.\n\n  @ingroup tagProcDiscovery\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf}\n  @platform{guest_mvf} @platform{guest_windows}\n\n  @details Given bdf info @p bdf, this function will get\n  the processor handle with the matching bdf.\n\n  @param[in] bdf The bdf to match with corresponding processor handle.\n\n  @param[out] processor_handle processor handle with the matching bdf.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_processor_handle_from_bdf(
        &self,
        bdf: amdsmi_bdf_t,
        processor_handle: *mut amdsmi_processor_handle,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_processor_handle_from_bdf
            .as_ref()
            .expect("Expected function, got error."))(bdf, processor_handle)
    }
    #[doc = "  @brief Returns BDF of the given device\n\n  @ingroup tagProcDiscovery\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_mvf}\n  @platform{guest_windows}\n\n  @param[in]      processor_handle Device which to query\n\n  @param[out]     bdf Reference to BDF. Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_device_bdf(
        &self,
        processor_handle: amdsmi_processor_handle,
        bdf: *mut amdsmi_bdf_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_device_bdf
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, bdf)
    }
    #[doc = "  @brief Returns the UUID of the device\n\n  @ingroup tagProcDiscovery\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_mvf}\n  @platform{guest_windows}\n\n  @param[in] processor_handle Device which to query\n\n  @param[in,out] uuid_length Length of the uuid string. As input, must be\n                 equal or greater than AMDSMI_GPU_UUID_SIZE and be allocated by\n                 user. As output it is the length of the uuid string.\n\n  @param[out] uuid Pointer to string to store the UUID. Must be\n              allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_device_uuid(
        &self,
        processor_handle: amdsmi_processor_handle,
        uuid_length: *mut ::std::os::raw::c_uint,
        uuid: *mut ::std::os::raw::c_char,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_device_uuid
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, uuid_length, uuid)
    }
    #[doc = "  @brief          Returns the Enumeration information for the device\n\n  @ingroup tagProcDiscovery\n\n  @platform{gpu_bm_linux} @platform{guest_1vf} @platform{guest_mvf}\n\n  @details        This function returns Enumeration information of the corresponding\n                  processor_handle. It will return the render number, card number,\n                  HSA ID, HIP ID, and the HIP UUID.\n\n  @param[in]      processor_handle Device which to query\n\n  @param[out]     info Reference to Enumeration information structure.\n                  Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_enumeration_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_enumeration_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_enumeration_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Retrieves an array of uint64_t (sized to cpu_set_size) of bitmasks with the\n  affinity within numa node or socket for the device.\n\n  @ingroup tagProcDiscovery\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @details Given a processor handle @p processor_handle, the size of the cpu_set array @p cpu_set_size,\n  and a pointer to an array of int64_t @p cpu_set, and @p scope, this function will write the CPU affinity bitmask\n  to the array pointed to by @p cpu_set.\n\n User must allocate the enough memory for the cpu_set array. The size of the array is determined by the\n number of CPU cores in the system. As an example, if there are 2 CPUs and each has 112 cores, the size\n should be ceiling(2*112/64) = 4, where 64 is the bits of uint64_t. The function will write the CPU affinity bitmask\n to the array. For example, to describe the CPU cores 0-55,112-167, it will set the 0-55 and 112-167 bits\n to 1 and the reset of bits to 0 in the cpu_set array.\n\n  @param[in] processor_handle a processor handle\n  @param[in] cpu_set_size The size of the cpu_set array that is safe to access\n  @param[in,out] cpu_set Array reference in which to return a bitmask of CPU cores that this processor affinities with.\n  @param[in] scope Scope for socket or numa affinity.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_cpu_affinity_with_scope(
        &self,
        processor_handle: amdsmi_processor_handle,
        cpu_set_size: u32,
        cpu_set: *mut u64,
        scope: amdsmi_affinity_scope_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_cpu_affinity_with_scope
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, cpu_set_size, cpu_set, scope)
    }
    #[doc = "  @brief Returns the virtualization mode for the target device.\n\n  @ingroup tagProcDiscovery\n\n  @platform{gpu_bm_linux} @platform{guest_1vf} @platform{host}\n\n  @details The virtualization mode is detected and returned as an enum.\n\n  @param[in] processor_handle The identifier of the given device.\n\n  @param[in,out] mode Reference to the enum representing virtualization mode.\n                  - When zero, the virtualization mode is unknown\n                  - When non-zero, the virtualization mode is detected\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail."]
    pub unsafe fn amdsmi_get_gpu_virtualization_mode(
        &self,
        processor_handle: amdsmi_processor_handle,
        mode: *mut amdsmi_virtualization_mode_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_virtualization_mode
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, mode)
    }
    #[doc = "  @brief Get the device id associated with the device with provided device\n  handler.\n\n  @ingroup tagIdentQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a uint32_t @p id,\n  this function will write the device id value to the uint64_t pointed to by\n  @p id. This ID is an identification of the type of device, so calling this\n  function for different devices will give the same value if they are kind\n  of device. Consequently, this function should not be used to distinguish\n  one device from another. amdsmi_get_gpu_bdf_id() should be used to get a\n  unique identifier.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] id a pointer to uint64_t to which the device id will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_id(&self, processor_handle: amdsmi_processor_handle, id: *mut u16) -> amdsmi_status_t {
        (self.amdsmi_get_gpu_id.as_ref().expect("Expected function, got error."))(processor_handle, id)
    }
    #[doc = "  @brief Get the device revision associated with the device\n\n  @ingroup tagIdentQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a\n  uint16_t @p revision to which the revision id will be written\n\n  @param[in] processor_handle a processor handle\n\n  @param[out] revision a pointer to uint16_t to which the device revision\n  will be written\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_revision(
        &self,
        processor_handle: amdsmi_processor_handle,
        revision: *mut u16,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_revision
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, revision)
    }
    #[doc = "  @brief Get the name string for a give vendor ID\n\n  @ingroup tagIdentQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a pointer to a caller provided\n  char buffer @p name, and a length of this buffer @p len, this function will\n  write the name of the vendor (up to @p len characters) buffer @p name. The\n  @p id may be a device vendor or subsystem vendor ID.\n\n  If the integer ID associated with the vendor is not found in one of the\n  system files containing device name information (e.g.\n  /usr/share/misc/pci.ids), then this function will return the hex vendor ID\n  as a string. Updating the system name files can be accompplished with\n  \"sudo update-pciids\".\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] name a pointer to a caller provided char buffer to which the\n  name will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len the length of the caller provided buffer @p name.\n\n  @note ::AMDSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_vendor_name(
        &self,
        processor_handle: amdsmi_processor_handle,
        name: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_vendor_name
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, name, len)
    }
    #[doc = "  @brief Get the vram vendor string of a device.\n\n  @ingroup tagIdentQuery\n\n  @platform{gpu_bm_linux}\n\n  @details This function retrieves the vram vendor name given a processor handle\n  @p processor_handle, a pointer to a caller provided\n  char buffer @p brand, and a length of this buffer @p len, this function\n  will write the vram vendor of the device (up to @p len characters) to the\n  buffer @p brand.\n\n  If the vram vendor for the device is not found as one of the values\n  contained within amdsmi_get_gpu_vram_vendor, then this function will return\n  the string 'unknown' instead of the vram vendor.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] brand a pointer to a caller provided char buffer to which the\n  vram vendor will be written\n\n  @param[in] len the length of the caller provided buffer @p brand.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_vram_vendor(
        &self,
        processor_handle: amdsmi_processor_handle,
        brand: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_vram_vendor
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, brand, len)
    }
    #[doc = "  @brief Get the subsystem device id associated with the device with\n  provided processor handle.\n\n  @ingroup tagIdentQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a uint32_t @p id,\n  this function will write the subsystem device id value to the uint64_t\n  pointed to by @p id.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] id a pointer to uint64_t to which the subsystem device id\n  will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_subsystem_id(
        &self,
        processor_handle: amdsmi_processor_handle,
        id: *mut u16,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_subsystem_id
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, id)
    }
    #[doc = "  @brief Get the name string for the device subsytem\n\n  @ingroup tagIdentQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a pointer to a caller provided\n  char buffer @p name, and a length of this buffer @p len, this function\n  will write the name of the device subsystem (up to @p len characters)\n  to the buffer @p name.\n\n  If the integer ID associated with the sub-system is not found in one of the\n  system files containing device name information (e.g.\n  /usr/share/misc/pci.ids), then this function will return the hex sub-system\n  ID as a string. Updating the system name files can be accompplished with\n  \"sudo update-pciids\".\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] name a pointer to a caller provided char buffer to which the\n  name will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len the length of the caller provided buffer @p name.\n\n  @note ::AMDSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_subsystem_name(
        &self,
        processor_handle: amdsmi_processor_handle,
        name: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_subsystem_name
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, name, len)
    }
    #[doc = "  @brief Get the list of possible PCIe bandwidths that are available. It is not\n  supported on virtual machine guest\n\n  @ingroup tagPCIeQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a to an\n  ::amdsmi_pcie_bandwidth_t structure @p bandwidth, this function will fill in\n  @p bandwidth with the possible T/s values and associated number of lanes,\n  and indication of the current selection.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] bandwidth a pointer to a caller provided\n  ::amdsmi_pcie_bandwidth_t structure to which the frequency information will be\n  written\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_pci_bandwidth(
        &self,
        processor_handle: amdsmi_processor_handle,
        bandwidth: *mut amdsmi_pcie_bandwidth_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_pci_bandwidth
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, bandwidth)
    }
    #[doc = "  @brief Get the unique PCI device identifier associated for a device\n\n  @ingroup tagPCIeQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Give a processor handle @p processor_handle and a pointer to a uint64_t @p\n  bdfid, this function will write the Bus/Device/Function PCI identifier\n  (BDFID) associated with device @p processor_handle to the value pointed to by\n  @p bdfid.\n\n  The format of @p bdfid will be as follows:\n\n      BDFID = ((DOMAIN & 0xFFFFFFFF) << 32) | ((Partition & 0xF) << 28)\n              | ((BUS & 0xFF) << 8) | ((DEVICE & 0x1F) <<3 )\n              | (FUNCTION & 0x7)\n\n  | Name         | Field   | KFD property     | KFD -> PCIe ID (uint64_t)    |\n  -------------- | ------- | ---------------- | ---------------------------- |\n  | Domain       | [63:32] | \"domain\"         | (DOMAIN & 0xFFFFFFFF) << 32  |\n  | Partition id | [31:28] | \"location id\"    | (LOCATION & 0xF0000000)      |\n  | Reserved     | [27:16] | \"location id\"    | N/A                          |\n  | Bus          | [15: 8] | \"location id\"    | (LOCATION & 0xFF00)          |\n  | Device       | [ 7: 3] | \"location id\"    | (LOCATION & 0xF8)            |\n  | Function     | [ 2: 0] | \"location id\"    | (LOCATION & 0x7)             |\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] bdfid a pointer to uint64_t to which the device bdfid value\n  will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_bdf_id(
        &self,
        processor_handle: amdsmi_processor_handle,
        bdfid: *mut u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_bdf_id
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, bdfid)
    }
    #[doc = "  @brief Get the NUMA node associated with a device\n\n  @ingroup tagPCIeQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a int32_t @p\n  numa_node, this function will retrieve the NUMA node value associated\n  with device @p processor_handle and store the value at location pointed to by\n  @p numa_node.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] numa_node pointer to location where NUMA node value will\n  be written.\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_topo_numa_affinity(
        &self,
        processor_handle: amdsmi_processor_handle,
        numa_node: *mut i32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_topo_numa_affinity
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, numa_node)
    }
    #[doc = "  @brief Get PCIe traffic information. It is not supported on virtual machine guest\n\n  @ingroup tagPCIeQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Give a processor handle @p processor_handle and pointers to a uint64_t's, @p\n  sent, @p received and @p max_pkt_sz, this function will write the number\n  of bytes sent and received in 1 second to @p sent and @p received,\n  respectively. The maximum possible packet size will be written to\n  @p max_pkt_sz.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] sent a pointer to uint64_t to which the number of bytes sent\n  will be written in 1 second. If pointer is NULL, it will be ignored.\n\n  @param[in,out] received a pointer to uint64_t to which the number of bytes\n  received will be written. If pointer is NULL, it will be ignored.\n\n  @param[in,out] max_pkt_sz a pointer to uint64_t to which the maximum packet\n  size will be written. If pointer is NULL, it will be ignored.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_pci_throughput(
        &self,
        processor_handle: amdsmi_processor_handle,
        sent: *mut u64,
        received: *mut u64,
        max_pkt_sz: *mut u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_pci_throughput
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, sent, received, max_pkt_sz)
    }
    #[doc = "  @brief Get PCIe replay counter\n\n  @ingroup tagPCIeQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a uint64_t @p\n  counter, this function will write the sum of the number of NAK's received\n  by the GPU and the NAK's generated by the GPU to memory pointed to by @p\n  counter.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] counter a pointer to uint64_t to which the sum of the NAK's\n  received and generated by the GPU is written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_pci_replay_counter(
        &self,
        processor_handle: amdsmi_processor_handle,
        counter: *mut u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_pci_replay_counter
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, counter)
    }
    #[doc = "  @brief Control the set of allowed PCIe bandwidths that can be used. It is not\n  supported on virtual machine guest\n\n  @ingroup tagPCIeControl\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a 64 bit bitmask @p bw_bitmask,\n  this function will limit the set of allowable bandwidths. If a bit in @p\n  bw_bitmask has a value of 1, then the frequency (as ordered in an\n  ::amdsmi_frequencies_t returned by :: amdsmi_get_clk_freq()) corresponding\n  to that bit index will be allowed.\n\n  This function will change the performance level to\n  ::AMDSMI_DEV_PERF_LEVEL_MANUAL in order to modify the set of allowable\n  band_widths. Caller will need to set to ::AMDSMI_DEV_PERF_LEVEL_AUTO in order\n  to get back to default state.\n\n  All bits with indices greater than or equal to the value of the\n  ::amdsmi_frequencies_t::num_supported field of ::amdsmi_pcie_bandwidth_t will be\n  ignored.\n\n  @note This function requires root access\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] bw_bitmask A bitmask indicating the indices of the\n  bandwidths that are to be enabled (1) and disabled (0). Only the lowest\n  ::amdsmi_frequencies_t::num_supported (of ::amdsmi_pcie_bandwidth_t) bits of\n  this mask are relevant.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_pci_bandwidth(
        &self,
        processor_handle: amdsmi_processor_handle,
        bw_bitmask: u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_pci_bandwidth
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, bw_bitmask)
    }
    #[doc = "  @brief Get the energy accumulator counter of the processor with provided\n  processor handle. It is not supported on virtual machine guest\n\n  @ingroup tagPowerQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a pointer to a uint64_t\n  @p energy_accumulator, and a pointer to a uint64_t @p timestamp, this function\n  will write amount of energy consumed to the uint64_t pointed to by\n  @p energy_accumulator, and the timestamp to the uint64_t pointed to by @p timestamp.\n  This function accumulates all energy consumed.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] energy_accumulator a pointer to uint64_t to which the energy\n  counter will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in,out] counter_resolution resolution of the counter @p energy_accumulator in\n  micro Joules\n\n  @param[in,out] timestamp a pointer to uint64_t to which the timestamp\n  will be written. Resolution: 1 ns.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_energy_count(
        &self,
        processor_handle: amdsmi_processor_handle,
        energy_accumulator: *mut u64,
        counter_resolution: *mut f32,
        timestamp: *mut u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_energy_count
            .as_ref()
            .expect("Expected function, got error."))(
            processor_handle,
            energy_accumulator,
            counter_resolution,
            timestamp,
        )
    }
    #[doc = "  @brief Set the maximum gpu power cap value. It is not supported on virtual\n  machine guest\n\n  @ingroup tagPowerControl\n\n  @platform{host} @platform{gpu_bm_linux} @platform{guest_1vf}\n\n  @details Set the power cap to the provided value @p cap.\n  @p cap must be between the minimum and maximum power cap values set by the\n  system, which can be obtained from ::amdsmi_dev_power_cap_range_get.\n\n  @param[in] processor_handle A processor handle\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a processor has more than one sensor, it could be greater than 0.\n\n  @param[in] cap a uint64_t that indicates the desired power cap.\n  The @p cap value must be greater than 0.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_power_cap(
        &self,
        processor_handle: amdsmi_processor_handle,
        sensor_ind: u32,
        cap: u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_power_cap
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, sensor_ind, cap)
    }
    #[doc = "  @brief Set the power performance profile. It is not supported on virtual machine guest\n\n  @ingroup tagPowerControl\n\n  @platform{gpu_bm_linux}\n\n  @details This function will attempt to set the current profile to the provided\n  profile, given a processor handle @p processor_handle and a @p profile. The provided\n  profile must be one of the currently supported profiles, as indicated by a\n  call to :: amdsmi_get_gpu_power_profile_presets()\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] reserved Not currently used. Set to 0.\n\n  @param[in] profile a ::amdsmi_power_profile_preset_masks_t that hold the mask\n  of the desired new power profile\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_power_profile(
        &self,
        processor_handle: amdsmi_processor_handle,
        reserved: u32,
        profile: amdsmi_power_profile_preset_masks_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_power_profile
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, reserved, profile)
    }
    #[doc = "  @brief Query the supported power cap sensors and their types for a device.\n\n  @ingroup tagPowerControl\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @details This function returns the list of supported power cap sensors for the given device,\n  including their sensor indices and types (e.g., PPT0, PPT1).\n\n  @param[in]  processor_handle A processor handle.\n  @param[out] sensor_count Pointer to a uint32_t that will be set to the number of supported sensors.\n  @param[out] sensor_inds Pointer to an array of uint32_t to be filled with sensor indices.\n                          The array must be allocated by the caller with enough space.\n  @param[out] sensor_types Pointer to an array of amdsmi_power_cap_type_t to be filled with sensor types.\n                          The array must be allocated by the caller with enough space.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail."]
    pub unsafe fn amdsmi_get_supported_power_cap(
        &self,
        processor_handle: amdsmi_processor_handle,
        sensor_count: *mut u32,
        sensor_inds: *mut u32,
        sensor_types: *mut amdsmi_power_cap_type_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_supported_power_cap
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, sensor_count, sensor_inds, sensor_types)
    }
    #[doc = "  @brief Get the socket power.\n\n  @ingroup tagPowerControl\n\n  @platform{cpu_bm}\n\n  @param[in]      processor_handle Cpu socket which to query\n\n  @param[in,out]    ppower - Input buffer to return socket power\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_cpu_socket_power(
        &self,
        processor_handle: amdsmi_processor_handle,
        ppower: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_cpu_socket_power
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, ppower)
    }
    #[doc = "  @brief Get the socket power cap.\n\n  @ingroup tagPowerControl\n\n  @platform{cpu_bm}\n\n  @param[in]      processor_handle Cpu socket which to query\n\n  @param[in,out]    pcap - Input buffer to return power cap.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_cpu_socket_power_cap(
        &self,
        processor_handle: amdsmi_processor_handle,
        pcap: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_cpu_socket_power_cap
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, pcap)
    }
    #[doc = "  @brief Get the maximum power cap value for a given socket.\n\n  @ingroup tagPowerControl\n\n  @platform{cpu_bm}\n\n  @param[in]      processor_handle Cpu socket which to query\n\n  @param[in,out]    pmax - Input buffer to return maximum power limit value\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_cpu_socket_power_cap_max(
        &self,
        processor_handle: amdsmi_processor_handle,
        pmax: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_cpu_socket_power_cap_max
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, pmax)
    }
    #[doc = "  @brief Get the SVI based power telemetry for all rails.\n\n  @ingroup tagPowerControl\n\n  @platform{cpu_bm}\n\n  @param[in]      processor_handle Cpu socket which to query\n\n  @param[in,out]    power - Input buffer to return svi based power value\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_cpu_pwr_svi_telemetry_all_rails(
        &self,
        processor_handle: amdsmi_processor_handle,
        power: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_cpu_pwr_svi_telemetry_all_rails
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, power)
    }
    #[doc = "  @brief Set the power cap value for a given socket.\n\n  @ingroup tagPowerControl\n\n  @platform{cpu_bm}\n\n  @param[in]  processor_handle Cpu socket which to query\n\n  @param[in]  pcap - Input power limit value\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_cpu_socket_power_cap(
        &self,
        processor_handle: amdsmi_processor_handle,
        pcap: u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_cpu_socket_power_cap
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, pcap)
    }
    #[doc = "  @brief Set the power efficiency profile policy.\n\n  @ingroup tagPowerControl\n\n  @platform{cpu_bm}\n\n  @param[in] processor_handle Cpu socket which to query\n\n  @param[in] mode - mode to be set\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_cpu_pwr_efficiency_mode(
        &self,
        processor_handle: amdsmi_processor_handle,
        mode: u8,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_cpu_pwr_efficiency_mode
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, mode)
    }
    #[doc = "  @brief Get the total amount of memory that exists\n\n  @ingroup tagMemoryQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a type of memory @p mem_type, and\n  a pointer to a uint64_t @p total, this function will write the total amount\n  of @p mem_type memory that exists to the location pointed to by @p total.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] mem_type The type of memory for which the total amount will be\n  found\n\n  @param[in,out] total a pointer to uint64_t to which the total amount of\n  memory will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_memory_total(
        &self,
        processor_handle: amdsmi_processor_handle,
        mem_type: amdsmi_memory_type_t,
        total: *mut u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_memory_total
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, mem_type, total)
    }
    #[doc = "  @brief Get the current memory usage\n\n  @ingroup tagMemoryQuery\n\n  @platform{gpu_bm_linux}\n\n  @details This function will write the amount of @p mem_type memory that\n  that is currently being used to the location pointed to by @p used.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] mem_type The type of memory for which the amount being used will\n  be found\n\n  @param[in,out] used a pointer to uint64_t to which the amount of memory\n  currently being used will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_memory_usage(
        &self,
        processor_handle: amdsmi_processor_handle,
        mem_type: amdsmi_memory_type_t,
        used: *mut u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_memory_usage
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, mem_type, used)
    }
    #[doc = "  @brief Get the bad pages of a processor. It is not supported on virtual\n  machine guest\n\n  @ingroup tagMemoryQuery\n\n  @platform{gpu_bm_linux}\n\n  @details This call will query the device @p processor_handle for the\n  number of bad pages (written to @p num_pages address). The results are\n  written to address held by the @p info pointer.\n  The first call to this API returns the number of bad pages which\n  should be used to allocate the buffer that should contain the bad page\n  records.\n\n  @param[in] processor_handle a processor handle\n\n  @param[out] num_pages Number of bad page records.\n\n  @param[out] info The results will be written to the\n  amdsmi_retired_page_record_t pointer.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_bad_page_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        num_pages: *mut u32,
        info: *mut amdsmi_retired_page_record_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_bad_page_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, num_pages, info)
    }
    #[doc = "  @brief Get the bad pages threshold of a processor. It is not supported on virtual\n  machine guest\n\n  @ingroup tagMemoryQuery\n\n  @platform{gpu_bm_linux}\n\n  @details This call will query the device @p processor_handle for the\n  threshold of bad pages (written to @p threshold address).\n\n  @param[in] processor_handle a processor handle\n  @param[out] threshold of bad page count.\n\n  @note This function requires root access\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_bad_page_threshold(
        &self,
        processor_handle: amdsmi_processor_handle,
        threshold: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_bad_page_threshold
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, threshold)
    }
    #[doc = "  @brief Verify the checksum of RAS EEPROM. It is not supported on virtual\n  machine guest\n\n  @ingroup tagMemoryQuery\n\n  @platform{gpu_bm_linux}\n\n  @details This call will verify the device @p processor_handle for the\n  checksum of RAS EEPROM.\n\n  @param[in] processor_handle a processor handle\n\n  @note This function requires root access\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success\n          AMDSMI_STATUS_CORRUPTED_EEPROM on the device's EEPROM corruption\n          others on fail"]
    pub unsafe fn amdsmi_gpu_validate_ras_eeprom(&self, processor_handle: amdsmi_processor_handle) -> amdsmi_status_t {
        (self
            .amdsmi_gpu_validate_ras_eeprom
            .as_ref()
            .expect("Expected function, got error."))(processor_handle)
    }
    #[doc = "  @brief Returns if RAS features are enabled or disabled for given block. It is not\n  supported on virtual machine guest\n\n  @ingroup tagMemoryQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, this function queries the\n  state of RAS features for a specific block @p block. Result will be written\n  to address held by pointer @p state.\n\n  @param[in] processor_handle Device handle which to query\n\n  @param[in] block Block which to query\n\n  @param[in,out] state A pointer to amdsmi_ras_err_state_t to which the state\n  of block will be written.\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_ras_block_features_enabled(
        &self,
        processor_handle: amdsmi_processor_handle,
        block: amdsmi_gpu_block_t,
        state: *mut amdsmi_ras_err_state_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_ras_block_features_enabled
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, block, state)
    }
    #[doc = "  @brief Get information about reserved (\"retired\") memory pages. It is not supported on\n  virtual machine guest\n\n  @ingroup tagMemoryQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, this function returns retired page\n  information @p records corresponding to the device with the provided processor\n  handle @p processor_handle. The number of retired page records is returned through @p\n  num_pages. @p records may be NULL on input. In this case, the number of\n  records available for retrieval will be returned through @p num_pages.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] num_pages a pointer to a uint32. As input, the value passed\n  through this parameter is the number of ::amdsmi_retired_page_record_t's that\n  may be safely written to the memory pointed to by @p records. This is the\n  limit on how many records will be written to @p records. On return, @p\n  num_pages will contain the number of records written to @p records, or the\n  number of records that could have been written if enough memory had been\n  provided.\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in,out] records A pointer to a block of memory to which the\n  ::amdsmi_retired_page_record_t values will be written. This value may be NULL.\n  In this case, this function can be used to query how many records are\n  available to read.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_memory_reserved_pages(
        &self,
        processor_handle: amdsmi_processor_handle,
        num_pages: *mut u32,
        records: *mut amdsmi_retired_page_record_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_memory_reserved_pages
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, num_pages, records)
    }
    #[doc = "  @brief Get the fan speed in RPMs of the device with the specified processor\n  handle and 0-based sensor index. It is not supported on virtual machine guest\n\n  @ingroup tagPhysicalStateQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a uint32_t\n  @p speed, this function will write the current fan speed in RPMs to the\n  uint32_t pointed to by @p speed\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[in,out] speed a pointer to uint32_t to which the speed will be\n  written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_fan_rpms(
        &self,
        processor_handle: amdsmi_processor_handle,
        sensor_ind: u32,
        speed: *mut i64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_fan_rpms
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, sensor_ind, speed)
    }
    #[doc = "  @brief Get the fan speed for the specified device as a value relative to\n  ::AMDSMI_MAX_FAN_SPEED. It is not supported on virtual machine guest\n\n  @ingroup tagPhysicalStateQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a uint32_t\n  @p speed, this function will write the current fan speed (a value\n  between 0 and the maximum fan speed, ::AMDSMI_MAX_FAN_SPEED) to the uint32_t\n  pointed to by @p speed\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[in,out] speed a pointer to uint32_t to which the speed will be\n  written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_fan_speed(
        &self,
        processor_handle: amdsmi_processor_handle,
        sensor_ind: u32,
        speed: *mut i64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_fan_speed
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, sensor_ind, speed)
    }
    #[doc = "  @brief Get the max. fan speed of the device with provided processor handle. It is\n  not supported on virtual machine guest\n\n  @ingroup tagPhysicalStateQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a uint32_t\n  @p max_speed, this function will write the maximum fan speed possible to\n  the uint32_t pointed to by @p max_speed\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[in,out] max_speed a pointer to uint32_t to which the maximum speed\n  will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_fan_speed_max(
        &self,
        processor_handle: amdsmi_processor_handle,
        sensor_ind: u32,
        max_speed: *mut u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_fan_speed_max
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, sensor_ind, max_speed)
    }
    #[doc = "  @brief Returns gpu cache info.\n\n  @ingroup tagPhysicalStateQuery\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @param[in] processor_handle PF of a processor for which to query\n\n  @param[out] info reference to the cache info struct.\n  Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_cache_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_gpu_cache_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_cache_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Get the voltage metric value for the specified metric, from the\n  specified voltage sensor on the specified device. It is not supported on\n  virtual machine guest\n\n  @ingroup tagPhysicalStateQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a sensor type @p sensor_type, a\n  ::amdsmi_voltage_metric_t @p metric and a pointer to an int64_t @p\n  voltage, this function will write the value of the metric indicated by\n  @p metric and @p sensor_type to the memory location @p voltage.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] sensor_type part of device from which voltage should be\n  obtained. This should come from the enum ::amdsmi_voltage_type_t\n\n  @param[in] metric enum indicated which voltage value should be\n  retrieved\n\n  @param[in,out] voltage a pointer to int64_t to which the voltage\n  will be written, in millivolts.\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_volt_metric(
        &self,
        processor_handle: amdsmi_processor_handle,
        sensor_type: amdsmi_voltage_type_t,
        metric: amdsmi_voltage_metric_t,
        voltage: *mut i64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_volt_metric
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, sensor_type, metric, voltage)
    }
    #[doc = "  @brief Reset the fan to automatic driver control. It is not supported on virtual\n  machine guest\n\n  @ingroup tagPhysicalStateControl\n\n  @platform{gpu_bm_linux}\n\n  @details This function returns control of the fan to the system\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_reset_gpu_fan(
        &self,
        processor_handle: amdsmi_processor_handle,
        sensor_ind: u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_reset_gpu_fan
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, sensor_ind)
    }
    #[doc = "  @brief Set the fan speed for the specified device with the provided speed,\n  in RPMs. It is not supported on virtual machine guest\n\n  @ingroup tagPhysicalStateControl\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a integer value indicating\n  speed @p speed, this function will attempt to set the fan speed to @p speed.\n  An error will be returned if the specified speed is outside the allowable\n  range for the device. The maximum value is 255 and the minimum is 0.\n\n  @note This function requires root access\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[in] speed the speed to which the function will attempt to set the fan\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_fan_speed(
        &self,
        processor_handle: amdsmi_processor_handle,
        sensor_ind: u32,
        speed: u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_fan_speed
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, sensor_ind, speed)
    }
    #[doc = "  @brief Get GPU busy percent from gpu_busy_percent sysfs file\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, this function returns GPU busy\n  percentage.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] gpu_busy_percent Direct output from the gpu_busy_percent sysfs file\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_busy_percent(
        &self,
        processor_handle: amdsmi_processor_handle,
        gpu_busy_percent: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_busy_percent
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, gpu_busy_percent)
    }
    #[doc = "  @brief Get coarse grain utilization counter of the specified device\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, the array of the utilization counters,\n  the size of the array, this function returns the coarse grain utilization counters\n  and timestamp.\n  The counter is the accumulated percentages. Every milliseconds the firmware calculates\n  % busy count and then accumulates that value in the counter. This provides minimally\n  invasive coarse grain GPU usage information.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] utilization_counters Multiple utilization counters can be retreived with a single\n  call. The caller must allocate enough space to the utilization_counters array. The caller also\n  needs to set valid AMDSMI_UTILIZATION_COUNTER_TYPE type for each element of the array.\n  ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments.\n\n  If the function reutrns AMDSMI_STATUS_SUCCESS, the counter will be set in the value field of\n  the amdsmi_utilization_counter_t.\n\n  @param[in] count The size of @p utilization_counters array.\n\n  @param[in,out] timestamp The timestamp when the counter is retrieved. Resolution: 1 ns.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_utilization_count(
        &self,
        processor_handle: amdsmi_processor_handle,
        utilization_counters: *mut amdsmi_utilization_counter_t,
        count: u32,
        timestamp: *mut u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_utilization_count
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, utilization_counters, count, timestamp)
    }
    #[doc = "  @brief Get the performance level of the device. It is not supported on virtual\n  machine guest\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details This function will write the ::amdsmi_dev_perf_level_t to the uint32_t\n  pointed to by @p perf, for a given processor handle @p processor_handle and a pointer\n  to a uint32_t @p perf.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] perf a pointer to ::amdsmi_dev_perf_level_t to which the\n  performance level will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_perf_level(
        &self,
        processor_handle: amdsmi_processor_handle,
        perf: *mut amdsmi_dev_perf_level_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_perf_level
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, perf)
    }
    #[doc = "  @brief Enter performance determinism mode with provided processor handle. It is\n  not supported on virtual machine guest\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and @p clkvalue this function\n  will enable performance determinism mode, which enforces a GFXCLK frequency\n  SoftMax limit per GPU set by the user. This prevents the GFXCLK PLL from\n  stretching when running the same workload on different GPUS, making\n  performance variation minimal. This call will result in the performance\n  level ::amdsmi_dev_perf_level_t of the device being\n  ::AMDSMI_DEV_PERF_LEVEL_DETERMINISM.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] clkvalue Softmax value for GFXCLK in MHz.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_perf_determinism_mode(
        &self,
        processor_handle: amdsmi_processor_handle,
        clkvalue: u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_perf_determinism_mode
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, clkvalue)
    }
    #[doc = "  @brief Get the overdrive percent associated with the device with provided\n  processor handle. It is not supported on virtual machine guest\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a uint32_t @p od,\n  this function will write the overdrive percentage to the uint32_t pointed\n  to by @p od\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] od a pointer to uint32_t to which the overdrive percentage\n  will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_overdrive_level(
        &self,
        processor_handle: amdsmi_processor_handle,
        od: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_overdrive_level
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, od)
    }
    #[doc = "  @brief Get the GPU memory clock overdrive percent associated with the device with provided\n  processor handle. It is not supported on virtual machine guest\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a uint32_t @p od,\n  this function will write the overdrive percentage to the uint32_t pointed\n  to by @p od\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] od a pointer to uint32_t to which the GPU memory clock overdrive percentage\n  will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_mem_overdrive_level(
        &self,
        processor_handle: amdsmi_processor_handle,
        od: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_mem_overdrive_level
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, od)
    }
    #[doc = "  @brief Get the list of possible system clock speeds of device for a\n  specified clock type. It is not supported on virtual machine guest\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a clock type @p clk_type, and a\n  pointer to a to an ::amdsmi_frequencies_t structure @p f, this function will\n  fill in @p f with the possible clock speeds, and indication of the current\n  clock speed selection.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] clk_type the type of clock for which the frequency is desired\n\n  @param[in,out] f a pointer to a caller provided ::amdsmi_frequencies_t structure\n  to which the frequency information will be written. Frequency values are in\n  Hz.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_clk_freq(
        &self,
        processor_handle: amdsmi_processor_handle,
        clk_type: amdsmi_clk_type_t,
        f: *mut amdsmi_frequencies_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_clk_freq
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, clk_type, f)
    }
    #[doc = "  @brief Reset the gpu associated with the device with provided processor handle. It is not\n  supported on virtual machine guest\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @details Given a processor handle @p processor_handle, this function will reset the GPU\n\n  @param[in] processor_handle a processor handle\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_reset_gpu(&self, processor_handle: amdsmi_processor_handle) -> amdsmi_status_t {
        (self.amdsmi_reset_gpu.as_ref().expect("Expected function, got error."))(processor_handle)
    }
    #[doc = "  @brief This function retrieves the overdrive GFX & MCLK information. If valid\n  for the GPU it will also populate the voltage curve data. It is not supported\n  on virtual machine guest\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a\n  ::amdsmi_od_volt_freq_data_t structure @p odv, this function will populate @p\n  odv. See ::amdsmi_od_volt_freq_data_t for more details.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] odv a pointer to an ::amdsmi_od_volt_freq_data_t structure\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_od_volt_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        odv: *mut amdsmi_od_volt_freq_data_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_od_volt_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, odv)
    }
    #[doc = "  @brief Get the 'metrics_header_info' from the GPU metrics associated with the device\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a amd_metrics_table_header_t in which\n  the 'metrics_header_info' will stored\n\n  @param[in] processor_handle Device which to query\n\n  @param[inout] header_value a pointer to amd_metrics_table_header_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::AMDSMI_STATUS_SUCCESS is returned upon successful call.\n          ::AMDSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n  @return ::amdsmi_status_t"]
    pub unsafe fn amdsmi_get_gpu_metrics_header_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        header_value: *mut amd_metrics_table_header_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_metrics_header_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, header_value)
    }
    #[doc = "  @brief This function retrieves the gpu metrics information. It is not supported\n  on virtual machine guest\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a\n  ::amdsmi_gpu_metrics_t structure @p pgpu_metrics, this function will populate\n  @p pgpu_metrics. See ::amdsmi_gpu_metrics_t for more details.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] pgpu_metrics a pointer to an ::amdsmi_gpu_metrics_t structure\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_metrics_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        pgpu_metrics: *mut amdsmi_gpu_metrics_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_metrics_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, pgpu_metrics)
    }
    #[doc = "  @brief This function retrieves the partition metrics information.\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux} @platform{guest_1vf}\n\n  @details Given a processor handle @p processor_handle and a pointer to a\n  ::amdsmi_gpu_metrics_t structure @p pgpu_metrics, this function will populate\n  @p pgpu_metrics. See ::amdsmi_gpu_metrics_t for more details.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] pgpu_metrics a pointer to an ::amdsmi_gpu_metrics_t structure\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_partition_metrics_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        pgpu_metrics: *mut amdsmi_gpu_metrics_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_partition_metrics_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, pgpu_metrics)
    }
    #[doc = "  @brief Get the pm metrics table with provided device index.\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a device handle @p processor_handle, @p pm_metrics pointer,\n  and @p num_of_metrics pointer,\n  this function will write the pm metrics name value pair\n  to the array at @p pm_metrics and the number of metrics retreived to @p num_of_metrics\n  Note: the library allocated memory for pm_metrics, and user must call\n  free(pm_metrics) to free it after use.\n\n  @param[in] processor_handle a processor handle\n\n  @param[inout] pm_metrics A pointerto an array to hold multiple PM metrics. On successs,\n  the library will allocate memory of pm_metrics and write metrics to this array.\n  The caller must free this memory after usage to avoid memory leak.\n\n  @param[inout] num_of_metrics a pointer to uint32_t to which the number of\n  metrics is allocated for pm_metrics array as input, and the number of metrics retreived\n  as output. If this parameter is NULL, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::AMDSMI_STATUS_SUCCESS call was successful\n  @retval ::AMDSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::AMDSMI_STATUS_INVAL the provided arguments are not valid\n  @return ::amdsmi_status_t\n"]
    pub unsafe fn amdsmi_get_gpu_pm_metrics_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        pm_metrics: *mut *mut amdsmi_name_value_t,
        num_of_metrics: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_pm_metrics_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, pm_metrics, num_of_metrics)
    }
    #[doc = "  @brief Get the register metrics table with provided device index and register type.\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a device handle @p processor_handle, @p reg_type, @p reg_metrics pointer,\n  and @p num_of_metrics pointer,\n  this function will write the register metrics name value pair\n  to the array at @p reg_metrics and the number of metrics retreived to @p num_of_metrics\n  Note: the library allocated memory for reg_metrics, and user must call\n  free(reg_metrics) to free it after use.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] reg_type The register type\n\n  @param[inout] reg_metrics A pointerto an array to hold multiple register metrics. On successs,\n  the library will allocate memory of reg_metrics and write metrics to this array.\n  The caller must free this memory after usage to avoid memory leak.\n\n  @param[inout] num_of_metrics a pointer to uint32_t to which the number of\n  metrics is allocated for reg_metrics array as input, and the number of metrics retreived\n  as output. If this parameter is NULL, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::AMDSMI_STATUS_SUCCESS call was successful\n  @retval ::AMDSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::AMDSMI_STATUS_INVAL the provided arguments are not valid\n  @return ::amdsmi_status_t\n"]
    pub unsafe fn amdsmi_get_gpu_reg_table_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        reg_type: amdsmi_reg_type_t,
        reg_metrics: *mut *mut amdsmi_name_value_t,
        num_of_metrics: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_reg_table_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, reg_type, reg_metrics, num_of_metrics)
    }
    #[doc = "  @brief This function sets the clock range information. It is not supported on virtual\n  machine guest\n\n  @deprecated ::amdsmi_set_gpu_clk_limit() should be used, with an\n  interface that set the min_value and then max_value.\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a minimum clock value @p minclkvalue,\n  a maximum clock value @p maxclkvalue and a clock type @p clkType this function\n  will set the sclk|mclk range\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] minclkvalue value to apply to the clock range. Frequency values\n  are in MHz.\n\n  @param[in] maxclkvalue value to apply to the clock range. Frequency values\n  are in MHz.\n\n  @param[in] clkType AMDSMI_CLK_TYPE_SYS | AMDSMI_CLK_TYPE_MEM range type\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_clk_range(
        &self,
        processor_handle: amdsmi_processor_handle,
        minclkvalue: u64,
        maxclkvalue: u64,
        clkType: amdsmi_clk_type_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_clk_range
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, minclkvalue, maxclkvalue, clkType)
    }
    #[doc = "  @brief This function sets the clock sets the clock min/max level\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a clock type @p clk_type,\n  a value @p clk_value needs to be set, and the @p level indicates min or max\n  clock you want to set, this function the clock limit.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] clk_type AMDSMI_CLK_TYPE_SYS, AMDSMI_CLK_TYPE_MEM and so on\n\n  @param[in] limit_type AMDSMI_FREQ_IND_MIN|AMDSMI_FREQ_IND_MAX to set the\n  minimum (0) or maximum (1) speed.\n\n  @param[in] clk_value value to apply to. Frequency values are in MHz.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_clk_limit(
        &self,
        processor_handle: amdsmi_processor_handle,
        clk_type: amdsmi_clk_type_t,
        limit_type: amdsmi_clk_limit_type_t,
        clk_value: u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_clk_limit
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, clk_type, limit_type, clk_value)
    }
    #[doc = "  @brief This function sets the clock frequency information. It is not supported on\n  virtual machine guest\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a frequency level @p level,\n  a clock value @p clkvalue and a clock type @p clkType this function\n  will set the sclk|mclk range\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] level AMDSMI_FREQ_IND_MIN|AMDSMI_FREQ_IND_MAX to set the\n  minimum (0) or maximum (1) speed.\n\n  @param[in] clkvalue value to apply to the clock range. Frequency values\n  are in MHz.\n\n  @param[in] clkType AMDSMI_CLK_TYPE_SYS | AMDSMI_CLK_TYPE_MEM range type\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_od_clk_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        level: amdsmi_freq_ind_t,
        clkvalue: u64,
        clkType: amdsmi_clk_type_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_od_clk_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, level, clkvalue, clkType)
    }
    #[doc = "  @brief This function sets  1 of the 3 voltage curve points. It is not supported\n  on virtual machine guest\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a voltage point @p vpoint\n  and a voltage value @p voltvalue this function will set voltage curve point\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] vpoint voltage point [0|1|2] on the voltage curve\n\n  @param[in] clkvalue clock value component of voltage curve point.\n  Frequency values are in MHz.\n\n  @param[in] voltvalue voltage value component of voltage curve point.\n  Voltage is in mV.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_od_volt_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        vpoint: u32,
        clkvalue: u64,
        voltvalue: u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_od_volt_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, vpoint, clkvalue, voltvalue)
    }
    #[doc = "  @brief This function will retrieve the current valid regions in the\n  frequency/voltage space. It is not supported on virtual machine guest\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a pointer to an unsigned integer\n  @p num_regions and a buffer of ::amdsmi_freq_volt_region_t structures, @p\n  buffer, this function will populate @p buffer with the current\n  frequency-volt space regions. The caller should assign @p buffer to memory\n  that can be written to by this function. The caller should also\n  indicate the number of ::amdsmi_freq_volt_region_t structures that can safely\n  be written to @p buffer in @p num_regions.\n\n  The number of regions to expect this function provide (@p num_regions) can\n  be obtained by calling :: amdsmi_get_gpu_od_volt_info().\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] num_regions As input, this is the number of\n  ::amdsmi_freq_volt_region_t structures that can be written to @p buffer. As\n  output, this is the number of ::amdsmi_freq_volt_region_t structures that were\n  actually written.\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in,out] buffer a caller provided buffer to which\n  ::amdsmi_freq_volt_region_t structures will be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_od_volt_curve_regions(
        &self,
        processor_handle: amdsmi_processor_handle,
        num_regions: *mut u32,
        buffer: *mut amdsmi_freq_volt_region_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_od_volt_curve_regions
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, num_regions, buffer)
    }
    #[doc = "  @brief Get the list of available preset power profiles and an indication of\n  which profile is currently active. It is not supported on virtual machine guest\n\n  @ingroup tagClkPowerPerfQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a pointer to a\n  ::amdsmi_power_profile_status_t @p status, this function will set the bits of\n  the ::amdsmi_power_profile_status_t.available_profiles bit field of @p status to\n  1 if the profile corresponding to the respective\n  ::amdsmi_power_profile_preset_masks_t profiles are enabled. For example, if both\n  the VIDEO and VR power profiles are available selections, then\n  ::AMDSMI_PWR_PROF_PRST_VIDEO_MASK AND'ed with\n  ::amdsmi_power_profile_status_t.available_profiles will be non-zero as will\n  ::AMDSMI_PWR_PROF_PRST_VR_MASK AND'ed with\n  ::amdsmi_power_profile_status_t.available_profiles. Additionally,\n  ::amdsmi_power_profile_status_t.current will be set to the\n  ::amdsmi_power_profile_preset_masks_t of the profile that is currently active.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[in,out] status a pointer to ::amdsmi_power_profile_status_t that will be\n  populated by a call to this function\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_power_profile_presets(
        &self,
        processor_handle: amdsmi_processor_handle,
        sensor_ind: u32,
        status: *mut amdsmi_power_profile_status_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_power_profile_presets
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, sensor_ind, status)
    }
    #[doc = "  @brief Set the PowerPlay performance level associated with the device with\n  provided processor handle with the provided value. It is not supported\n  on virtual machine guest\n\n  @ingroup tagClkPowerPerfControl\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and an ::amdsmi_dev_perf_level_t @p\n  perf_level, this function will set the PowerPlay performance level for the\n  device to the value @p perf_lvl.\n\n  @note This function requires root access\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] perf_lvl the value to which the performance level should be set\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_perf_level(
        &self,
        processor_handle: amdsmi_processor_handle,
        perf_lvl: amdsmi_dev_perf_level_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_perf_level
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, perf_lvl)
    }
    #[doc = "  @brief Set the overdrive percent associated with the device with provided\n  processor handle with the provided value. See details for WARNING. It is\n  not supported on virtual machine guest\n\n  @ingroup tagClkPowerPerfControl\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and an overdrive level @p od,\n  this function will set the overdrive level for the device to the value\n  @p od. The overdrive level is an integer value between 0 and 20, inclusive,\n  which represents the overdrive percentage; e.g., a value of 5 specifies\n  an overclocking of 5%.\n\n  The overdrive level is specific to the gpu system clock.\n\n  The overdrive level is the percentage above the maximum Performance Level\n  to which overclocking will be limited. The overclocking percentage does\n  not apply to clock speeds other than the maximum. This percentage is\n  limited to 20%.\n\n   ******WARNING******\n  Operating your AMD GPU outside of official AMD specifications or outside of\n  factory settings, including but not limited to the conducting of\n  overclocking (including use of this overclocking software, even if such\n  software has been directly or indirectly provided by AMD or otherwise\n  affiliated in any way with AMD), may cause damage to your AMD GPU, system\n  components and/or result in system failure, as well as cause other problems.\n  DAMAGES CAUSED BY USE OF YOUR AMD GPU OUTSIDE OF OFFICIAL AMD SPECIFICATIONS\n  OR OUTSIDE OF FACTORY SETTINGS ARE NOT COVERED UNDER ANY AMD PRODUCT\n  WARRANTY AND MAY NOT BE COVERED BY YOUR BOARD OR SYSTEM MANUFACTURER'S\n  WARRANTY. Please use this utility with caution.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] od the value to which the overdrive level should be set\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_overdrive_level(
        &self,
        processor_handle: amdsmi_processor_handle,
        od: u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_overdrive_level
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, od)
    }
    #[doc = "  @brief Control the set of allowed frequencies that can be used for the\n  specified clock. It is not supported on virtual machine guest\n\n  @ingroup tagClkPowerPerfControl\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a clock type @p clk_type, and a\n  64 bit bitmask @p freq_bitmask, this function will limit the set of\n  allowable frequencies. If a bit in @p freq_bitmask has a value of 1, then\n  the frequency (as ordered in an ::amdsmi_frequencies_t returned by\n  amdsmi_get_clk_freq()) corresponding to that bit index will be\n  allowed.\n\n  This function will change the performance level to\n  ::AMDSMI_DEV_PERF_LEVEL_MANUAL in order to modify the set of allowable\n  frequencies. Caller will need to set to ::AMDSMI_DEV_PERF_LEVEL_AUTO in order\n  to get back to default state.\n\n  All bits with indices greater than or equal to\n  ::amdsmi_frequencies_t::num_supported will be ignored.\n\n  @note This function requires root access\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] clk_type the type of clock for which the set of frequencies\n  will be modified\n\n  @param[in] freq_bitmask A bitmask indicating the indices of the\n  frequencies that are to be enabled (1) and disabled (0). Only the lowest\n  ::amdsmi_frequencies_t.num_supported bits of this mask are relevant.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_clk_freq(
        &self,
        processor_handle: amdsmi_processor_handle,
        clk_type: amdsmi_clk_type_t,
        freq_bitmask: u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_clk_freq
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, clk_type, freq_bitmask)
    }
    #[doc = "  @brief Get the soc pstate policy for the processor\n\n  @ingroup tagClkPowerPerfControl\n\n  @platform{gpu_bm_linux} @platform{guest_1vf} @platform{host}\n\n  @details Given a processor handle @p processor_handle, this function will write\n  current soc pstate  policy settings to @p policy. All the processors at the same socket\n  will have the same policy.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] policy the soc pstate policy for this processor.\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_soc_pstate(
        &self,
        processor_handle: amdsmi_processor_handle,
        policy: *mut amdsmi_dpm_policy_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_soc_pstate
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, policy)
    }
    #[doc = "  @brief Set the soc pstate policy for the processor\n\n  @ingroup tagClkPowerPerfControl\n\n  @platform{gpu_bm_linux} @platform{guest_1vf} @platform{host}\n\n  @details Given a processor handle @p processor_handle and a soc pstate  policy @p policy_id,\n  this function will set the soc pstate  policy for this processor. All the processors at\n  the same socket will be set to the same policy.\n\n  @note This function requires root access\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] policy_id the soc pstate  policy id to set. The id is the id in\n  amdsmi_dpm_policy_entry_t, which can be obtained by calling\n  amdsmi_get_soc_pstate()\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_soc_pstate(
        &self,
        processor_handle: amdsmi_processor_handle,
        policy_id: u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_soc_pstate
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, policy_id)
    }
    #[doc = "  @brief Get the xgmi per-link power down policy parameter for the processor\n\n  @ingroup tagClkPowerPerfControl\n\n  @platform{gpu_bm_linux} @platform{guest_1vf} @platform{host}\n\n  @details Given a processor handle @p processor_handle, this function will write\n  current xgmi plpd settings to @p policy. All the processors at the same socket\n  will have the same policy.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] xgmi_plpd the xgmi plpd for this processor.\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_xgmi_plpd(
        &self,
        processor_handle: amdsmi_processor_handle,
        xgmi_plpd: *mut amdsmi_dpm_policy_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_xgmi_plpd
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, xgmi_plpd)
    }
    #[doc = "  @brief Set the xgmi per-link power down policy parameter for the processor\n\n  @ingroup tagClkPowerPerfControl\n\n  @platform{gpu_bm_linux} @platform{guest_1vf}\n\n  @details Given a processor handle @p processor_handle and a dpm policy @p policy_id,\n  this function will set the xgmi plpd for this processor. All the processors at\n  the same socket will be set to the same policy.\n\n  @note This function requires root access\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] policy_id the xgmi plpd id to set. The id is the id in\n  amdsmi_dpm_policy_entry_t, which can be obtained by calling\n  amdsmi_get_xgmi_plpd()\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_xgmi_plpd(
        &self,
        processor_handle: amdsmi_processor_handle,
        policy_id: u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_xgmi_plpd
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, policy_id)
    }
    #[doc = "  @brief Get the status of the Process Isolation\n\n  @ingroup tagClkPowerPerfControl\n\n  @platform{gpu_bm_linux} @platform{guest_1vf} @platform{guest_windows}\n\n  @details Given a processor handle @p processor_handle, this function will write\n  current process isolation status to @p pisolate. The 0 is the process isolation\n  disabled, and the 1 is the process isolation enabled.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] pisolate the process isolation status.\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_process_isolation(
        &self,
        processor_handle: amdsmi_processor_handle,
        pisolate: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_process_isolation
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, pisolate)
    }
    #[doc = "  @brief Enable/disable the system Process Isolation\n\n  @ingroup tagClkPowerPerfControl\n\n  @platform{gpu_bm_linux} @platform{guest_1vf} @platform{guest_windows}\n\n  @details Given a processor handle @p processor_handle and a process isolation @p pisolate,\n  flag, this function will set the Process Isolation for this processor. The 0 is the process\n  isolation disabled, and the 1 is the process isolation enabled.\n\n  @note This function requires root access\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] pisolate the process isolation status to set.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_process_isolation(
        &self,
        processor_handle: amdsmi_processor_handle,
        pisolate: u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_process_isolation
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, pisolate)
    }
    #[doc = "  @brief Run the cleaner shader to clean up data in LDS/GPRs\n\n  @ingroup tagClkPowerPerfControl\n\n  @platform{gpu_bm_linux} @platform{guest_1vf} @platform{guest_windows}\n\n  @details Given a processor handle @p processor_handle,\n  this function will clean the local data of this processor. This can be called between\n  user logins to prevent information leak.\n\n  @note This function requires root access\n\n  @param[in] processor_handle a processor handle\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_clean_gpu_local_data(&self, processor_handle: amdsmi_processor_handle) -> amdsmi_status_t {
        (self
            .amdsmi_clean_gpu_local_data
            .as_ref()
            .expect("Expected function, got error."))(processor_handle)
    }
    #[doc = "  @brief Get the build version information for the currently running build of AMDSMI\n\n  @ingroup tagVersionQuery\n\n  @platform{gpu_bm_linux} @platform{cpu_bm} @platform{guest_1vf} @platform{guest_mvf}\n  @platform{guest_windows}\n\n  @details  Get the major, minor, patch and build string for AMDSMI build\n  currently in use through @p version\n\n  @param[in,out] version A pointer to an ::amdsmi_version_t structure that will\n  be updated with the version information upon return.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_lib_version(&self, version: *mut amdsmi_version_t) -> amdsmi_status_t {
        (self
            .amdsmi_get_lib_version
            .as_ref()
            .expect("Expected function, got error."))(version)
    }
    #[doc = "  @brief Retrieve the error counts for a GPU block. It is not supported on virtual\n  machine guest\n\n  See [RAS Error Count sysfs Interface (AMDGPU RAS Support - Linux Kernel\n  documentation)](https://docs.kernel.org/gpu/amdgpu/ras.html#ras-error-count-sysfs-interface)\n  to learn how these error counts are accessed.\n\n  @ingroup tagECCInfo\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @details Given a processor handle @p processor_handle, an ::amdsmi_gpu_block_t @p block and a\n  pointer to an ::amdsmi_error_count_t @p ec, this function will write the error\n  count values for the GPU block indicated by @p block to memory pointed to by\n  @p ec.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] block The block for which error counts should be retrieved\n\n  @param[in,out] ec A pointer to an ::amdsmi_error_count_t to which the error\n  counts should be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_ecc_count(
        &self,
        processor_handle: amdsmi_processor_handle,
        block: amdsmi_gpu_block_t,
        ec: *mut amdsmi_error_count_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_ecc_count
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, block, ec)
    }
    #[doc = "  @brief Retrieve the enabled ECC bit-mask. It is not supported on virtual machine guest\n\n  See [RAS Error Count sysfs Interface (AMDGPU RAS Support - Linux Kernel\n  documentation)](https://docs.kernel.org/gpu/amdgpu/ras.html#ras-error-count-sysfs-interface)\n  to learn how these error counts are accessed.\n\n  @ingroup tagECCInfo\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @details Given a processor handle @p processor_handle, and a pointer to a uint64_t @p\n  enabled_mask, this function will write bits to memory pointed to by\n  @p enabled_blocks. Upon a successful call, @p enabled_blocks can then be\n  AND'd with elements of the ::amdsmi_gpu_block_t ennumeration to determine if\n  the corresponding block has ECC enabled. Note that whether a block has ECC\n  enabled or not in the device is independent of whether there is kernel\n  support for error counting for that block. Although a block may be enabled,\n  but there may not be kernel support for reading error counters for that\n  block.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] enabled_blocks A pointer to a uint64_t to which the enabled\n  blocks bits will be written.\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_ecc_enabled(
        &self,
        processor_handle: amdsmi_processor_handle,
        enabled_blocks: *mut u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_ecc_enabled
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, enabled_blocks)
    }
    #[doc = "  @brief Returns the total number of ECC errors (correctable,\n         uncorrectable and deferred) in the given GPU. It is not supported on\n         virtual machine guest\n\n  See [RAS Error Count sysfs Interface (AMDGPU RAS Support - Linux Kernel\n  documentation)](https://docs.kernel.org/gpu/amdgpu/ras.html#ras-error-count-sysfs-interface)\n  to learn how these error counts are accessed.\n\n  @ingroup tagECCInfo\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_windows}\n\n  @param[in] processor_handle Device which to query\n\n  @param[out] ec Reference to ecc error count structure.\n              Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_total_ecc_count(
        &self,
        processor_handle: amdsmi_processor_handle,
        ec: *mut amdsmi_error_count_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_total_ecc_count
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, ec)
    }
    #[doc = " @brief Retrieve CPER entries cached in the driver.\n\n The user will pass buffers to hold the CPER data and CPER headers. The library will\n fill the buffer based on the severity_mask user passed. It will also parse the CPER header\n and stored in the cper_hdrs array. The user can use the cper_hdrs to get the timestamp and other header information.\n A cursor is also returned to the user, which can be used to get the next set of CPER entries.\n\n If there are more data than any of the buffers user pass, the library will return AMDSMI_STATUS_MORE_DATA.\n User can call the API again with the cursor returned at previous call to get more data.\n If the buffer size is too small to even hold one entry, the library\n will return AMDSMI_STATUS_OUT_OF_RESOURCES.\n\n Even if the API returns AMDSMI_STATUS_MORE_DATA, the 2nd call may still get the entry_count == 0 as the driver\n cache may not contain the serverity user is interested in. The API should return AMDSMI_STATUS_SUCCESS in this case\n so that user can ignore that call.\n\n @ingroup tagECCInfo\n\n @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf}\n\n @param[in] processor_handle Handle to the processor for which CPER entries are to be retrieved.\n @param[in] severity_mask The severity mask of the entries to be retrieved.\n @param[in,out] cper_data Pointer to a buffer where the CPER data will be stored. User must allocate the buffer\n                and set the buf_size correctly.\n @param[in,out] buf_size Pointer to a variable that specifies the size of the cper_data.\n                On return, it will contain the actual size of the data written to the cper_data.\n @param[in,out] cper_hdrs Array of the parsed headers of the cper_data. The user must allocate\n                the array of pointers to cper_hdr. The library will fill the array with the pointers to the parsed\n                headers. The underlying data is in the cper_data buffer and only pointer is stored in this array.\n @param[in,out] entry_count Pointer to a variable that specifies the array length of the cper_hdrs user allocated.\n                On return, it will contain the actual entries written to the cper_hdrs.\n @param[in,out] cursor Pointer to a variable that will contain the  cursor  for the next call.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_cper_entries(
        &self,
        processor_handle: amdsmi_processor_handle,
        severity_mask: u32,
        cper_data: *mut ::std::os::raw::c_char,
        buf_size: *mut u64,
        cper_hdrs: *mut *mut amdsmi_cper_hdr_t,
        entry_count: *mut u64,
        cursor: *mut u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_cper_entries
            .as_ref()
            .expect("Expected function, got error."))(
            processor_handle,
            severity_mask,
            cper_data,
            buf_size,
            cper_hdrs,
            entry_count,
            cursor,
        )
    }
    #[doc = "  @brief Get the AFIDs from CPER buffer\n\n  @ingroup tagRasInfo\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf}\n  @platform{guest_mvf}\n\n  @details A utility function which retrieves the AFIDs from the CPER record.\n\n  @param[in] cper_buffer a pointer to the buffer with one CPER record.\n  The caller must make sure the whole CPER record is loaded into the buffer.\n\n  @param[in] buf_size is the size of the cper_buffer.\n\n  @param[out] afids a pointer to an array of uint64_t to which the AF IDs will be written\n\n  @param[in,out] num_afids As input, the value passed through this parameter is the number of\n  uint64_t that may be safely written to the memory pointed to by @p afids. This is the limit\n  on how many AF IDs will be written to @p afids. On return, @p num_afids will contain the\n  number of AF IDs written to @p afids, or the number of AF IDs that could have been written\n  if enough memory had been provided. It is suggest to pass MAX_NUMBER_OF_AFIDS_PER_RECORD for all\n  AF Ids.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_afids_from_cper(
        &self,
        cper_buffer: *mut ::std::os::raw::c_char,
        buf_size: u32,
        afids: *mut u64,
        num_afids: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_afids_from_cper
            .as_ref()
            .expect("Expected function, got error."))(cper_buffer, buf_size, afids, num_afids)
    }
    #[doc = "  @brief Returns RAS features info.\n\n  @ingroup tagRasInfo\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @param[in] processor_handle Device handle which to query\n\n  @param[out] ras_feature RAS features that are currently enabled and supported on\n  the processor. Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_ras_feature_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        ras_feature: *mut amdsmi_ras_feature_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_ras_feature_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, ras_feature)
    }
    #[doc = "  @brief Retrieve the ECC status for a GPU block. It is not supported on virtual machine\n  guest\n\n  See [RAS Error Count sysfs Interface (AMDGPU RAS Support - Linux Kernel\n  documentation)](https://docs.kernel.org/gpu/amdgpu/ras.html#ras-error-count-sysfs-interface)\n  to learn how these error counts are accessed.\n\n  @ingroup tagErrorQuery\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, an ::amdsmi_gpu_block_t @p block and\n  a pointer to an ::amdsmi_ras_err_state_t @p state, this function will write\n  the current state for the GPU block indicated by @p block to memory pointed\n  to by @p state.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] block The block for which error counts should be retrieved\n\n  @param[in,out] state A pointer to an ::amdsmi_ras_err_state_t to which the\n  ECC state should be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_ecc_status(
        &self,
        processor_handle: amdsmi_processor_handle,
        block: amdsmi_gpu_block_t,
        state: *mut amdsmi_ras_err_state_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_ecc_status
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, block, state)
    }
    #[doc = "  @brief Get a description of a provided AMDSMI error status\n\n  @ingroup tagErrorQuery\n\n  @platform{gpu_bm_linux} @platform{host} @platform{cpu_bm} @platform{guest_1vf} @platform{guest_mvf}\n\n  @details Set the provided pointer to a const char *, @p status_string, to\n  a string containing a description of the provided error code @p status.\n\n  @param[in] status The error status for which a description is desired\n\n  @param[in,out] status_string A pointer to a const char * which will be made\n  to point to a description of the provided error code\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_status_code_to_string(
        &self,
        status: amdsmi_status_t,
        status_string: *mut *const ::std::os::raw::c_char,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_status_code_to_string
            .as_ref()
            .expect("Expected function, got error."))(status, status_string)
    }
    #[doc = "  @brief Tell if an event group is supported by a given device. It is not supported\n  on virtual machine guest\n\n  @ingroup tagPerfCounter\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and an event group specifier @p\n  group, tell if @p group type events are supported by the device associated\n  with @p processor_handle\n\n  @param[in] processor_handle processor handle of device being queried\n\n  @param[in] group ::amdsmi_event_group_t identifier of group for which support\n  is being queried\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_gpu_counter_group_supported(
        &self,
        processor_handle: amdsmi_processor_handle,
        group: amdsmi_event_group_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_gpu_counter_group_supported
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, group)
    }
    #[doc = "  @brief Create a performance counter object\n\n  @ingroup tagPerfCounter\n\n  @platform{gpu_bm_linux}\n\n  @details Create a performance counter object of type @p type for the device\n  with a processor handle of @p processor_handle, and write a handle to the object to the\n  memory location pointed to by @p evnt_handle. @p evnt_handle can be used\n  with other performance event operations. The handle should be deallocated\n  with ::amdsmi_gpu_destroy_counter() when no longer needed.\n\n  @note This function requires root access\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] type the ::amdsmi_event_type_t of performance event to create\n\n  @param[in,out] evnt_handle A pointer to a ::amdsmi_event_handle_t which will be\n  associated with a newly allocated counter\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_gpu_create_counter(
        &self,
        processor_handle: amdsmi_processor_handle,
        type_: amdsmi_event_type_t,
        evnt_handle: *mut amdsmi_event_handle_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_gpu_create_counter
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, type_, evnt_handle)
    }
    #[doc = "  @brief Deallocate a performance counter object\n\n  @ingroup tagPerfCounter\n\n  @platform{gpu_bm_linux}\n\n  @details Deallocate the performance counter object with the provided\n  ::amdsmi_event_handle_t @p evnt_handle\n\n  @note This function requires root access\n\n  @param[in] evnt_handle handle to event object to be deallocated\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_gpu_destroy_counter(&self, evnt_handle: amdsmi_event_handle_t) -> amdsmi_status_t {
        (self
            .amdsmi_gpu_destroy_counter
            .as_ref()
            .expect("Expected function, got error."))(evnt_handle)
    }
    #[doc = "  @brief Issue performance counter control commands. It is not supported on\n  virtual machine guest\n\n  @ingroup tagPerfCounter\n\n  @platform{gpu_bm_linux}\n\n  @details Issue a command @p cmd on the event counter associated with the\n  provided handle @p evt_handle.\n\n  @note This function requires root access\n\n  @param[in] evt_handle an event handle\n\n  @param[in] cmd The event counter command to be issued\n\n  @param[in,out] cmd_args Currently not used. Should be set to NULL.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_gpu_control_counter(
        &self,
        evt_handle: amdsmi_event_handle_t,
        cmd: amdsmi_counter_command_t,
        cmd_args: *mut ::std::os::raw::c_void,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_gpu_control_counter
            .as_ref()
            .expect("Expected function, got error."))(evt_handle, cmd, cmd_args)
    }
    #[doc = "  @brief Read the current value of a performance counter\n\n  @ingroup tagPerfCounter\n\n  @platform{gpu_bm_linux}\n\n  @details Read the current counter value of the counter associated with the\n  provided handle @p evt_handle and write the value to the location pointed\n  to by @p value.\n\n  @note This function requires root access\n\n  @param[in] evt_handle an event handle\n\n  @param[in,out] value pointer to memory of size of ::amdsmi_counter_value_t to\n  which the counter value will be written\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_gpu_read_counter(
        &self,
        evt_handle: amdsmi_event_handle_t,
        value: *mut amdsmi_counter_value_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_gpu_read_counter
            .as_ref()
            .expect("Expected function, got error."))(evt_handle, value)
    }
    #[doc = "  @brief Get the number of currently available counters. It is not supported on\n  virtual machine guest\n\n  @ingroup tagPerfCounter\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a performance event group @p grp,\n  and a pointer to a uint32_t @p available, this function will write the\n  number of @p grp type counters that are available on the device with handle\n  @p processor_handle to the memory that @p available points to.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] grp an event device group\n\n  @param[in,out] available A pointer to a uint32_t to which the number of\n  available counters will be written\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_available_counters(
        &self,
        processor_handle: amdsmi_processor_handle,
        grp: amdsmi_event_group_t,
        available: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_available_counters
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, grp, available)
    }
    #[doc = "  @brief Get process information about processes currently using GPU\n\n  @ingroup tagSystemInfo\n\n  @platform{gpu_bm_linux}\n\n  @details Given a non-NULL pointer to an array @p procs of\n  ::amdsmi_process_info_t's, of length *@p num_items, this function will write\n  up to *@p num_items instances of ::amdsmi_process_info_t to the memory pointed\n  to by @p procs. These instances contain information about each process\n  utilizing a GPU. If @p procs is not NULL, @p num_items will be updated with\n  the number of processes actually written. If @p procs is NULL, @p num_items\n  will be updated with the number of processes for which there is current\n  process information. Calling this function with @p procs being NULL is a way\n  to determine how much memory should be allocated for when @p procs is not\n  NULL.\n\n  @param[in,out] procs a pointer to memory provided by the caller to which\n  process information will be written. This may be NULL in which case only @p\n  num_items will be updated with the number of processes found.\n\n  @param[in,out] num_items A pointer to a uint32_t, which on input, should\n  contain the amount of memory in ::amdsmi_process_info_t's which have been\n  provided by the @p procs argument. On output, if @p procs is non-NULL, this\n  will be updated with the number ::amdsmi_process_info_t structs actually\n  written. If @p procs is NULL, this argument will be updated with the number\n  processes for which there is information.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_compute_process_info(
        &self,
        procs: *mut amdsmi_process_info_t,
        num_items: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_compute_process_info
            .as_ref()
            .expect("Expected function, got error."))(procs, num_items)
    }
    #[doc = "  @brief Get process information about a specific process\n\n  @ingroup tagSystemInfo\n\n  @platform{gpu_bm_linux}\n\n  @details Given a pointer to an ::amdsmi_process_info_t @p proc and a process\n  id\n  @p pid, this function will write the process information for @p pid, if\n  available, to the memory pointed to by @p proc.\n\n  @param[in] pid The process ID for which process information is being\n  requested\n\n  @param[in,out] proc a pointer to a ::amdsmi_process_info_t to which\n  process information for @p pid will be written if it is found.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_compute_process_info_by_pid(
        &self,
        pid: u32,
        proc_: *mut amdsmi_process_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_compute_process_info_by_pid
            .as_ref()
            .expect("Expected function, got error."))(pid, proc_)
    }
    #[doc = "  @brief Get the device indices currently being used by a process\n\n  @ingroup tagSystemInfo\n\n  @platform{gpu_bm_linux}\n\n  @details Given a process id @p pid, a non-NULL pointer to an array of\n  uint32_t's @p processor_handleices of length *@p num_devices, this function will\n  write up to @p num_devices device indices to the memory pointed to by\n  @p processor_handleices. If @p processor_handleices is not NULL, @p num_devices will be\n  updated with the number of gpu's currently being used by process @p pid.\n  If @p processor_handleices is NULL, @p processor_handleices will be updated with the number of\n  gpus currently being used by @p pid. Calling this function with @p\n  dv_indices being NULL is a way to determine how much memory is required\n  for when @p processor_handleices is not NULL.\n\n  @param[in] pid The process id of the process for which the number of gpus\n  currently being used is requested\n\n  @param[in,out] dv_indices a pointer to memory provided by the caller to\n  which indices of devices currently being used by the process will be\n  written. This may be NULL in which case only @p num_devices will be\n  updated with the number of devices being used.\n\n  @param[in,out] num_devices A pointer to a uint32_t, which on input, should\n  contain the amount of memory in uint32_t's which have been provided by the\n  @p processor_handleices argument. On output, if @p processor_handleices is non-NULL, this will\n  be updated with the number uint32_t's actually written. If @p processor_handleices is\n  NULL, this argument will be updated with the number devices being used.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_compute_process_gpus(
        &self,
        pid: u32,
        dv_indices: *mut u32,
        num_devices: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_compute_process_gpus
            .as_ref()
            .expect("Expected function, got error."))(pid, dv_indices, num_devices)
    }
    #[doc = "  @brief Retrieve the XGMI error status for a device. It is not supported on\n  virtual machine guest\n\n  @ingroup tagXGMI\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, and a pointer to an\n  ::amdsmi_xgmi_status_t @p status, this function will write the current XGMI\n  error state ::amdsmi_xgmi_status_t for the device @p processor_handle to the memory\n  pointed to by @p status.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] status A pointer to an ::amdsmi_xgmi_status_t to which the\n  XGMI error state should be written\n  If this parameter is nullptr, this function will return\n  ::AMDSMI_STATUS_INVAL if the function is supported with the provided,\n  arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_gpu_xgmi_error_status(
        &self,
        processor_handle: amdsmi_processor_handle,
        status: *mut amdsmi_xgmi_status_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_gpu_xgmi_error_status
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, status)
    }
    #[doc = "  @brief Reset the XGMI error status for a device. It is not supported on virtual\n  machine guest\n\n  @ingroup tagXGMI\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, this function will reset the\n  current XGMI error state ::amdsmi_xgmi_status_t for the device @p processor_handle to\n  amdsmi_xgmi_status_t::AMDSMI_XGMI_STATUS_NO_ERRORS\n\n  @param[in] processor_handle a processor handle\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_reset_gpu_xgmi_error(&self, processor_handle: amdsmi_processor_handle) -> amdsmi_status_t {
        (self
            .amdsmi_reset_gpu_xgmi_error
            .as_ref()
            .expect("Expected function, got error."))(processor_handle)
    }
    #[doc = "  @brief          Returns XGMI information for the GPU.\n\n  @ingroup tagXGMI\n\n  @platform{gpu_bm_linux}\n\n  @param[in]      processor_handle Device which to query\n\n  @param[out]     info Reference to xgmi information structure. Must be\n                  allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_xgmi_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_xgmi_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_xgmi_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Get the XGMI link status\n\n  @ingroup tagXGMI\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle,  this function\n  will return the link status for each XGMI link connect to this processor.\n  If the processor link type is not XGMI, it should return AMDSMI_STATUS_NOT_SUPPORTED.\n\n  @param[in] processor_handle a processor handle\n\n  @param[out] link_status The link status of the XGMI connect to this processor.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_xgmi_link_status(
        &self,
        processor_handle: amdsmi_processor_handle,
        link_status: *mut amdsmi_xgmi_link_status_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_xgmi_link_status
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, link_status)
    }
    #[doc = "  @brief Return link metric information\n\n  @ingroup tagHWTopology\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @param[in] processor_handle PF of a processor for which to query\n\n  @param[out] link_metrics reference to the link metrics struct.\n  Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_link_metrics(
        &self,
        processor_handle: amdsmi_processor_handle,
        link_metrics: *mut amdsmi_link_metrics_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_link_metrics
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, link_metrics)
    }
    #[doc = "  @brief Retrieve the NUMA CPU node number for a device\n\n  @ingroup tagHWTopology\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @details Given a processor handle @p processor_handle, and a pointer to an\n  uint32_t @p numa_node, this function will write the\n  node number of NUMA CPU for the device @p processor_handle to the memory\n  pointed to by @p numa_node.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in,out] numa_node A pointer to an uint32_t to which the\n  numa node number should be written.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_topo_get_numa_node_number(
        &self,
        processor_handle: amdsmi_processor_handle,
        numa_node: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_topo_get_numa_node_number
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, numa_node)
    }
    #[doc = "  @brief Retrieve the weight for a connection between 2 GPUs\n\n  @ingroup tagHWTopology\n\n  @platform{gpu_bm_linux}\n\n  @details Given a source processor handle @p processor_handle_src and\n  a destination processor handle @p processor_handle_dst, and a pointer to an\n  uint64_t @p weight, this function will write the\n  weight for the connection between the device @p processor_handle_src\n  and @p processor_handle_dst to the memory pointed to by @p weight.\n\n  @param[in] processor_handle_src the source processor handle\n\n  @param[in] processor_handle_dst the destination processor handle\n\n  @param[in,out] weight A pointer to an uint64_t to which the\n  weight for the connection should be written.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_topo_get_link_weight(
        &self,
        processor_handle_src: amdsmi_processor_handle,
        processor_handle_dst: amdsmi_processor_handle,
        weight: *mut u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_topo_get_link_weight
            .as_ref()
            .expect("Expected function, got error."))(processor_handle_src, processor_handle_dst, weight)
    }
    #[doc = "  @brief Retreive minimal and maximal io link bandwidth between 2 GPUs\n\n  @ingroup tagHWTopology\n\n  @platform{gpu_bm_linux}\n\n  @details Given a source processor handle @p processor_handle_src and\n  a destination processor handle @p processor_handle_dst,  pointer to an\n  uint64_t @p min_bandwidth, and a pointer to uint64_t @p max_bandiwidth,\n  this function will write theoretical minimal and maximal bandwidth limits.\n  API works if src and dst are connected via xgmi and have 1 hop distance.\n\n  @param[in] processor_handle_src the source processor handle\n\n  @param[in] processor_handle_dst the destination processor handle\n\n  @param[in,out] min_bandwidth A pointer to an uint64_t to which the\n  minimal bandwidth for the connection should be written.\n\n  @param[in,out] max_bandwidth A pointer to an uint64_t to which the\n  maximal bandwidth for the connection should be written.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_minmax_bandwidth_between_processors(
        &self,
        processor_handle_src: amdsmi_processor_handle,
        processor_handle_dst: amdsmi_processor_handle,
        min_bandwidth: *mut u64,
        max_bandwidth: *mut u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_minmax_bandwidth_between_processors
            .as_ref()
            .expect("Expected function, got error."))(
            processor_handle_src,
            processor_handle_dst,
            min_bandwidth,
            max_bandwidth,
        )
    }
    #[doc = "  @brief Retrieve the hops and the connection type between 2 GPUs\n\n  @ingroup tagHWTopology\n\n  @platform{gpu_bm_linux}\n\n  @details Given a source processor handle @p processor_handle_src and\n  a destination processor handle @p processor_handle_dst, and a pointer to an\n  uint64_t @p hops and a pointer to an AMDSMI_INK_TYPE @p type,\n  this function will write the number of hops and the connection type\n  between the device @p processor_handle_src and @p processor_handle_dst to the memory\n  pointed to by @p hops and @p type.\n\n  @param[in] processor_handle_src the source processor handle\n\n  @param[in] processor_handle_dst the destination processor handle\n\n  @param[in,out] hops A pointer to an uint64_t to which the\n  hops for the connection should be written.\n\n  @param[in,out] type A pointer to an ::AMDSMI_LINK_TYPE to which the\n  type for the connection should be written.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_topo_get_link_type(
        &self,
        processor_handle_src: amdsmi_processor_handle,
        processor_handle_dst: amdsmi_processor_handle,
        hops: *mut u64,
        type_: *mut amdsmi_link_type_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_topo_get_link_type
            .as_ref()
            .expect("Expected function, got error."))(processor_handle_src, processor_handle_dst, hops, type_)
    }
    #[doc = "  @brief Retrieve the set of GPUs that are nearest to a given device\n         at a specific interconnectivity level.\n\n  @ingroup tagHWTopology\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @details Once called topology_nearest_info will get populated with a list of\n           all nearest devices for a given link_type. The list has a count of\n           the number of devices found and their respective handles/identifiers.\n\n  @param[in] processor_handle The identifier of the given device.\n\n  @param[in] link_type The amdsmi_link_type_t level to search for nearest GPUs.\n\n  @param[in,out] topology_nearest_info\n                 .count;\n                   - When zero, set to the number of matching GPUs such that .device_list can be malloc'd.\n                   - When non-zero, .device_list will be filled with count number of processor_handle.\n                 .device_list An array of processor_handle for GPUs found at level.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail."]
    pub unsafe fn amdsmi_get_link_topology_nearest(
        &self,
        processor_handle: amdsmi_processor_handle,
        link_type: amdsmi_link_type_t,
        topology_nearest_info: *mut amdsmi_topology_nearest_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_link_topology_nearest
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, link_type, topology_nearest_info)
    }
    #[doc = "  @brief Return P2P availability status between 2 GPUs\n\n  @ingroup tagHWTopology\n\n  @platform{gpu_bm_linux}\n\n  @details Given a source processor handle @p processor_handle_src and\n  a destination processor handle @p processor_handle_dst, and a pointer to a\n  bool @p accessible, this function will write the P2P connection status\n  between the device @p processor_handle_src and @p processor_handle_dst to the memory\n  pointed to by @p accessible.\n\n  @param[in] processor_handle_src the source processor handle\n\n  @param[in] processor_handle_dst the destination processor handle\n\n  @param[in,out] accessible A pointer to a bool to which the status for\n  the P2P connection availablity should be written.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_is_P2P_accessible(
        &self,
        processor_handle_src: amdsmi_processor_handle,
        processor_handle_dst: amdsmi_processor_handle,
        accessible: *mut bool,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_is_P2P_accessible
            .as_ref()
            .expect("Expected function, got error."))(processor_handle_src, processor_handle_dst, accessible)
    }
    #[doc = "  @brief Retrieve connection type and P2P capabilities between 2 GPUs\n\n  @ingroup tagHWTopology\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_mvf}\n\n  @details Given a source processor handle @p processor_handle_src and\n  a destination processor handle @p processor_handle_dst, a pointer to an amdsmi_link_type_t @p type,\n  and a pointer to amdsmi_p2p_capability_t @p cap. This function will write the connection type,\n  and io link capabilities between the device\n  @p processor_handle_src and @p processor_handle_dst to the memory\n  pointed to by @p cap and @p type.\n\n  @param[in] processor_handle_src the source processor handle\n\n  @param[in] processor_handle_dst the destination processor handle\n\n  @param[in,out] type A pointer to an ::amdsmi_link_type_t to which the\n  type for the connection should be written.\n\n  @param[in,out] cap A pointer to an ::amdsmi_p2p_capability_t to which the\n  io link capabilities should be written.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_topo_get_p2p_status(
        &self,
        processor_handle_src: amdsmi_processor_handle,
        processor_handle_dst: amdsmi_processor_handle,
        type_: *mut amdsmi_link_type_t,
        cap: *mut amdsmi_p2p_capability_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_topo_get_p2p_status
            .as_ref()
            .expect("Expected function, got error."))(processor_handle_src, processor_handle_dst, type_, cap)
    }
    #[doc = "  @brief Retrieves the current compute partitioning for a desired device\n\n  @ingroup tagComputePartition\n\n  @platform{gpu_bm_linux}\n\n  @details\n  Given a processor handle @p processor_handle and a string @p compute_partition ,\n  and uint32 @p len , this function will attempt to obtain the device's\n  current compute partition setting string. Upon successful retreival,\n  the obtained device's compute partition settings string shall be stored in\n  the passed @p compute_partition char string variable.\n\n  @param[in] processor_handle Device which to query\n\n  @param[inout] compute_partition a pointer to a char string variable,\n  which the device's current compute partition will be written to.\n\n  @param[in] len the length of the caller provided buffer @p compute_partition,\n  suggested length is 4 or greater.\n\n  @retval ::AMDSMI_STATUS_SUCCESS call was successful\n  @retval ::AMDSMI_STATUS_INVAL the provided arguments are not valid\n  @retval ::AMDSMI_STATUS_UNEXPECTED_DATA data provided to function is not valid\n  @retval ::AMDSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function\n  @retval ::AMDSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire compute partition value. In this case,\n  only @p len bytes will be written.\n  @return ::amdsmi_status_t"]
    pub unsafe fn amdsmi_get_gpu_compute_partition(
        &self,
        processor_handle: amdsmi_processor_handle,
        compute_partition: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_compute_partition
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, compute_partition, len)
    }
    #[doc = "  @brief Modifies a selected device's compute partition setting.\n\n  @ingroup tagComputePartition\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle, a type of compute partition\n  @p compute_partition, this function will attempt to update the selected\n  device's compute partition setting. This function does not allow any concurrent operations.\n  Device must be idle and have no workloads when performing set partition operations.\n\n  @param[in] processor_handle Device which to query\n\n  @param[in] compute_partition using enum ::amdsmi_compute_partition_type_t,\n  define what the selected device's compute partition setting should be\n  updated to.\n\n  @retval ::AMDSMI_STATUS_SUCCESS call was successful\n  @retval ::AMDSMI_STATUS_PERMISSION function requires root access\n  @retval ::AMDSMI_STATUS_INVAL the provided arguments are not valid\n  @retval ::AMDSMI_STATUS_SETTING_UNAVAILABLE the provided setting is\n  unavailable for current device\n  @retval ::AMDSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function\n  @return ::amdsmi_status_t"]
    pub unsafe fn amdsmi_set_gpu_compute_partition(
        &self,
        processor_handle: amdsmi_processor_handle,
        compute_partition: amdsmi_compute_partition_type_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_compute_partition
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, compute_partition)
    }
    #[doc = "  @brief Retrieves the current memory partition for a desired device\n\n  @ingroup tagMemoryPartition\n\n  @platform{gpu_bm_linux}\n\n  @details\n  Given a processor handle @p processor_handle and a string @p memory_partition ,\n  and uint32 @p len , this function will attempt to obtain the device's\n  memory partition string. Upon successful retreival, the obtained device's\n  memory partition string shall be stored in the passed @p memory_partition\n  char string variable.\n\n  @param[in] processor_handle Device which to query\n\n  @param[inout] memory_partition a pointer to a char string variable,\n  which the device's memory partition will be written to.\n\n  @param[in] len the length of the caller provided buffer @p memory_partition ,\n  suggested length is 5 or greater.\n\n  @retval ::AMDSMI_STATUS_SUCCESS call was successful\n  @retval ::AMDSMI_STATUS_INVAL the provided arguments are not valid\n  @retval ::AMDSMI_STATUS_UNEXPECTED_DATA data provided to function is not valid\n  @retval ::AMDSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function\n  @retval ::AMDSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire memory partition value. In this case,\n  only @p len bytes will be written.\n  @return ::amdsmi_status_t"]
    pub unsafe fn amdsmi_get_gpu_memory_partition(
        &self,
        processor_handle: amdsmi_processor_handle,
        memory_partition: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_memory_partition
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, memory_partition, len)
    }
    #[doc = "  @brief Modifies a selected device's current memory partition setting.\n\n  @ingroup tagMemoryPartition\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a type of memory partition\n  @p memory_partition, this function will attempt to update the selected\n  device's memory partition setting. This function does not allow any concurrent operations.\n  Device must be idle and have no workloads when performing set partition operations.\n\n  On @platform{gpu_bm_linux} AMDGPU driver restart is REQUIRED to complete updating to\n  the new memory partition setting. Refer to `amdsmi_gpu_driver_reload()` for more details.\n\n  @param[in] processor_handle Device which to query\n\n  @param[in] memory_partition using enum ::amdsmi_memory_partition_type_t,\n  define what the selected device's current mode setting should be updated to.\n\n  @retval ::AMDSMI_STATUS_SUCCESS call was successful\n  @retval ::AMDSMI_STATUS_PERMISSION function requires root access\n  @retval ::AMDSMI_STATUS_INVAL the provided arguments are not valid\n  @retval ::AMDSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function\n  @retval ::AMDSMI_STATUS_AMDGPU_RESTART_ERR could not successfully restart the amdgpu driver\n  @return ::amdsmi_status_t\n"]
    pub unsafe fn amdsmi_set_gpu_memory_partition(
        &self,
        processor_handle: amdsmi_processor_handle,
        memory_partition: amdsmi_memory_partition_type_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_memory_partition
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, memory_partition)
    }
    #[doc = "  @brief Returns current gpu memory partition capabilities\n\n  @ingroup tagMemoryPartition\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_mvf}\n\n  @param[in] processor_handle a processor handle\n\n  @param[out] config reference to the memory partition config.\n  Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_memory_partition_config(
        &self,
        processor_handle: amdsmi_processor_handle,
        config: *mut amdsmi_memory_partition_config_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_memory_partition_config
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, config)
    }
    #[doc = "  @brief Sets memory partition mode\n  Set accelerator partition setting based on profile_index\n  from amdsmi_get_gpu_accelerator_partition_profile_config\n\n  @ingroup tagMemoryPartition\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @details Given a processor handle @p processor_handle and a type of memory partition\n  @p mode, this function will attempt to update the selected\n  device's memory partition setting. This function does not allow any concurrent operations.\n  Device must be idle and have no workloads when performing set partition operations.\n\n  On @platform{gpu_bm_linux} AMDGPU driver restart is REQUIRED to complete updating to\n  the new memory partition setting. Refer to `amdsmi_gpu_driver_reload()` for more details.\n\n  @param[in] processor_handle A processor handle\n\n  @param[in] mode Enum representing memory partitioning mode to set\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_memory_partition_mode(
        &self,
        processor_handle: amdsmi_processor_handle,
        mode: amdsmi_memory_partition_type_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_memory_partition_mode
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, mode)
    }
    #[doc = "  @brief Returns gpu accelerator partition caps as currently configured in the system\n\n  @ingroup tagAcceleratorPartition\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_mvf}\n\n  @note User must use admin/elevated privledges to run this API, or API will not be able to read resources.\n  Otherwise, API will fill in the structure with as much information as possible.\n\n  @param[in] processor_handle Device which to query\n\n  @param[out] profile_config reference to the accelerator partition config.\n  Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_accelerator_partition_profile_config(
        &self,
        processor_handle: amdsmi_processor_handle,
        profile_config: *mut amdsmi_accelerator_partition_profile_config_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_accelerator_partition_profile_config
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, profile_config)
    }
    #[doc = "  @brief Returns current gpu accelerator partition cap\n\n  @ingroup tagAcceleratorPartition\n\n  @note User must use admin/elevated privledges to run this API, or API will not be able to read resources.\n  Otherwise, API will fill in the structure with as much information as possible.\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_mvf}\n\n  @param[in] processor_handle Device which to query\n\n  @param[out] profile reference to the accelerator partition profile.\n  Must be allocated by user.\n\n  @param[in,out] partition_id array of ids for current accelerator profile.\n  Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_accelerator_partition_profile(
        &self,
        processor_handle: amdsmi_processor_handle,
        profile: *mut amdsmi_accelerator_partition_profile_t,
        partition_id: *mut u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_accelerator_partition_profile
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, profile, partition_id)
    }
    #[doc = "  @brief Set accelerator partition setting based on profile_index\n  from amdsmi_get_gpu_accelerator_partition_profile_config\n\n  @ingroup tagAcceleratorPartition\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @note On @platform{gpu_bm_linux} User must use admin/elevated privledges\n  to run this API, or API will not be able to read resources.\n\n  @param[in] processor_handle Device which to query\n\n  @param[in] profile_index Represents index of a partition user wants to set\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_accelerator_partition_profile(
        &self,
        processor_handle: amdsmi_processor_handle,
        profile_index: u32,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_accelerator_partition_profile
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, profile_index)
    }
    #[doc = "  @brief Prepare to collect event notifications for a GPU\n\n  @ingroup tagEventNotification\n\n  @platform{gpu_bm_linux}\n\n  @details This function prepares to collect events for the GPU with device\n  ID @p processor_handle, by initializing any required system parameters. This call\n  may open files which will remain open until ::amdsmi_stop_gpu_event_notification()\n  is called.\n\n  @param[in] processor_handle a processor handle corresponding to the device on which to\n  listen for events\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_init_gpu_event_notification(
        &self,
        processor_handle: amdsmi_processor_handle,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_init_gpu_event_notification
            .as_ref()
            .expect("Expected function, got error."))(processor_handle)
    }
    #[doc = "  @brief Specify which events to collect for a device\n\n  @ingroup tagEventNotification\n\n  @platform{gpu_bm_linux}\n\n  @details Given a processor handle @p processor_handle and a @p mask consisting of\n  elements of ::amdsmi_evt_notification_type_t OR'd together, this function\n  will listen for the events specified in @p mask on the device\n  corresponding to @p processor_handle.\n\n  @param[in] processor_handle a processor handle corresponding to the device on which to\n  listen for events\n\n  @param[in] mask Bitmask generated by OR'ing 1 or more elements of\n  ::amdsmi_evt_notification_type_t indicating which event types to listen for,\n  where the amdsmi_evt_notification_type_t value indicates the bit field, with\n  bit position starting from 1.\n  For example, if the mask field is 0x0000000000000003, which means first bit,\n  bit 1 (bit position start from 1) and bit 2 are set, which indicate interest\n  in receiving AMDSMI_EVT_NOTIF_VMFAULT (which has a value of 1) and\n  AMDSMI_EVT_NOTIF_THERMAL_THROTTLE event (which has a value of 2).\n\n  @note ::AMDSMI_STATUS_INIT_ERROR is returned if\n  ::amdsmi_init_gpu_event_notification() has not been called before a call to this\n  function\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_set_gpu_event_notification_mask(
        &self,
        processor_handle: amdsmi_processor_handle,
        mask: u64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_set_gpu_event_notification_mask
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, mask)
    }
    #[doc = "  @brief Collect event notifications, waiting a specified amount of time\n\n  @ingroup tagEventNotification\n\n  @platform{gpu_bm_linux}\n\n  @details Given a time period @p timeout_ms in milliseconds and a caller-\n  provided buffer of ::amdsmi_evt_notification_data_t's @p data with a length\n  (in ::amdsmi_evt_notification_data_t's, also specified by the caller) in the\n  memory location pointed to by @p num_elem, this function will collect\n  ::amdsmi_evt_notification_type_t events for up to @p timeout_ms milliseconds,\n  and write up to *@p num_elem event items to @p data. Upon return @p num_elem\n  is updated with the number of events that were actually written. If events\n  are already present when this function is called, it will write the events\n  to the buffer then poll for new events if there is still caller-provided\n  buffer available to write any new events that would be found.\n\n  This function requires prior calls to ::amdsmi_init_gpu_event_notification() and\n  :: amdsmi_set_gpu_event_notification_mask(). This function polls for the\n  occurrance of the events on the respective devices that were previously\n  specified by :: amdsmi_set_gpu_event_notification_mask().\n\n  @param[in] timeout_ms number of milliseconds to wait for an event\n  to occur\n\n  @param[in,out] num_elem pointer to uint32_t, provided by the caller. On\n  input, this value tells how many ::amdsmi_evt_notification_data_t elements\n  are being provided by the caller with @p data. On output, the location\n  pointed to by @p num_elem will contain the number of items written to\n  the provided buffer.\n\n  @param[out] data pointer to a caller-provided memory buffer of size\n  @p num_elem ::amdsmi_evt_notification_data_t to which this function may safely\n  write. If there are events found, up to @p num_elem event items will be\n  written to @p data.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_event_notification(
        &self,
        timeout_ms: ::std::os::raw::c_int,
        num_elem: *mut u32,
        data: *mut amdsmi_evt_notification_data_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_event_notification
            .as_ref()
            .expect("Expected function, got error."))(timeout_ms, num_elem, data)
    }
    #[doc = "  @brief Close any file handles and free any resources used by event\n  notification for a GPU\n\n  @ingroup tagEventNotification\n\n  @platform{gpu_bm_linux}\n\n  @details Any resources used by event notification for the GPU with\n  processor handle @p processor_handle will be free with this\n  function. This includes freeing any memory and closing file handles. This\n  should be called for every call to ::amdsmi_init_gpu_event_notification()\n\n  @param[in] processor_handle The processor handle of the GPU for which event\n  notification resources will be free\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_stop_gpu_event_notification(
        &self,
        processor_handle: amdsmi_processor_handle,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_stop_gpu_event_notification
            .as_ref()
            .expect("Expected function, got error."))(processor_handle)
    }
    #[doc = "  @brief Returns the driver version information\n\n  @ingroup tagSoftwareVersion\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_mvf}\n  @platform{guest_windows}\n\n  @param[in] processor_handle Device which to query\n\n  @param[out] info Reference to driver information structure. Must be\n              allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_driver_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_driver_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_driver_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Returns the ASIC information for the device\n\n  @ingroup tagAsicBoardInfo\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_mvf}\n  @platform{guest_windows}\n\n  @details This function returns ASIC information such as the product name,\n           the vendor ID, the subvendor ID, the device ID,\n           the revision ID and the serial number.\n\n  @param[in] processor_handle Device which to query\n\n  @param[out] info Reference to static asic information structure.\n              Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_asic_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_asic_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_asic_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief          Returns the KFD (Kernel Fusion Driver) information for the device\n\n  @ingroup tagAsicBoardInfo\n\n  @platform{gpu_bm_linux}\n\n  @details        This function returns KFD information populated into the amdsmi_kfd_info_t.\n                  This contains the kfd_id and node_id which allow for the ID and\n                  index of this device in the KFD.\n\n  @param[in]      processor_handle Device which to query\n\n  @param[out]     info Reference to kfd information structure.\n                  Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_kfd_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_kfd_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_kfd_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Returns vram info\n\n  @ingroup tagAsicBoardInfo\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_mvf}\n\n  @param[in] processor_handle PF of a processor for which to query\n\n  @param[out] info Reference to vram info structure\n  Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_vram_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_vram_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_vram_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Returns the board part number and board information for the requested device\n\n  @ingroup tagAsicBoardInfo\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_mvf}\n\n  @param[in] processor_handle Device which to query\n\n  @param[out] info Reference to board info structure.\n              Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_board_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_board_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_board_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Returns the power caps as currently configured in the system.\n\n  @ingroup tagAsicBoardInfo\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @param[in] processor_handle Device which to query\n\n  @param[in] sensor_ind A 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n  Parameter @p sensor_ind is unused on @platform{host}.\n\n  @param[out] info Reference to power caps information structure. Must be\n  allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_power_cap_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        sensor_ind: u32,
        info: *mut amdsmi_power_cap_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_power_cap_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, sensor_ind, info)
    }
    #[doc = "  @brief Returns the PCIe info for the GPU.\n\n  @ingroup tagAsicBoardInfo\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_windows}\n\n  @param[in] processor_handle Device which to query\n\n  @param[out] info Reference to the PCIe information\n  returned by the library. Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_pcie_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_pcie_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_pcie_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Returns the 'xcd_counter' from the GPU metrics associated with the device\n\n  @ingroup tagAsicBoardInfo\n\n  @platform{gpu_bm_linux} @platform{guest_1vf} @platform{guest_mvf}\n\n  @param[in] processor_handle Device which to query\n\n  @param[inout] xcd_count a pointer to uint16_t to which the device gpu\n  metric unit will be stored. Must be allocated by user.\n\n  @retval ::AMDSMI_STATUS_SUCCESS is returned upon successful call.\n          ::AMDSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device."]
    pub unsafe fn amdsmi_get_gpu_xcd_counter(
        &self,
        processor_handle: amdsmi_processor_handle,
        xcd_count: *mut u16,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_xcd_counter
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, xcd_count)
    }
    #[doc = " @brief Retrieves node power management (NPM) status and power limit for the specified node.\n\n @ingroup tagNodeInfo\n\n @platform{gpu_bm_linux} @platform{host}\n\n @details This function queries the NPM controller for the given node and returns whether NPM is enabled,\n along with the current node-level power limit in Watts. The NPM status and limit are set out-of-band\n and reported via this API.\n\n @param[in]  node_handle Handle to the Node to query.\n @param[out] info Pointer to amdsmi_npm_info_t structure to receive NPM status and limit.\n             Must be allocated by the user.\n\n @return ::AMDSMI_STATUS_SUCCESS on success, non-zero on failure."]
    pub unsafe fn amdsmi_get_npm_info(
        &self,
        node_handle: amdsmi_node_handle,
        info: *mut amdsmi_npm_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_npm_info
            .as_ref()
            .expect("Expected function, got error."))(node_handle, info)
    }
    #[doc = "  @brief Returns the firmware versions running on the device.\n\n  @ingroup tagFWVbiosQuery\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_mvf}\n  @platform{guest_windows}\n\n  @param[in] processor_handle Device which to query\n\n  @param[out] info Reference to the fw info. Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_fw_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_fw_info_t,
    ) -> amdsmi_status_t {
        (self.amdsmi_get_fw_info.as_ref().expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Returns the static information for the vBIOS on the device.\n\n  @ingroup tagFWVbiosQuery\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_1vf} @platform{guest_mvf}\n  @platform{guest_windows}\n\n  @param[in] processor_handle Device which to query\n\n  @param[out] info Reference to static vBIOS information.\n              Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_vbios_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_vbios_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_vbios_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Get the temperature metric value for the specified metric, from the\n  specified temperature sensor on the specified device. It is not supported on\n  virtual machine guest\n\n  @ingroup tagGPUMonitor\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_windows}\n\n  @details Given a processor handle @p processor_handle, a sensor type @p sensor_type, a\n  ::amdsmi_temperature_metric_t @p metric and a pointer to an int64_t @p\n  temperature, this function will write the value of the metric indicated by\n  @p metric and @p sensor_type to the memory location @p temperature.\n\n  @param[in] processor_handle a processor handle\n\n  @param[in] sensor_type part of device from which temperature should be\n  obtained. This should come from the enum ::amdsmi_temperature_type_t\n\n  @param[in] metric enum indicated which temperature value should be\n  retrieved\n\n  @param[in,out] temperature a pointer to int64_t to which the temperature is in Celsius.\n  If this parameter is nullptr, this function will return ::AMDSMI_STATUS_INVAL if the function\n  is supported with the provided, arguments and ::AMDSMI_STATUS_NOT_SUPPORTED if it is not\n  supported with the provided arguments.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_temp_metric(
        &self,
        processor_handle: amdsmi_processor_handle,
        sensor_type: amdsmi_temperature_type_t,
        metric: amdsmi_temperature_metric_t,
        temperature: *mut i64,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_temp_metric
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, sensor_type, metric, temperature)
    }
    #[doc = "  @brief Returns the current usage of the GPU engines (GFX, MM and MEM).\n  Each usage is reported as a percentage from 0-100%.\n\n  @ingroup tagGPUMonitor\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_windows}\n\n  @param[in] processor_handle Device which to query\n\n  @param[out] info Reference to the gpu engine usage structure. Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_activity(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_engine_usage_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_activity
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Returns the current power and voltage of the GPU.\n\n  @ingroup tagGPUMonitor\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_windows} @platform{guest_1vf}\n\n  @note amdsmi_power_info_t::socket_power metric can rarely spike above the socket power limit in some cases\n  @note unsupported struct members are set to UINT32_MAX\n\n  @param[in] processor_handle PF of a processor for which  to query\n\n  @param[out] info Reference to the gpu power structure. Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_power_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_power_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_power_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Returns is power management enabled\n\n  @ingroup tagGPUMonitor\n\n  @platform{gpu_bm_linux} @platform{host}\n\n  @param[in] processor_handle PF of a processor for which to query\n\n  @param[out] enabled Reference to bool. Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_is_gpu_power_management_enabled(
        &self,
        processor_handle: amdsmi_processor_handle,
        enabled: *mut bool,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_is_gpu_power_management_enabled
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, enabled)
    }
    #[doc = "  @brief Returns the measurements of the clocks in the GPU\n         for the GFX and multimedia engines and Memory. This call\n         reports the averages over 1s in MHz. It is not supported\n         on virtual machine guest\n\n  @ingroup tagGPUMonitor\n\n  @platform{gpu_bm_linux} @platform{host} @platform{guest_windows}\n\n  @param[in] processor_handle Device which to query\n\n  @param[in] clk_type Enum representing the clock type to query.\n\n  @param[out] info Reference to the gpu clock structure.\n              Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_clock_info(
        &self,
        processor_handle: amdsmi_processor_handle,
        clk_type: amdsmi_clk_type_t,
        info: *mut amdsmi_clk_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_clock_info
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, clk_type, info)
    }
    #[doc = "  @brief          Returns the VRAM usage (both total and used memory)\n                  in MegaBytes.\n\n  @ingroup tagGPUMonitor\n\n  @platform{gpu_bm_linux}\n\n  @param[in]      processor_handle Device which to query\n\n  @param[out]     info Reference to vram information.\n                  Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_gpu_vram_usage(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_vram_usage_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_vram_usage
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief          Returns the violations for a processor\n\n  Warning: API will be slow due to polling driver for 2 samples. Require\n  a minimum wait of 100ms between the 2 samples in order to calculate. Otherwise\n  users would need to use amdsmi_get_gpu_metrics_info for BM. See that API's struct\n  for calculations.\n\n  @ingroup tagGPUMonitor\n\n  @platform{gpu_bm_linux}\n\n  @param[in]      processor_handle Device which to query\n\n  @param[out]     info Reference to all violation status details available.\n                  Must be allocated by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success, non-zero on fail"]
    pub unsafe fn amdsmi_get_violation_status(
        &self,
        processor_handle: amdsmi_processor_handle,
        info: *mut amdsmi_violation_status_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_violation_status
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, info)
    }
    #[doc = "  @brief Returns the list of process information running on a given GPU.\n  If pdh.dll is not present on the system, this API returns\n  AMDSMI_STATUS_NOT_SUPPORTED.\n\n  @ingroup tagProcessInfo\n\n  @platform{gpu_bm_linux} @platform{guest_windows}\n\n  @warning IMPORTANT: To get valid return values, at least 1 second needs to pass\n  from starting the program to the first call of this function,\n  and before every following call of this function after that, to get correct values\n\n  @note The user provides a buffer to store the list and the maximum\n        number of processes that can be returned. If the user sets\n        max_processes to 0, the current total number of processes will\n        replace max_processes param. After that, the function needs to be\n        called again, with updated max_processes, to successfully fill the\n        process list, which was previously allocated with max_processes\n\n  @note If the reserved size for processes is smaller than the number of\n        actual processes running. The AMDSMI_STATUS_OUT_OF_RESOURCES is\n        an indication the caller should handle the situation (resize).\n        The max_processes is always changed to reflect the actual size of\n        list of processes running, so the caller knows where it is at.\n\n  @param[in]      processor_handle Device which to query\n\n  @param[in,out]  max_processes Reference to the size of the list buffer in\n                  number of elements. Returns the return number of elements\n                  in list or the number of running processes if equal to 0,\n                  and if given value in param max_processes is less than\n                  number of processes currently running,\n                  AMDSMI_STATUS_OUT_OF_RESOURCES will be returned.\n\n                  For cases where max_process is not zero (0), it specifies the list's size limit.\n                  That is, the maximum size this list will be able to hold. After the list is built\n                  internally, as a return status, we will have AMDSMI_STATUS_OUT_OF_RESOURCES when\n                  the original size limit is smaller than the actual list of processes running.\n                  Hence, the caller is aware the list size needs to be resized, or\n                  AMDSMI_STATUS_SUCCESS otherwise.\n                  Holding a copy of max_process before it is passed in will be helpful for monitoring\n                  the allocations done upon each call since the max_process will permanently be changed\n                  to reflect the actual number of processes running.\n\n  @param[out]     list Reference to a user-provided buffer where the process\n                  list will be returned. This buffer must contain at least\n                  max_processes entries of type amd_proc_info_list_t. Must be allocated\n                  by user.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success,\n                            | ::AMDSMI_STATUS_OUT_OF_RESOURCES, filled list buffer with data, but number of\n                                actual running processes is larger than the size provided."]
    pub unsafe fn amdsmi_get_gpu_process_list(
        &self,
        processor_handle: amdsmi_processor_handle,
        max_processes: *mut u32,
        list: *mut amdsmi_proc_info_t,
    ) -> amdsmi_status_t {
        (self
            .amdsmi_get_gpu_process_list
            .as_ref()
            .expect("Expected function, got error."))(processor_handle, max_processes, list)
    }
    #[doc = "/\n/** @defgroup tagDriverControl Driver control mechanisms\n  These functions provide control over the driver. Users should use with\n  caution as they may cause the driver to become unstable.\n  @{\n/\n/**\n  @brief Restart the device driver (kmod module) for all AMD GPUs on the\n  system.\n\n  @ingroup tagDriverControl\n\n  @platform{gpu_bm_linux} @platform{guest_1vf} @platform{guest_mvf}\n\n  @details This function will reload the AMD GPU driver as described in\n  the Linux kernel documentation -\n  https://docs.kernel.org/admin-guide/sysctl/kernel.html#modprobe\n  with no extra parameters as specified in\n  https://docs.kernel.org/gpu/amdgpu/module-parameters.html.\n\n  Use this function with caution, as it will unload and reload the AMD GPU\n  driver: `modprobe -r amdgpu && modprobe amdgpu`.\n\n  Any process or workload using the AMD GPU driver is REQUIRED to be\n  stopped before calling this function. Otherwise, function will return\n  ::AMDSMI_STATUS_AMDGPU_RESTART_ERR could not successfully restart\n  the amdgpu driver.\n\n  User is REQUIRED to have root/admin privileges to call this function.\n  Otherwise, this function will return ::AMDSMI_STATUS_NO_PERM.\n\n  This API will take time to complete, as we are checking the driver's\n  loading status to confirm it reloaded properly. If\n  ::AMDSMI_STATUS_AMDGPU_RESTART_ERR is returned, it means the driver\n  did not reload properly and the user should check dmesg logs.\n\n  This function has been created in order to conviently reload the\n  AMD GPU driver once `amdsmi_set_gpu_memory_partition()` or\n  `amdsmi_set_gpu_memory_partition_mode()` successfully has been changed\n  on Baremetal systems. Now users can control the reload once all GPU\n  processes/workloads have been stopped on the AMD GPU driver.\n  A (AMD GPU) driver reload is REQUIRED to complete changing\n  to the new memory partition configuration\n  (`amdsmi_set_gpu_memory_partition()`/`amdsmi_set_gpu_memory_partition_mode()`)\n  operation MUST be successful. This function WILL EFFECT all GPUs in the\n  hive to be reconfigured with the specified memory partition configuration.\n\n  @return ::amdsmi_status_t | ::AMDSMI_STATUS_SUCCESS on success\n  @return                   | ::AMDSMI_STATUS_NO_PERM function requires root access\n  @return                   | ::AMDSMI_STATUS_AMDGPU_RESTART_ERR could not successfully restart\n                                the amdgpu driver."]
    pub unsafe fn amdsmi_gpu_driver_reload(&self) -> amdsmi_status_t {
        (self
            .amdsmi_gpu_driver_reload
            .as_ref()
            .expect("Expected function, got error."))()
    }
}
